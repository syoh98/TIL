### ✏️ JSP와 Servlet의 기본적인 동작 원리는 꼭 알아야 한다
* JSP의 라이프 사이클
  * JSP URL 호출
  * 페이지 번역
  * JSP 페이지 컴파일
  * 클래스 로드
  * 인스턴스 생성
  * `jspInit` 메서드 호출
  * `_jspService` 메서드 호출
  * `jspDestory` 메서드 호출
* Servlet의 라이프 사이클(WAS의 JVM이 시작한 이후에)
  * Servlet 객체가 자동으로 생성되고 초기화 되거나,
  * 사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화된다.
  * 그 다음 계속 '사용 가능' 상태로 대기한다
     * 중간에 예외가 발생하면 '사용 불가능' 상태로 빠졌다가 다시 '사용 가능' 상태로 변환되기도 한다.
     * 해당 서블릿이 더 이상 필요없을 때는 '파기' 상태로 넘어간 후 JVM에서 '제거'된다.
</br>

### ✏️ 적절한 include 사용하기
* JSP에서 include를 사용하면, 하나의 JSP에서 다른 JSP를 호출하여 여러 JSP 파일을 혼합해서 하나의 JSP로 만들 수 있다.
* 정적인 방식과 동적인 방식이 있다
  * **정적인 방식**
    * JSP의 라이프 사이클 중 JSP 페이지 번역 및 컴파일 단계에서 필요한 JSP를 읽어서 메인 JSP의 자바 소스 및 클래스에 포함 시키는 방식
    * `<%@include file="관련URL"%>`
  * **동적인 방식**
    * 페이지가 호출될 때마다 지정된 페이지를 불러들여서 수행하도록 되어있다
    * `<jsp:include page="relativeURL"/>`
  * 💡 동적인 방식이 정적인 방식보다 30배 느리다
    * ➡️ 성능을 빠르게 하려면 정적인 방식을 사용해야하지만, 화면에서 오류가 발생할 수 있다(정적인 방식을 사용하면 메인 JSP에 추가되는 JSP가 생긴다)
    * ➡️ 상황에 알맞은 include 방식을 선택하자
</br>

### ✏️ 자바 빈즈, 잘 쓰면 약 못 쓰면 독
* 자바 빈즈: UI에서 서버 측 데이터를 담아서 처리하기 위한 컴포넌트
* **🤔 자바 빈즈의 문제점은?**
  * 자바 빈즈를 통하여 useBean을 하면 성능에 많은 영향을 미치지는 않지만, 너무 많이 사용하면 JSP에서 소요되는 시간이 증가될 수 있다
  * 자바 빈즈를 처리하기 위한 시간을 줄이기 위해서는 TO(Transfer object) 패턴을 사용해야 한다.
  * 하나의 TO 클래스를 만들고, 사용된 문자열 및 HashMap, List를 그 클래스의 변수로 지정하여 사용하면 화면을 수행하는데 소요된 시간 중 48%가 절약된다.
  * 그러므로 TO를 만들어 사용하자.
</br>

### ✏️ 태그 라이브러리도 잘 써야 한다
* 태그 라이브러리: JSP에서 공통적으로 반복되는 코드를 클래스로 만들고, 그 클래스를 HTML 태그와 같이 정의된 태그로 사용할 수 있도록 하는 라이브러리
* **🤔 태그 라이브러리에서 성능상 문제가 발생할 때는 언제일까?**
  * 태그 라이브러리 클래스를 잘못 작성하거나 태크라이브러리 클래스로 전송되는 데이터가 많을 때 성능에 문제가 된다.
  * 태그 라이브러리는 태그 사이에 있는 데이터를 넘겨주어야 하는데, 이 때 넘겨주는 데이터 형태는 대부분 문자열 타입이다.
    * 따라서 데이터가 많으면 많을수록 처리를 해야 하는 내용이 많아지고, 자연히 태그 라이브러리 클래스에서 처리되는 시간이 많아질 수 밖에 없다.
    * ➡️ 목록을 처리하면서 대용량의 데이터를 처리할 경우에는 태그 라이브러리의 사용을 자제하자.
</br>

### ✏️ 스프링 프레임워크 간단 정리
* 스프링의 핵심기술
  * **Dependency Injection(의존성 주입)**
    * 객체 간의 의존관계를 관리하는 기술
    * ```java
      public class A {
          private B b = new B();
      }
      ```
      ➡️A 클래스의 객체는 항상 B클래스의 객체를 사용하게 된다 **(의존성이 높다)**
    * ```java
      public class A {
          private B b;
          public A(B b) {
              this.b = b;
          }
      }
      ```
      ➡️ 객체를 외부에서 넘겨 형태로 코드를 작성하면 보다 쉽게 A클래스가 사용하는 객체를 다른 것으로 변경할 수 있다 **(의존성이 낮다)**   
      ➡️ 스프링은 이렇게 의존성을 쉽게 주입하는 틀을 제공해 준다.
  * **Aspect Oriented Programming(관점 지향 프로그래밍)**
    * 트랜잭션, 로깅, 보완 체크 코드들은 여러 모듈, 여러 계층에 스며드는데 대부분은 비슷한 코드가 중복되고, 코드를 눈으로 읽는 데 방해가 된다.   
      ➡️ 이런 코드를 실제 비즈니스 로직과 분리할 수 있도록 도와주는 것이 `AOP`이다.
    * 자바에서 가장 유명한 AOP 프레임워크로는 AspectJ가 있다. 이 기술을 잘 활용하면 핵심 비즈니스 코드의 가독성을 높여준다.
  * **Portable Service Abstraction**
    * 비슷한 기술을 구현하기 위해 코딩하는 방법은 사용할 라이브러리나 프레임워크에 따라 달라지기 때문에, 추상화가 매우 중요하다.
    * 스프링은 비슷한 기술을 모두 아우를 수 있는 추상화 계층을 제공하여, 사용하는 기술이 바뀌더라도 비즈니스 로직의 변화가 없도록 도와준다.
</br>

### ✏️ 스프링 프레임워크를 사용하면서 발생할 수 있는 문제
* 스프링 프레임워크를 사용할 때 성능 관련 문제가 가장 많이 발생하는 부분은 `프록시`와 관련있다.
  * 스프링 프록시는 기본적으로 실행 시에 생성된다.
  * 따라서, 개발할 때 적은 요청을 할 때는 이상이 없다가, 요청량이 많은 운영 상황으로 넘어가면 문제가 나타날 수 있다.
  * 스프링이 프록시를 사용하게 하는 주요 기능은 트랜잭션이다(`@Transactional`)
  * `@Transactional` 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체를 만든다
