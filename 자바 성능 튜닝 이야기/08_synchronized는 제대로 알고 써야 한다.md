우리가 개발하는 WAS는 여러 개의 스레드가 동작하도록 되어 있다.   
그래서 synchronized를 자주 사용한다.   
하지만 synchronized를 쓴다고 무조건 안정적인 것은 아니며, 성능에 영향을 미치는 부분도 있다!   
</br>

**✏️자바에서 스레드는 어떻게 사용하나?**   
* 프로세스와 스레드   
  우리가 클래스를 하나 수행시키거나 WAS를 기동하면, 서버에 자바 프로세스가 하나 생성된다.   
  하나가 생성되는지 여러 개가 생성되는지는 윈도의 자원관리자나 리눅스, 유닉스의 프로세스를 조회해 보면 된다.   
  하나의 프로세스에는 여거 개의 스레드가 생성된다.   
  단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있다.
  그러므로 프로세스와 스레드의 관계는 일대다 관계이다.   
  스레드는 가벼운 프로세스이고, 프로세스에서 만들어 사용하고 있는 메모리를 공유한다.   
  그래서 별개의 프로세스가 하나씩 뜨는 것보다는 성능이나 자원 사용에 있어서 도움이 된다.   
* Thread 클래스 상속과 Runnable 인터페이스 구현(스레드의 구현방법)   
  기본적으로 Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 거의 차이가 없다.   
  대신 Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있다.   
  이는 장점이 될 수도 있지만, 해당 클래스를 수행할 때 별도의 스레드 객체를 생성해야 한다는 점은 단점이 될 수도 있다.   
  또한 자바는 다중 상속을 인정하지 않기 때문에, 스레드를 사용할 때 이미 상속받은 클래스가 존재한다면 Runnable 인터페이스를 구현해야 한다.   
* `sleep()`, `wait()`, `join()` 메서드   
  현재 진행 중인 스레드를 대기하는 메서드
  모두 예외를 던지도록 되어있어 사용할 때 반드시 예외처리 필요
  * `sleep()`
    * 명시된 시간만큼 해당 스레드를 대기
  * `wait()`
    * 명시된 시간만큼 해당 스레드를 대기
    * `sleep()` 메서드와 다른 점은 매개변수, 아무런 매개변수를 지정하지 않으면 `notify()` 메서드 또는 `notifyAll()`메서드가 호출될 때까지 대기
  * `join()`
    * 명시된 시간만큼 해당 스레드가 죽기를 기다림
* `interrupt()`, `notify()`, `notifyAll()` 메서드
 * `interrupt()`: 위 3개의 메서드를 '모두' 멈출 수 있는 유일한 메서드
 * `notify()`: `wait()` 메서드를 멈추기 위한 메서드. 객체의 모니터와 관련있는 **단일 스레드**를 깨운다.
 * `notifyAll()`: `wait()` 메서드를 멈추기 위한 메서드. 객체의 모니터와 관련있는 **모든 스레드**를 깨운다.   
</br>

**✏️`interrupt()` 메서드는 절대적인 것이 아니다**   
`interrupt()` 메서드는 해당 스레드가 'block'되거나 특정 상태에서만 작동한다   
(= 특정 메서드를 중지시키려고 할 때 항상 메서드가 멈추지 않는다.)   
</br>

**✏️synchronized를 이해하자**   
* synchronized는 하나의 객체에 여러 객체가 동시에 접근하여 처리하는 상황이 발생할 때 사용한다.
* synchronized는 메서드나 블록으로 사용할 수 있다
* 절대로 생성자의 식별자로는 사용할 수 없다
* 💡 그럼 언제 동기화를 사용해야 할까?
  * 하나의 객체를 여러 스레드에서 동시에 사용할 경우
  * static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우
</br>
