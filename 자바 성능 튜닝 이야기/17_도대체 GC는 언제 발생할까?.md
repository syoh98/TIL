* GC가 어떻게 수행되는지 잘 모르고 개발하는 개발자들이 많다.   
* 유닉스/리눅스/윈도우 등에서 `Full GC`를 수행하는 시점에는 해당 JVM에서 처리되지 않는다는 단점이 있다.   
* 그러므로 자신이 만든 자바 프로그램의 성능을 생각하는 자바 엔지니어라면, GC가 어떻게 처리되는지 기본 지식은 갖고 있는 것이 좋다.   
</br>

### ✏️GC란?
Garbage Collection은 말 그대로 쓰레기를 정리하는 작업이다.   
여기서 쓰레기란 객체이다.   
하나의 객체는 메모리를 점유하고, 필요하지 않으면 메모리에서 해제되어야 한다.   
ex) 
```java
public String makeQuery(String code) {
   String queryPre = "SELECT * FROM table_a WHERE a='";
   String queryPost="' ORDER BY c";
   return queryPre + code + queryPost;
}
```
➡️ 해당 코드에서 makeQuery() 메서드를 호출한 후 수행이 완료되면 queryPre 객체와 queryPost 객체는 **더 이상 필요 없는 객체**, 즉 쓰레기가 되는 것이다.   
➕) 자바에서는 메모리를 GC라는 알고리즘을 통하여 관리하기 때문에, 개발자가 메모리를 처리하기 위한 로직을 만들 필요가 없고, 절대로 만들어서는 안된다.   
</br>

### ✏️자바의 Runtime data area는 이렇게 구성된다
자바에서 데이터를 처리하기 위한 영역에는 어떤 것들이 있을까>
* PC 레지스터
* JVM 스택
* 힙(Heap)
* 메서드 영역
* 런타임 상수(constant) 풀
* 네이티브 메서드 스택   
**➡️ 이 영역 중에서 GC가 발생하는 부분이 힙영역이다(= 나머지 영역은 GC 대상이 아니다)**

* Heap 메모리
  * 클래스 인스턴스, 배열이 이 메모르에 쌓인다
  * 이 메모리는 '공유 메모리'라고도 불리우며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다
* Non-heap 메모리
  * 메서드 영역: 메서드 영역은 모든 JVM 스레드에서 공유한다
  * **[이 영역에 저장되는 데이터들]**
    * JVM 스택
      * 스레드가 시작할 때 JVM 스택이 생성된다
      * 이 스택에는 메서드가 호출되는 정보인 프레임이 저장된다
      * 지역변수와 임시 결과, 메서드 수행과 리턴에 관련된 정보들도 포함된다.
    * 네이티브 메서드 스택
      * 자바 코드가 아닌 다른 언어로 된(보통은 C로 된)코드들이 실행하게 될 때의 스택 정보를 관리한다.
    * PC 레지스터
      * 자바의 스레드들은 각자의 pc 레지스터를 갖는다.
      * 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인트럭션 주소를 pc 레지스터에 보관한다.
</br>

### ✏️GC의 원리
GC 작업을 하는 가비지 콜렉터의 역할   
* 메모리 할당
* 사용 중인 메모리 인식
* 사용하지 않는 메모리 인식   
➡️ 사용하지 않는 메모리를 인식하는 작업을 수행하지 않으면, 할당한 메모리 영역이 꽉차서 JVM에 행이 걸리거나, 더 많은 메모리를 할당하려는 현상이 발생할 것이다.   
➡️ 만약 JVM의 최대 메모리 크기를 지정해서 전부 사용한 다음, GC를 해도 더 이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 `OutOfMemory`가 발생하여 JVM이 다운될 수도 있다.
