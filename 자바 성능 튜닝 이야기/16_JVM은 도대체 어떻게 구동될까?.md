## ✏️ HotSpot VM은 어떻게 구성되어 있을까?
* **🤔 왜 이름을 이렇게 지었을까?**
  * 자바를 만든 Sun에서는 자바의 성능을 개선하기 위해서 Just In Time(JIT) 컴파일러를 만들었고, 이름을 HotSpot으로 지었다.
  * JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다.
  * 분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.
* **HotSpot VM의 세 가지 주요 컴포넌트**
  * VM(Virtual Machine) 런타임
  * JIT(Just In Time) 컴파일러
  * 메모리 관리자
* 💡 **JIT을 사용한다는 것은**
  * 언제나 자바 메서드가 호출되면 바이트 코드를 컴파일하고 실행 가능한 네이티브 코드로 변환한다는 의미이다
  * 하지만, 매번 JIT로 컴파일 하면 성능 저하가 심하므로, 최적화 단계를 거치게 된다.
</br>

## ✏️ JIT Compiler라는 게 도대체 뭘까?
* HotSpot VM JIT 컴파일러는 `Client버전`과 `Server버전`으로 나뉜다.
* C와 Java의 컴파일
  * C의 경우 먼저 소스코드에서 object 파일을 만들고, 이 object로 수행 가능한 라이브러리로 만든다. 이 작업은 애플리케이션이 수행되는 것과 비교해서 지속, 반복적으로 수행되지 않고 한 번만 수행된다.
  * Java의 경우 `javac`라는 컴파일러를 사용한다. 이 컴파일러는 소스코드를 바이트 코드로 된 class 파일로 변환해주기 때문에 JVM은 항상 바이트 코드로 시작하며, 동적으로 기계에 의존적인 코드로 변환한다.
* JIT은 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않기 때문에 모든 코드는 초기에 인터프리터에 의해서 시작되고, **해당 코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다.**
  * HotSpot VM에서 **이 작업은 각 메서드에 있는 카운터를 통해 통제**되며, 메서드에는 두 개의 카운터가 존재한다.
    * **수행 카운터(invocation counter)**: 메서드를 시작할 때마다 증가
    * **백에지 카운터(backedge counter)**: 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가(수행 카운터보다 컴파일 우선순위가 높다)
  * 💡 **이 카운터들이 인터프리터에 의해서 증가될 때마다, 그 값들이 한계치에 도달했는지 확인하고 도달했을 경우 인터프리터는 컴파일을 요청한다.**
    * 여기서 수행 카운터에서 사용하는 한계치는 `ComplieThreshold`, 백에지 카운터에서 사용하는 한계치는 `CompileThreshold * OnStackReplacePercentage / 100`로 계산한다.
  * 컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓이고, **하나 이상의 컴파일러 스레드가 이 큐를 모니터링**한다.
    * 만약 컴파일러 스레드가 바쁘지 않을 때는 큐에서 대상을 빼내서 컴파일을 시작한다.
    * 보통 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속 한다.
  * HotSpot VM은 `OSR(On Stack Replacement)`이라는 컴파일도 수행한다.
    * OSR은 인터프리터에서 수행한 코드 중 오랫동안 루프가 지속되는 경우에 사용된다.
    * 만약 해당 코드의 컴파일이 완료된 상태에서 최적화되지 않은 코드가 수행되고 있는 것을 발견한 경우에 인터프리터에서 시작된 오랫동안 지속되는 루프가 다시는 불리지 않을 경우엔 도움이 되지 않지만, 루프가 끝나지 않고 지속적으로 수행되고 있을 경우에는 큰 도움이 된다.
### 💡Java 5 HotSpot VM이 발표되면서 새로운 기능이 추가되었다.
* JVM이 시작될 때 플랫폼과 시스템 설정을 평가하여 **자동으로 garbage collector를 선정**하고, **자바 힙 크기와 JIT 컴파일러를 선택하는 것**이다.
  * 이 기능을 통해서 애플리케이션의 활동과 객체 할당 비율에 따라서 **garbage collector가 동적으로 자바 힙 크기를 조절**하며, **New의 Eden과 Survivor, Old 영역의 비율을 자동적으로 조절하는 것**을 의미한다.
</br>

## ✏️ IBM JVM의 JIT 컴파일 및 최적화 절차
JIT컴파일 방식
* 인라이닝(Inlining)
  * 메서드가 단순할 때 적용되는 방식, 호출된 메서드가 단순할 겨웅 그 내용이 호출한 메서드의 코드에 포함해버린다.
* 지역 최적화(Local optimizations)
  * 작은 단위의 코드를 분석하고 개선하는 작업을 수행한다.
* 조건 구문 최적화(Control flow optimizations)
  * 메서드 내의 조건 구문을 최적화하고, 효율성을 위해서 코드의 수행 경로를 변경한다.
* 글로벌 최적화(Global optimizations)
  * 메서드 전체를 최적화하는 방식. 매우 비싼 방식이며, 컴파일 시간이 많이 소요된다는 단점이 있지만, 성능 개선이 많이 될 수 있다는 장점이 있다.
* 네이티브 코드 최적화(Native code generation)
  * 플랫폼 아키텍처 의존적. 다시 말해서 아키텍처에 따라서 최적화를 다르게 처리한다.
</br>

## ✏️ JVM이 시작할 때의 절차는 이렇다
java 명령으로 HelloWorld라는 클래스를 실행했을 경우   
1. java 명령어 줄에 있는 옵션 파싱:
   일부 명령은 자바 실행 프로그램에서 적절한 JIT 컴파일러를 선택하는 등의 작업을 하기 위해서 사용하고, 다른 명령들은 HotSpot VM에 전달된다.
2. 자바 힙 크기 할당 및 JIT 컴파일러 타입 지정:(이 옵션들이 명령줄에 지정되지 않았을 경우)
   메모리 크기나 JIT 컴파일러 종류가 명시적으로 지정되지 않은 경우에 자바 실행 프로그램이 시스템의 상황에 맞게 선정한다.
3. CLASSPATH와 LD_LIBRARY_PATH 같은 환경 변수를 지정한다.
4. 자바의 Main 클래스가 지정되지 않았으면, Jar 파일의 manifest 파일에서 Main 클래스를 확인한다.
5. JNI 표준 API인 JNI_CreateJavaVM을 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성한다.
6. HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main() 메서드의 속성 정보를 읽는다.
7. CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행된다. 이 때 자바 실행 시 Main 클래스 뒤에 있는 값들이 전달된다.
</br>

## ✏️ JVM이 종료될 때의 절차는 이렇다
1. HotSpot VM이 작동중인 상황에서는 단 하나의 데몬이 아닌 스레드가 수행될 때까지 대기한다.
2. java.lang 패키지에 있는 Shutdown 클래스의 shutdown() 메서드가 수행된다. 이 메서드가 수행되면 자바 레벨의 shutdown hook이 수행되고, finalization-on-exit이라는 값이 true일 경우에 자바 객체 finalizer를 수행한다.
3. HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비한다. 이 작업은 JVM_OnExit()메서드를 통해서 지정된다. 그리고, HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시킨다.
4. HotSpot의 JavaThread::exit() 메서드를 호출하여 JNI 처리 블록을 해제한다. 그리고, guard pages, 스레드 목록에 있는 스레드들을 삭제한다. 이 순간 부터는 HotSpot VM에서는 자바 코드를 실행하지 못한다.
5. HotSpot VM 스레드를 종료한다. 이 작업을 수행하면 HotSpot VM에 남아있는 HotSpot VM 스레드들을 safepoint로 옮기고, JIT 컴파일러 스레드들을 중지시킨다.
6. JNI, HotSpot VM, JVMTI barrier에 있는 추적 기능을 종료시킨다.
7. 네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot의 "vm exited" 값을 설정한다.
8. 현재 스레드를 삭제한다
9. 입출력 스트림을 삭제하고, PerfMemory 리소스 연결을 해제한다
10. JVM 종료를 호출한 호출자로 복귀한다.
