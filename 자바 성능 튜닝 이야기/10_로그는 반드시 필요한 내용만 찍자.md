## ✏️ System.out.println()의 문제점
* `System.out.println()`를 제거한 경우 성능이 개선되었다.   
* 어떤 내용을 얼마나 많이 프린트하느냐에 따라서 응답 시간은 달라지겠지만, 시스템 로그를 프린트하면 반드시 성능에 영향을 주게된다.   
* ➡️ 왜그럴까?
  * 내용이 완전히 프린트 되거나 저장될 때까지, 뒤에 프린트하려는 부분은 대기할 수 밖에 없다
  * 그렇게되면 애플리케이션에서는 대기 시간이 발생한다
  * 이 대기시간은 시스템의 속도에 의존적이다
* **❗더 큰 문제는 System.out.println()으로 출력하는 로그가 개발할 때만 사용된다는 것이다(= 운영할 떄는 전혀 사용되지 않는다)**]
* 즉, 의미없는 디버스용 로그를 프린트하기 위해서 아까운 서버의 리소스와 디스크가 낭비된다는 것이다.
</br>

## ✏️ System.out.format() 메서드
* C에서 프린트하던 방식으로 처리할 수 있어 소스가 간결해진다.
* 두가지 방식으로 사용가능하다
  * `format(String format, Object... args)`: 지정된 포맷으로 프린트 한다
  * `format(Local I, String format, Object... args)`: 위 메서드와 동일하지만, 가장 앞에 지역 정보를 포함한다
* **🤔 String을 더해서 처리하는 것ㄷ과 Formatter를 사용하는 것 중 어느방식이 더 빠를까?**
  * `System.out.println()`보다 `format()`의 방식이 더 오랜시간 소요된다
</br>

## ✏️ 로그를 더 간결하게 처리하는 방법
그럼 디버그용 로그가 꼭 필요할 때는 어떻게 해야할까?   
➡️ Logger를 사용하여 로그를 처리하는 것이다   
🤔 또 Logger를 사용하기 힘든 상황이라면??
1. 자체 로거 클래스를 만드는 방법 ➡️ 이미 만들어져 있는 로거를 사용하는 것이 효율적이다. 추천하지 않는다.
2. 시스템 로그를 컴파일 할 때 삭제되도록 하는 방법
  * 구현방법
    ```java
    public class LogRemoveSample {
      private final boolean printFlag=false;
      public LogRemoveSample() {}
      public ArrayList getList() {
        ArrayList retList=new ArrayList(10);
        // 중간 생략
        if(printFlag) {
          System.out.format("LogRemoveSample.getList(): size=%d\n", retList.size());
        }
        return retList;
      }
    }
    ```
* 💡 여기서 중요한 것은 `final`로 printFlag를 선언했기 때문에, **절대로 이 값은 실행 시 변경될 수 없는 점**이다.   
* 🤔 이 소스를 보고 '뭐 이렇게 까지 귀찮게 하나? 그냥 로그는 주석 처리하면 되지...'라고 생각할 수 있다
* **➡️ 두 줄 이상에 걸쳐서 시스템 로그를 프린트하는 부분을 그냥 일괄 변경해서 주석처리하면, 100% 컴파일 오류가 발생한다**
</br>

## ✏️ 로거 사용 시의 문제점
* 컴파일 시에 로그를 제거하는 방법을 사용하지 않는 한 로그를 프린트하든 하지 않든, 로그를 삭제하기 위한 한줄을 처리하기 위해서는 어차피 객체를 생성해야 한다.   
* 또한 메모리에서 제거하기 위해서는 GC를 수행해야 하고, GC 수행 시간이 또 소요된다   
    ```java
    logger.info("query="+query);
    logger.info("result="+resultHashMap);
    ```
    * 호출되는 메서드에 문자열이 전달되어야 하기 때문에 괄호 안에 있는 값들을 문자열로 변환하는 작업이 반드시 수행된 다음, 메서드 호출이 진행된다
    * 쿼리가 한두줄이라면 상관 없지만 일반적으로 최소 한페이지다 **(그만큼의 객체가 생성되었다가 아무 일도 안하고 사라진다면,,,)**
    * ➡️ 그러므로 가장 좋은 방법은 디버그용 로그를 제거하는 것이다. 하지만 그렇지 못한 것이 현실이다.
    * ➡️ 로그를 처리하는데 발생하는 문제점을 해결하는데 도움을 주는 `slf4j`에 대해 알아보자
</br>

## ✏️ 로그를 깔씀하게 처리해주는 slf4j와 LogBack
* slf4j(Simple Logging Facade for Java): 간단히 로그를 처리해주는 프레임워크
* 🤔 log4j와 어떤점이 다를까?
  * 기존의 로거들은 출력을 위해서 문자열을 더해 전달해줘야만 했다.
  * slf4j는 format 문자열에 중괄호를 넣고, 그 순서대로 출력하고자 하는 데이터들을 콤마로 구분하려 전달해준다
  * **💡 이렇게 전달해주면 로그를 출력하지 않을 경우 필요없는 문자열 더하기 연산이 발생하지 않는다**
  * 게다가 자바의 기본 로거를 비롯하여 Log4j, 아파치 commons 로깅 등과 연계하여 사용할 수 있도록 되어있다.
  * LogBack은 예외의 스택 정보를 출력할 때 해당 클래스가 어떤 라이브러리(jar파일)를 참고하고 있는지도 포함하여 제공하기 때문에 쉽게 관련된 클래스를 확인할 수 있다.
</br>

## ✏️ 예외처리는 이렇게
일반적인 예외처리 방법
```java
  try {
    // ...
  } catch(Exception e) {
    e.printStackTrace();
  }
```
➡️ `e.printStackTrace()`를 호출하게 되면 스택 정보를 확인하고, 확인된 정보를 콘솔에 프린트한다.   
➡️ 여러 스레드에서 콘솔에 로그를 프린트하면 데이터가 섞이기 때문에 콘솔에 찍힌 로그를 알아보기 힘들다.   
➡️ 성능에도 많은 부하를 준다.   

## ✏️ 정리
* 로그를 효율적으로 관리하면 성능에도 영향을 주지 않고, 운영 시 문제가 발생해도 원하는 내용만 확인할 수 있다.
* 코딩은 습관이다. 나쁜 습관은 고쳐야 발전이 있다. 더 깔끔한 소스와 로그를 원한다면, 필요없는 로그들은 소스에서 지우자.   
* 그리고 반드시 Log4j나 slf4j, LogBack과 같은 로거를 사용하자.   
* 예외 처리 시에는 반드시 필요한 내용만 처리하자.
