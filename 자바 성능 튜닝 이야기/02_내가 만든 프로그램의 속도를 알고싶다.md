시스템의 성능이 느릴 때 가장 먼저 해야하는 작업은 **병목지점을 파악하는 것**이다   
➡️ 따라서 애플리케이션이 수행되는 속도를 측정하는 방법을 알아보자   
</br>

**✏️프로파일링 툴이란?**   
* 시스템 문제 분석 툴
* 많이 사용하는 툴로는 APM이 있다.
* 💡 APM 툴과 프로파일링 툴의 차이점?
  * APM 툴
    * 애플리케이션의 장애 상황에 대한 모니터링 및 문제점 진단이 주 목적이다
    * 서버의 사용자 수나 리소스에 대한 모니터링을 할 수 있다
    * 실시간 모니터링을 위한 툴이다
  * 프로파일링 툴
    * 소스레벨의 분석을 위한 툴
    * 애플리케이션의 세부 응답 시간까지 분석할 수 있다
    * 가격이 APM 툴에 비해 저렴하다
    * 메모리 사용량을 객체나 클래스, 소스의 라인 단위까지 분석할 수 있다
  * 💡 프로파일링 툴이 기본적으로 제공하는 기능은 어떤 것이 있을까?
    * 응답 시간 프로파일링 기능
      * 응답시간을 측정하기 위해 사용
      * 응답시간 프로파일링을 할 때는 보통 **CPU시간**과 **대기시간**이 제공
        * 실제 소요 시간: CPU시간 + 대기시간
    * 메모리 프로파일링
      * 잠깐 사용하고 GC의 대상이 되는 부분을 찾거나, 메모리 부족현상이 발생하는 부분을 찾기 위함
      * 클래스 및 메서드 단위의 메모리 사용량이 분석된다.
* **💡 그럼 더 간단하게 프로그램의 속도를 측정할 수 있는 방법이 없을까?**
  ➡️ 그게 System 클래스이다.   
  
**✏️`System.currentTimeMillis`와 `System.nanoTime`**
* `System.currentTimeMillis`: 현재의 시간을 ms로 리턴한다.
* `System.nanoTime`: 현재의 시간을 ns로 리턴한다.
  * JDK 5.0부터 추가된 메서드
  * 만든 목적? 수행된 시간 측정. 때문에 오늘의 날짜를 알아내는 부분에서는 사용불가
* 💡 둘의 수행 시간은 어떤 때는 nanoTime()이 오래걸리고, 어떤 때는 currentTimeMillis()가 오래걸린다.
* **💡 그럼 메서드로 측정하는 방법말고, 전문측정 라이브러리를 사용하는 방법도 있을까?**
  * JMH: JDK를 오픈 소스로 제공하는 OpenJDK에서 만든 성능 측정용 라이브러리
    * 여러 개의 스레드로 테스트도 가능하고, 워밍업 작업도 자동으로 수행해주기 때문에 정확한 측정이 가능하다
    * JMH를 사용하면 일일이 케이스를 구성할 필요 없이 각 케이스별로 테스트를 수행하고 그 결과를 확인 할 수 있다.
  * Caliper
  * JUnitPerf
  * JunitBench
  * ContiPerf
  
