https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html   
   
## 🔘 Transaction Propagation
### PROPAGATION_REQUIRED
![image](https://github.com/user-attachments/assets/0713d92e-0ea7-490e-9d33-52db650bc1ed)   
* `PROPAGATION_REQUIRED`는 트랜잭션이 아직 존재하지 않는 경우 현재 범위에 대해 로컬 또는 더 큰 범위에 대해 정의된 기존 외부 트랜잭션에 참여하여 물리 트랜잭션을 적용한다.   
  이는 동일한 스레드 내의 일반적인 호출 스택 배열에서 좋은 기본 값이다. (ex. 모든 기본 리소스가 service-level 트랜잭션에 참여해야 하는 여러 저장소 메서드에 위임하는 서비스 facade)
* 전파 설정이 `PROPAGATION_REQUIRED`면 설정이 적용되는 각 메서드에 대해 논리 트랜잭션 범위가 생성된다. 이러한 각 논리적 트랜잭션 범위는 롤백 전용 상태를 개별적으로 결정할 수 있으며 외부 트랜잭션 범위는 내부 트랜잭션 범위와 논리적으로 독립적이다.   
  표준 `PROPAGATION_REQUIRED` 동작의 경우 이러한 모든 범위는 **동일한 물리 트랜잭션에 매핑**된다. 따라서 내부 트랜잭션 범위에 설정된 롤백 전용 마커는 외부 트랜잭션에 실제로 커밋 가능성에 영향을 미친다.
* 그러나 내부 트랜잭션 범위가 롤백 전용 마커를 설정하는 경우 외부 트랜잭션은 롤백 자체를 결정하지 않았으므로 롤백(내부 트랜잭션 범위에 의해 자동으로 트리거됨)은 예상치 못한 것이다. 해당 시점에서 `UnexpectedRollbackException`이 발생한다. 이는 트랜잭션 호출자가 커밋이 실제로 수행되지 않았는데 수행되었다고 오해할 수 없도록 하기 위한 예상되는 동작이다.   
  따라서 내부 트랜잭션(외부 호출자가 인식하지 못하는)이 자동으로 트랜잭션을 롤백전용으로 표시하는 경우 외부 호출자는 여전히 커밋을 호출한다. 외부 호출자는 롤백이 대신 수행되었음을 명확하게 나타내기 위해 `UnexpectedRollbackException`을 수신해야한다.
* **🗒️ NOTE**
  * 기본적으로 참여 트랜잭션은 로컬 격리 수준, 시간 초과 값 또는 읽기 전용 플래스(있는 경우)를 자동으로 무시하고 외부 범위의 특성에 조인한다.   
    다른 격리 수준으로 기존 트랜잭션에 참여할 때 격리 수준 선언을 거부하려면 트랜잭션 관리자에서 verifyExistingTransactions 플래그를 true로 전환하는 것을 고려해야한다. 이 non-lenient 모드는 읽기 전용 불일치(즉, 읽기 전용 외부 범위에 참여하려고 시도하는 내부 읽기-쓰기 트랜잭션)도 거부한다.
</br>

### 🔘 PROPAGATION_REQUIRES_NEW
![image](https://github.com/user-attachments/assets/074d3eb9-52fb-42d3-ab80-03eb16575b9b)
* `PROPAGATION_REQURES_NEW`는 `PROPAGATION_REQUIRED`와 달리 항상 영향을 받는 각 트랜잭션 범위에 대해 **독립적인 물리 트랜잭션을 사용하며 외부 범위에 대한 기존 트랜잭션에 절대 참여하지 않는다.**   
  이러한 arrangement에서는 기본 리소스 트랜잭션이 다르므로 독립적으로 커밋하거나 롤백 할 수 있으며 **외부 트랜잭션은 내부 트랜잭션의 롤백 상태에 영향을 받지 않고 내부 트랜잭션의 잠금은 즉시 해제**된다.   
  이러한 독립적인 내부 트랜잭션은 자체 격리 수준, 시간 초과 및 읽기 전용 설정을 선언할 수도 있으며 외부 트랜잭션의 특성을 상속하지 않을 수도 있다.
* **🗒️ NOTE**
  * 외부 트랜잭션에 연결된 리소스는 내부 트랜잭션이 새로운 데이터베이스 연결과 같은 자체 리소스를 획득하는 동안 바인딩된 상태로 유지된다. 여러 스레드에 활성 외부 트랜잭션이 있고 내부 트랜잭션에 대한 새 연결을 얻기 위해 대기하는 경우 커넥션 풀이 고갈되고 잠재적인 데드락 가능성이 생기며, 커넥션 풀은 더 이상 내부 연결을 전달할 수 없다.   
  * 커넥션 풀의 크기가 적절하여 동시 스레드 수를 1 이상 초과하지 않는 한 `PROPAGATION_REQUIRES_NEW`를 사용하면 안된다.
