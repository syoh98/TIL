## 🦅 5.1 트랜잭션
`잠금`은 동시성을 제어하기 위한 기능이고, `트랜잭션`은 데이터의 정합성을 보장하기 위한 기능이다.
* **MySQL에서의 트랜잭션**
  * 트랜잭션은 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT) 아무것도 적용되지 않아야(ROLLBACK)함을 보장해 주는 것이다.
  * MyISAM의 경우 트랜잭션이 지원되지 않아 부분 업데이트 현상으로 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.
  * InnoDB의 경우 트랜잭션이 지원되어 쓰레기 데이터가 테이블에 남아 있지 않는다.
* **주의사항**
  * 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다. 범위를 크게 잡는다면 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생한다.
## 🦅 5.2 MySQL 엔진의 잠금
* **글로벌 락**
  * MySQL에서 제공하는 잠금 중 가장 범위가 크고, `FLUSH TABLES WITH READ LOCK` 명령으로 획득이 가능하다.
  * 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베리스가 다르더라도 동일하게 영향을 미친다.
  * InnoDB 스토리지 엔진이 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없어 가벼운 글로벌 락(`백업 락`)의 필요성이 생겼다.
* **테이블 락**
  * 개별 테이블 단위로 설정되는 잠금이며, `명시적` 또는 `묵시적`으로 특정 테이블의 락을 획득할 수 있다.
    * `명시적`: LOCK TALBLES table_name [READ | WRITE]로 락 획득, UNLOCK TABLES로 락 반납
    * `묵시적`: 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.(자동실행, 자동반납)
* **네임드 락**
  * 네임드 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.
  * `GET_LOCK()` 함수를 아용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
  * 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
* **메타데이터 락**
  * 데이터베이스 객체(테이블 또는 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
  * 명시적으로 획득하거나 해제할 수 있는 것이 아니고 `RENAME TABLE tab_a TO tab_b` 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

## 🦅 5.3 InnoDB 스토리지 엔진 잠금
* **InnoDB 스토리지 엔진의 잠금**
* **인덱스와 잠금**
* **레코드 수준의 잠금 확인 및 해제**

## 🦅 5.4 MySQL의 격리 수준
* **READ UNCOMMITTED**
* **READ COMMITTED**
* **REPEATABLE READ**
* **SERIALIZABLE**
