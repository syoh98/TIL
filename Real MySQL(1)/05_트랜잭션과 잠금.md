## 🦅 5.1 트랜잭션
`잠금`은 동시성을 제어하기 위한 기능이고, `트랜잭션`은 데이터의 정합성을 보장하기 위한 기능이다.
* **MySQL에서의 트랜잭션**
  * 트랜잭션은 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT) 아무것도 적용되지 않아야(ROLLBACK)함을 보장해 주는 것이다.
  * MyISAM의 경우 트랜잭션이 지원되지 않아 부분 업데이트 현상으로 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.
  * InnoDB의 경우 트랜잭션이 지원되어 쓰레기 데이터가 테이블에 남아 있지 않는다.
* **주의사항**
  * 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다. 범위를 크게 잡는다면 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생한다.
## 🦅 5.2 MySQL 엔진의 잠금
* **글로벌 락**
  * MySQL에서 제공하는 잠금 중 가장 범위가 크고, `FLUSH TABLES WITH READ LOCK` 명령으로 획득이 가능하다.
  * 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베리스가 다르더라도 동일하게 영향을 미친다.
  * InnoDB 스토리지 엔진이 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없어 가벼운 글로벌 락(`백업 락`)의 필요성이 생겼다.
* **테이블 락**
  * 개별 테이블 단위로 설정되는 잠금이며, `명시적` 또는 `묵시적`으로 특정 테이블의 락을 획득할 수 있다.
    * `명시적`: LOCK TALBLES table_name [READ | WRITE]로 락 획득, UNLOCK TABLES로 락 반납
    * `묵시적`: 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.(자동실행, 자동반납)
* **네임드 락**
  * 네임드 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.
  * `GET_LOCK()` 함수를 아용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
  * 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
* **메타데이터 락**
  * 데이터베이스 객체(테이블 또는 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
  * 명시적으로 획득하거나 해제할 수 있는 것이 아니고 `RENAME TABLE tab_a TO tab_b` 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

## 🦅 5.3 InnoDB 스토리지 엔진 잠금
InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
* **InnoDB 스토리지 엔진의 잠금**
  * 레코드 락
    * 레코드 자체만을 잠그는 것, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.
    * **중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.** 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
  * 갭 락
    * 레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
    * 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다.
  * 넥스트 키 락
    * 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.
  * 자동 증가 락
    * MySQL에서는 자동 증가하는 숫자 값을 추출(채번)하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공한다.
    * AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다. 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.
* **인덱스와 잠금**
  * InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리되기 때문에 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드 모두 락을 걸어야한다.
* **레코드 수준의 잠금 확인 및 해제**
  * 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있지만 레코드 수준의 잠금은 테이블 레코드 각각의 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.

## 🦅 5.4 MySQL의 격리 수준
`트랜잭션 격리 수준`이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.    
SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.
![image](https://github.com/user-attachments/assets/ef672b10-d1c6-490d-91d7-3e022772f3a5)
* **READ UNCOMMITTED**
  * 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보이는 격리수준
* **READ COMMITTED**
  * 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있는 격리수준
  * 오라클 DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준
* **REPEATABLE READ**
  * MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서 동일한 결과를 보여줄 수 있게 보장한다.
  * MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
* **SERIALIZABLE**
  * 읽기 작업도 읽기 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.(= 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.)
