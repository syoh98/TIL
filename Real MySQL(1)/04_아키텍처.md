## 🦅 4.1 MYSQL 엔진 아키텍처
* **MySQL 엔진**
  * 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.
  * MySQL 서버에서 MySQL 엔진은 하나다.
* **스토리지 엔진**
  * 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담한다.
  * MySQL 서버에서 스토리지 엔진은 동시에 여러 개를 사용할 수 있다.
  * 각 스토리지 엔진은 성능 향상을 위해 `키 캐시`(MyISAM 스토리지 엔진)나 `INNODB 버퍼 풀`(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.
* **핸들러 API**
  * MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라 하고, 이 때 사용되는 API를 핸들러 API라고 한다.
* **MySQL 스레딩 구조**   
  MySQL 서버는 프로세스 기반이 아닌 `스레드 기반`으로 작동한다.
  * 포그라운드 스레드(클라이언트 스레드, 사용자 스레드)
    * 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
    * 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
  * 백그라운드 스레드
    * `InnoDB` 백그라운드에서 처리하는 작업
      * 인서트 버퍼를 병합하는 스레드
      * **로그를 디스크로 기록하는 스레드**
      * **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
      * 데이터를 버퍼로 읽어오는 스레드
      * 잠금이나 데드락을 모니터링하는 스레드
* **메모리 할당 및 사용 구조**   
  글로벌 메모리 영역과 로컬 메모리 영역은 `MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부`에 따라 구분된다.   
  <img src="https://github.com/user-attachments/assets/c37c9e94-52da-494b-b931-5c90f0860e02" width="500"/>
  * 글로벌 메모리 영역
    * 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.(필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만, 클라이언트의 스레드 수와는 무관하며 글로벌 영역은 모든 스레드에 의해 공유된다.)
  * 로컬 메모리 영역(세션 메모리 영역, 클라이언트 메모리 영역)
    * MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
    * 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 **절대 공유되어 사용되지 않는다.**
* **플러그인 스토리지 엔진 모델**
  * MySQL 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원한다.
  * 인증이나 전문 검색 파서 또는 쿼리 재작성과 같은 플러그인이 있으며, 비밀번호 검증과 커넥션 제어 등에 관련된 다양한 플러그인이 제공된다. 뿐만 아니라 MySQL 서버의 기능을 커스텀하게 확장할 수 있게 플러그인 API가 매뉴얼에 공개되어 있으므로 기존 MySQL 서버에서 제공하던 기능들을 확장하거나 완전히 새로운 기능들을 플러그인을 이용해 구현할 수도 있다.
* **컴포넌트**
  * MySQL 8.0부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.
  * MySQL 서버 플러그인의 단점
    1. 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
    2. 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하기 않음(캡슐화 안 됨)
    3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
* **쿼리 실행 구조**
  * 쿼리파서
  * 전처리기
  * 옵티마이저
  * 실행 엔진
  * 핸들러(스토리지 엔진)
* **복제** -> 별도의 장에서 다룸
* **쿼리 캐시**
  * 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능을 보였다.
  * 하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제해야 했다. 이는 심각한 동시 처리 성능 저하를 유발하고 버그의 많은 원인이되어 MySQL 8.0부터 쿼리 캐시 기능은 제거됐다.
* **스레드풀**
  * MySQL 서버엔터프라이즈 에디션은 스레드 풀을 제공하지만, MySQL 커뮤니티 에디션은 지원하지 않는다. 이 경우 플러그인 형태로 작동하는 Percona Server를 설치하여 사용 가능하다.
  * **스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적**이다.
  * Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성하는데, 스레드 그룹의 개수는 thread_pool_size 시스템 변수를 변경해서 조정할 수 있다.
  * Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다. **먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰서 전체적인 처리 성능을 향상시킬 수 있다.**
* **트랜잭션 지원 메타데이터**
  * MySQL 5.7버전까지 테이블의 구조를 FRM 파일에 저장하고 일부 스토어트 프로그램 또한 파일(*.TRN, *.TRG, *.PAR, ...)기반으로 관리했다.
  * **파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 발생했다.** ➡️ 이를 `데이터베이스나 테이블이 깨졌다`라고 표현한다.
  * 따라서 MySQL 8.0 버전부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선됐다.
  * InnoDB는 트랜잭션 기반의 스토리지 엔진으로, 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전한 성공 또는 완전한 실패로 정리된다.
</br>

## 🦅 4.2 InnoDB 스토리지 엔진 아키텍처   
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하여 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.
* **프라이머리 키에 의한 클러스터링**
  * InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.(=프라이머리 키 값의 순서대로 디스크에 저장된다.)
  * 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
  * MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.
* **외래 키 지원**
  * 외래키 지원은 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
* **MVCC(Multi Version Concurrency Control)**
  * MVCC는 하나의 레코드에 대해 여러 개의 버전을 동시에 관리하는 기술로, 가장 큰 목적은 `잠금을 사용하지 않는 일관된 읽기를 제공`하는 데 있다.
* **잠금 없는 일관된 읽기(Non-Locking Consistent Read)**
* **자동 데드락 감지**
* **자동화된 장애 복구**
* **InnoDB 버퍼 풀**  
버퍼 풀은 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.
  * 💠버퍼 풀의 크기 설정
    * MySQL 5.7 버전부터 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 되었다. 따라서 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적이다.
    * InnoDB 버퍼 풀을 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크다.
    * InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.
  * 💠버퍼 풀의 구조
    * InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
    * 버퍼 풀의 페이지 크기 조각을 관리하기 위해 3개의 자료 구조를 관리한다.
      * `LRU(Least Recently Used)`: LRU+MRU(Most Recently Used), 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화
      * `플러시 리스트`: 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
      * `프리 리스트`: InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
  * 💠버퍼 풀과 리두 로그
  * 💠버퍼 풀 플러시
    * 플러시 리스트 플러시
    * LRU 리스트 플러시
  * 💠버퍼 풀 상태 백업 및 복구
  * 💠버퍼 풀의 적재 내용 확인
* **Double Write Buffer**
* **언두 로그**
  * 언두 로드 레코드 모니터링
  * 언두 테이블스페이스 관리
* **체인지 버퍼**
* **리두 로그 및 로그 버퍼**
  * 리두 로그 아카이빙
  * 리두 로그 활성화 및 비활성화
* **어댑티브 해시 인덱스**
* **InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교**
</br>

## 🦅 4.3 MyISAM 스토리지 엔진 아키텍처

## 🦅 4.4 MYSQL 로그 파일
