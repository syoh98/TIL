## 🦅 9.1 개요
쿼리의 실행 계획을 수립하는 옵테마이저는 가장 복잡한 부분으로 알려져 있다. 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.
* **쿼리 실행 절차**   
  MySQL 서버에서 쿼리가 실행되는 과정은 세 단계이다.
  1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
  2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
  3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
* **옵티마이저의 종류**
  * 규칙 기반 최적화(Rule-based optimizer, RBO)
    * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수힙하는 방식
    * 오래전부터 많은 DBMS에서 거의 사용되지 않는다.
  * 비용 기반 최적화(Cost-based optimizer, CBO)
    * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
    * 현재 대부분의 RDMS가 비용기반의 옵티마이저를 채택하고 있다.
## 🦅 9.2 기본 데이터 처리
* **풀 테이블 스캔과 풀 인덱스 스캔**
  * ✏️`풀 테이블 스캔`: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
  * ✏️`리드 어헤드`: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
  * InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
* **병렬 처리**
  * MySQL 8.0 버전부터 쿼리의 병렬 처리가 가능해졌다. 여기서의 병렬 처리는 `하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것`을 의미한다.
* **ORDER BY 처리(Using filesort)**
  * 소트 버퍼
    * ✏️`소트 버퍼`: MySQL에서 정렬을 수행하기 위해 사용하는 별도의 메모리 공간, 이 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
  * 정렬 알고리즘
    * 싱글 패스 정렬 방식
    * 투 패스 정렬 방식
  * 정렬 처리 방법
    * 인덱스를 이용한 정렬
    * 조인의 드라이빙 테이블만 정렬
    * 임시 테이블을 이용한 정렬
    * 정렬 처리 방법의 성능 비교
      * 스트리밍 방식
      * 버퍼링 방식
  * 정렬 관련 상태 변수
* **GROUP BY 처리**
  * 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
  * 루스 인덱스 스캔을 이용하는 GROUP BY
  * 임시 테이블을 사용하는 GROUP BY
* **DISINCT 처리**
  * SELECT DISTINCT
  * 집합 함수와 함께 사용된 DISTINCT
* **내부 임시 테이블 활용**
  * 메모리 임시 테이블과 디스크 임시 테이블
  * 임시 테이블이 필요한 쿼리
  * 임시 테이블이 디스크에 생성되는 경우
  * 임시 테이블 관련 상태 변수

## 🦅 9.3 고급 최적화

## 🦅 9.4 쿼리 힌트
