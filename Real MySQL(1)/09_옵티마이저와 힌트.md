## 🦅 9.1 개요
쿼리의 실행 계획을 수립하는 옵테마이저는 가장 복잡한 부분으로 알려져 있다. 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.
* **쿼리 실행 절차**   
  MySQL 서버에서 쿼리가 실행되는 과정은 세 단계이다.
  1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
  2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
  3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
* **옵티마이저의 종류**
  * 규칙 기반 최적화(Rule-based optimizer, RBO)
    * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수힙하는 방식
    * 오래전부터 많은 DBMS에서 거의 사용되지 않는다.
  * 비용 기반 최적화(Cost-based optimizer, CBO)
    * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
    * 현재 대부분의 RDMS가 비용기반의 옵티마이저를 채택하고 있다.
## 🦅 9.2 기본 데이터 처리
* **풀 테이블 스캔과 풀 인덱스 스캔**
  * ✏️`풀 테이블 스캔`: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
  * ✏️`리드 어헤드`: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
  * InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
* **병렬 처리**
  * MySQL 8.0 버전부터 쿼리의 병렬 처리가 가능해졌다. 여기서의 병렬 처리는 `하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것`을 의미한다.
* **ORDER BY 처리(Using filesort)**
  * 소트 버퍼
    * ✏️`소트 버퍼`: MySQL에서 정렬을 수행하기 위해 사용하는 별도의 메모리 공간, 이 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
  * 정렬 알고리즘
    * 싱글 패스 정렬 방식
      * **소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.**
      *  투 패스 정렬 방식보다 더 많은 소트 버퍼 공간이 필요하다.
    * 투 패스 정렬 방식
      * **정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다.**
      * 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.
  * 정렬 처리 방법
    * 인덱스를 이용한 정렬
      * 해당 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
      * ✏️ **정렬이 되어있다고 ORDER BY 절 자체를 쿼리해서 제거하면 안된다.** MySQL 서버는 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬 작업을 수행하지 않기 때문이다.
      * B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
    * 조인의 드라이빙 테이블만 정렬
      * 해당 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절을 작성해야 한다.
    * 임시 테이블을 이용한 정렬
      * ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 컬럼인 경우 사용한다.
      * 정렬의 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.
    * 정렬 처리 방법의 성능 비교
      쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동할 수 밖에 없는지 확인해보자. 쿼리가 처리되는 방법은 `스트리밍 처리`와 `버퍼링 처리`라는 2가지 방식으로 구분할 수 있다.
      * 스트리밍 방식   
        <img src="https://github.com/user-attachments/assets/8c534d42-92ee-4cee-a258-37cc83f6f57c" width="400"/></br>
        * 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다.
      * 버퍼링 방식   
        <img src="https://github.com/user-attachments/assets/edbc83ba-9041-4add-9ab7-bcc98cfed652" width="400"/></br>
        * 스트리밍 방식의 반대 방식이다.
        * ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 한다. 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다. 이 경우 버퍼링 방식이 사용된다.
        * 인덱스를 사용한 정렬방식만 스트리밍 형태의 처리이고, 나머지는 모두 버퍼링된 후에 정렬된다.
  * 정렬 관련 상태 변수
    * MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다.
    * `Sort_merge_passes`: 멀티 머지 횟수, `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수, `Sort_scan`: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수, `Sort_scan`, `Sort_range`: 정렬 작업 횟수를 누적하고 있는 상태 값, `Sort_rows`: 지금까지 정렬한 전체 레코드 건수
* **GROUP BY 처리**   
  GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다.
  * 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
    * ORDER BY의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
    * 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 컬럼에 별도로 GROUP BY 관련 코멘트("Using index for group-by")나 임시 테이블 사용 또는 정렬 관련 코멘트("Using temporary, Using filesort")가 표시되지 않는다.
  * 루스 인덱스 스캔을 이용하는 GROUP BY
    * ✏️ `루스 인덱스 스캔`: 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
    * MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있으며, 프리픽스 인덱스는 루스 인덱스 스캔을 사용할 수 없다.
    * 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다. 즉, 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.
    * 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.
  * 임시 테이블을 사용하는 GROUP BY
    * MySQL 8.0에서는 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다. 즉 별도의 정렬 작업 없이 GROUP BY가 처리된다.
* **DISINCT 처리**
  * SELECT DISTINCT
    * 단순히 SELECT되는 레코드 중에서 `유니크한 레코드`만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다. 이 경우 GROUP BY와 동일한 방식으로 처리된다.
    * 유의해야할 점은 DISTINCT는 SELECT하는 레코드(튜플)를 유니크하게 SELECT하는 것이지, 특정 컬럼만 유니크하게 조회하는 것이 아니다.
    * `SELECT DISTINCT(first_name), last_name FROM employees` 해당 쿼리는 first_name만 유니크하게 조회하고 last_name은 DISTINCT가 없을 때와 동일하게 조회하는 쿼리처럼 보이지만, MYSQL는 괄호를 의미없이 사용된 괄호로 해석하고 제거해버린다.(**= SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 컬럼에 영향을 미친다.**)
  * 집합 함수와 함께 사용된 DISTINCT
    * 집합 함수가 없는 SELECT 쿼리에서 DISTINCT는 조회하는 모든 컬럼의 조합이 유니크한 것들만 가져온다. 하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 컬럼값이 유니크한 것들을 가져온다.
* **내부 임시 테이블 활용**
  * 메모리 임시 테이블과 디스크 임시 테이블
    * MySQL 8.0 버전부터 메모리용 임시 테이블을 MEMORY와 TempTable 중에서 선택이 가능하다. 기본 값은 TempTable이다.
    * 임시 테이블의 크기가 1GB보다 커지는 경우 메모리의 임시 테이블을 디스크로 기록한다.(MMAP 파일로 디스크에 기록 또는 InnoDB 테이블로 기록)
  * 임시 테이블이 필요한 쿼리
    * ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
    * ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
    * DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
    * UNION이나 UNION DISTINCT가 사용된 쿼리
    * 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
  * 임시 테이블이 디스크에 생성되는 경우
    * UNION이나 UNION ALL에서 SELECT되는 컬럼 중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 굥우
    * GROUP BY나 DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
  * 임시 테이블 관련 상태 변수
    * Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
    * Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 갖고 있는 상태 값

## 🦅 9.3 고급 최적화
### 옵티마이저 스위치 옵션
MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다.   
옵티마이저 옵션은 크게 조인 관련 옵티마이저 옵션과 옵티마이저 스위치로 구분할 수 있다.
옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어하는데, 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.
* **MRR과 배치 키 액세스(mrr & batched_key_access)**
  * MRR은 "Multi-Range Read"로 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링 하는 것이다.
  * 조인 버퍼에 레코드가 가득 차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다.
  * 이렇게 함으로써 스토리지 엔진은 디스크의 데이터 페이지 읽기를 최소화 할 수 있다.
* **블록 네스티드 루프 조인(block_nested_loop)**
  * `네스티드 루프 조인`은 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.
  * 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 `조인 버퍼가 사용되는지 여부`와 `조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐`이다.
    * 네스티드 루프 조인: 조인 버퍼 미사용, 드라이빙 테이블에서 한 행을 가져와 드리븐 테이블에서 해당 행과 일치하는 레코드를 찾는 방법
    * 블록 네스티드 루프 조인: 조인 버퍼 사용, 드라이빙 테이블에서 가져온 데이터를 블록 단위로 버퍼에 저장하고 여러 레코드를 한꺼번에 드리븐 테이블과 조인한다.**(조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음을 기억해야한다.)**
* **인덱스 컨디션 푸시다운(index_condition_pushdown)**
  * `인덱스 컨디션 푸시다운`은 인덱스 스캔 중에 조건절을 최대한 일찍 적용하여 디스크로부터 불필요한 데이터 접근을 줄이는 최적화 기법이다.
  * `index_condition_pushdown`으로 활성화, 비활성화 할 수 있다.
  * 쿼리의 성능이 몇 배에서 몇십 배로 향상될 수도 있는 중요한 기능이다.
* **인덱스 확장(use_index_extensions)**
  * 해당 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
  * 해당 옵션 사용 시 옵티마이저가 인덱스 확장 기능을 활성화하여 더 많은 경우에 커버링 인덱스를 사용할 수 있다. 이를 통해 테이블에 직접 접근하는 횟수를 줄이고, 성능을 향상시킬 수 있다.
* **인덱스 머지(index_merge)**
  * 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
* **인덱스 머지 - 교집합(index_merge_intersection)**
  * `두 개 이상의 인덱스 교집합을 찾아 결과를 반환하는 방식`이다.
  * 즉, 쿼리 조건을 만족하는 레코드를 두 개 이상의 인덱스에서 모두 찾아 모든 인덱스가 공통적으로 일치하는 레코드만 반환한다.
* **인덱스 머지 - 합집합(index_merge_union)**
  * 두 개 이상의 인덱스에서 각각의 결과를 결합하여 합집합을 반환하는 방식이다.
  * 정렬 없이 단순히 결과를 합집합으로 결합한다. 중복되는 레코드는 결합하면서 제거한다.
* **인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)**
  * `두 개 이상의 인덱스에서 각각 일치하는 레코드를 찾고 이를 합집합으로 결합한 후 정렬하여 결과를 반환하는 방식`이다.
  * 즉, 쿼리 조건을 만족하는 레코드를 각 인덱스에서 따로 찾아낸 후 이를 정렬하여 중복 제거 후 결과를 반환한다.
* **세미 조인(semijoin)**
  * 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리이다.
* **테이블 풀-아웃(Table Pull-out)**
  * Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다.
  * 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이었다.
  * 테이블 풀 아웃 최적화는 세미 조인 서브쿼리에서만 사용 가능하다.
* **퍼스트 매치(firstmatch)**
  * First Match 최적화 전략은 조인 시 첫 번째로 일치하는 레코드를 찾는 순간, 나머지 탐색을 멈추고 다음 레코드로 넘어가는 방식이다. 즉, 가능한 모든 조인 후보를 찾는 대신 첫 번째 일치하는 경우만을 찾아 불필요한 연산을 줄여 최적화한다.
  * GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.
* **루스 스캔(loosescan)**
  * 인덱스를 사용하여 데이터의 일부만 스캔하고, 각 그룹의 첫 번째 일치 항목을 빠르게 찾는 방식이다.
  * LooseScan 최적화는 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그 다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다. 따라서 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.
* **구체화(Materialization)**
  * 서브쿼리를 임시 테이블에 저장하여 필요할 때 재사용하는 방식이다.
  * 동일한 데이터에 대한 반복적인 연산을 줄일 수 있다.
  * 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
* **중복 제거(Duplicated Weed-out)**
  * Duplicated Weedout은 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.
  * 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
* **컨디션 팬아웃(condition_fanout_filter)**
  * 쿼리의 조건문이 여러 값으로 분기될 때 각 조건에 맞게 쿼리 성능을 개선하는 방식이다.
* **파생 테이블 머지(derived_merge)**
  * 쿼리에서 서브쿼리를 하나의 테이블처럼 사용하여 데이터를 조회하는 방식이다.
  * 파생 테이블을 최적화하여 불필요한 중간 테이블 생성 없이 직접적인 조인을 통해 성능을 향상시킨다.
* **인비저블 인덱스(use_invisible_indexes)**
  * 데이터베이스에 인덱스를 생성하되 쿼리 옵티마이저가 인덱스를 사용하지 않도록 설정하는 기능이다.
  * MySQL 8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다.
* **스킵 스캔(skip_scan)**
  * 데이터베이스가 복합 인덱스를 사용할 때 인덱스의 선행 컬럼을 무시하고 후행 컬럼으로부터 데이터를 검색하는 기법이다.
  * (A, B, C) 컬럼으로 구성된 인덱스가 있을 때 쿼리의 WHERE 절에 A와 B 컬럼에 대한 조건이 있다면 이 쿼리는 A 컬럼과 B 컬럼까지만 인덱스를 활용할 수 있다. 그런데 WHERE 절에 B와 C 컬럼에 대한 조건을 가지고 있다면 이 쿼리는 인덱스를 활용할 수 없다.
  * 위와 같은 제약 사항을 뛰어넘을 수 있는 최적화 기법이 스킵 스캔이다.
  * 인덱스의 선행 컬럼이 매우 다양한 값을 가지는 경우 스킵 스캔 최적화가 비효율적일 수 있다.
* **해시 조인(hash_join)**
  * 두 테이블 중 하나를 메모리에 해시 테이블로 만들고 다른 테이블을 해시 테이블과 비교하여 조인을 수행하는 방식이다.
  * 해시 조인은 빌드 단계(Build-phase)와 프로브 단계(Probe-phase)로 나뉘어 처리된다.
    * `빌드 단계`에서는 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성(빌드)하는 작업을 수행한다.
    * `프로브 단계`는 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정을 의미한다.
* **인덱스 정렬 선호(prefer_ordering_index)**
  * 쿼리에서 정렬이 필요한 경우 인덱스를 이용해 정렬을 미리 수행하여 성능을 향상시키는 방법이다.
### 조인 최적화 알고리즘
* **Exhaustive 검색 알고리즘**
  * MySQL 5.0과 그 이전 저번에서 사용되던 조인 최적화 기법으로, FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.
* **Greedy 검색 알고리즘**
  * Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 MySQL 5.0부터 도입된 조인 최적화 기법이다.
 
## 🦅 9.4 쿼리 힌트
### 인덱스 힌트
* **STRAIGHT_JOIN**
  * SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.
  * 임시 테이블과 일반 테이블의 조인: 이 경우 거의 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
  * 임시 테이블끼리 조인: 임시 테이블은 항상 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하므로 크기가 작은 테이블을 드라이빙으로 선택해주는 것이 좋다.
  * 일반 테이블끼리 조인: 양쪽 테이블 모두 조인 컬럼에 인덱스가 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋다.
* **USE INDEX / FORCE INDEX / IGNORE INDEX**
  * USE INDEX: 가장 자주 사용되는 인덱스 힌트로 MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트이다.
  * FORCE INDEX: USE INDEX와 비교해서 다른 점은 없으며 USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트이다.
  * IGNORE INDEX: USE INDEX나 FORCE INDEX와는 반대로 특정 인덱스를 사용하지 못하게 하는 용도로 사용하는 힌트다. 풀 테이블 스캔 사용을 유도하기 위해 사용할 수도 있다.
* **SQL_CALC_FOUND_ROWS**
  * 전체 결과 집합의 개수를 계산하는 데 사용되는 쿼리 옵션이다. LIMIT 쿼리에 해당 힌트가 포함된 경우 LIMIT를 만족하는 수만큼의 레코드를 찾았다고 하더라고 끝까지 검색을 수행한다.
  * 이 힌트는 성능 향상을 위해 만들어진 힌트가 아니라 개발자의 편의를 위해 만들어진 힌트라는 것을 명심하자.
### 옵티마이저 힌트
* **옵티마이저 힌트 종류**   
옵티마이저 힌트는 영향 범위에 따라 4개의 그룹으로 나누어 볼 수 있다.
  * 인덱스
  * 테이블
  * 쿼리 블록
  * 글로벌(쿼리 전체)
* **MAX_EXECUTION_TIME**
  * 단순히 쿼리의 최대 실행 시간을 설정하는 힌트로, 옵티마이저 힌트 중 유일하게 쿼리의 실행 계획에 영향을 미치지 않는다.
  * 시간 초과 시 쿼리가 강제 종료된다.
* **SET_VAR**
  * SET_VAR 힌트는 실행 계획을 바꾸는 용도뿐만 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가시켜 대용향 처리 쿼리의 성능을 향상시키는 용도로도 사용할 수 있다.
* **SEMIJOIN & NO_SEMIJOIN**
  * SEMIJOIN: 세미 조인을 사용하도록 강제하는 힌트이다.(+ 세미 조인은 서브쿼리에서 중복 제거 없이 첫 번째 매칭을 찾고 나머지를 무시하는 방식이다.)
  * NO_SEMIJOIN: 세미 조인을 사용하지 않도록 강제한다.
* **SUBQUERY**
  * 서브쿼리를 최적화 하는 데 사용되는 힌트로 서브쿼리를 특정 방식으로 처리하도록 강제한다.
* **BNL & NO_BNL & HASHJOIN & NO_HASHJOIN**
  * BNL: Block Nested Loop Join을 강제한다.(+ BNL은 작은 테이블을 메모리에 로드한 후 큰 테이블과 블록 단위로 비교하는 방식이다.)
  * NO_BNL: Block Nested Loop Join을 사용하지 않도록 강제한다.
  * HASHJOIN: 해시 조인을 강제한다.(+ 해시조인은 해시 테이블을 사용하여 조인을 처리하는 방식이다.)
  * NO_HASHJOIN: 해시 조인을 사용하지 않도록 강제한다.
* **JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX**
  * JOIN_FIXED_ORDER: 쿼리에서 지정된 테이블 순서대로 조인을 강제한다.
  * JOIN_ORDER: 특정 테이블 순서로 조인을 강제할 수 있다.
  * JOIN_PREFIX: 조인의 앞부분에 특정 테이블 순서를 강제한다.
  * JOIN_SUFFIX: 조인의 뒷부분에 특정 테이블 순서를 강제한다.
* **MERGE & NO_MERGE**
  * MERGE: 테이블을 병합하여 최적화된 시행 계획을 강제하는 힌트이다. 쿼리 옵티마이저가 병합을 통해 최적화하려는 경우 사용한다.
  * NO_MERGE: 테이블 병합을 방지하여 각 테이블을 독립적으로 처리하게 한다.
* **INDEX_MERGE & NO_INDEX_MERGE**
  * INDEX_MERGE: 두 개 이상의 인덱스를 병합하여 최적화하는 힌트이다. 여러 인덱스가 사용될 때 병합하여 처리할 수 있도록 강제한다.
  * NO_INDEX_MERGE: 인덱스 병합을 방지하고 하나의 인덱스만 사용하도록 강제한다.
* **NO_ICP(Index Condition Pushdown)**
  * 인덱스를 사용할 때 조건을 인덱스 레벨에서 처리하도록 하는 기법이다. `NO_ICP`는 이를 비활성화하고 모든 조건을 테이블에서 처리하게 강제한다.
* **SKIP_SCAN & NO_SKIP_SCAN**
  * SKIP_SCAN: 복합 인덱스를 사용할 때 인덱스의 선행 컬럼 조건 없이 후행 컬럼을 기준으로 인덱스 스캔을 강제하는 힌트이다.
  * NO_SKIP_SCAN: 스킵 스캔을 사용하지 않도록 강제한다.
* **INDEX & NO_INDEX**
  * INDEX: 특정 인덱스를 사용하도록 강제하는 힌트이다.
  * NO_INDEX: 특정 인덱스를 사용하지 않도록 강제하는 힌트이다.
