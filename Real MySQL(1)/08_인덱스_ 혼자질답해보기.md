<details>
  <summary>디스크를 읽는 방법에는 순차 I/O와 랜덤 I/O가 있습니다. 각각의 개념과 디스크 성능을 위해서 어떤 작업이 더 유리한지 설명해주세요.</summary>
  순차 I/O는 데이터가 디스크의 연속적인 위치에 저장되어 있어 데이터를 읽거나 쓸 때 디스크 헤더가 한 방향으로만 이동하여 처리하는 방식입니다.</br>
  랜덤 I/O는 데이터를 디스크의 임의의 위치에서 읽거나 쓰는 방식으로, 디스크 헤더가 여러 위치로 이동하여 처리하는 방식입니다.</br>
  디스크 헤더의 위치 이동 없이 많은 데이터를 한 번에 기록할 수 있는 순차 I/O 방법이 작업 부하가 작습니다. 따라서 디스크 성능을 위해서는 랜덤 I/O 방식을 최소화해야 합니다.
</details>

<details>
  <summary>인덱스는 무엇인가요? 어떤 방식으로 구현할 수 있나요?</summary>
  인덱스는 테이블의 데이터 읽기 속도를 높이기 위해 사용하는 데이터 구조로 B-Tree 인덱스 알고리즘, Hash 인덱스 알고리즘의 방식으로 구현할 수 있습니다.
</details>

<details>
  <summary>테이블의 데이터 읽기 속도를 높이기 위해 인덱스를 사용한다고 말씀해주셨어요. 그럼 테이블에 인덱스를 추가하는 게 항상 옳은가요?</summary>
  인덱스를 추가하는 게 항상 옳지는 않습니다. 인덱스를 저장할 때마다 정렬된 상태를 유지해야 하기 때문에 INSERT, UPDATE, DELETE와 같은 데이터의 저장 성능을 희생해야 합니다.</br>
  따라서, 데이터의 저장 속도를 어디까지 희생할 수 있는지와 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 인덱스 추가 여부를 판단할 수 있습니다.
</details>

<details>
  <summary>B-Tree 인덱스는 어떤 구조를 갖고 있나요?</summary>
  트리 구조의 최상위에 하나의 루트 노드, 가장 하위에 리프 노드, 루트 노드와 리프 노드 사이에 브랜치 노드의 구조를 갖고 있습니다.
</details>

<details>
  <summary>클러스터링 인덱스는 무엇인가요?</summary>
  클러스터링 인덱스는 프라이머리 키와 데이터가 결합된 형태로 데이터를 물리적으로 정렬하여 저장하는 인덱스입니다. 클러스터링 키로 검색할 때 처리 성능이 매우 빠르다는 장점이 있지만, 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다는 단점이 있습니다.
</details>

<details>
  <summary>그럼 프라이머리 키가 없는 테이블은 클러스터링 테이블이 어떻게 구성되나요?</summary>
  프라이머리 키가 없으면 먼저 NOT NULL 옵션을 가진 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택합니다. 이 경우도 없다면, 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택합니다.
</details>
