## 🦅 10.1 통계 정보
MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.   
하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.   
그래서 MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.   
히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.
### 테이블 및 인덱스 통계 정보
* **MySQL 서버의 통계 정보**
  * MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다.
  * 이처럼 통계 정보가 메모리에 관리될 경우 MySQL 서버가 재시작되면 지금까지 수집된 통계 정보가 모두 사라진다.
  * MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 개선됐다. 이렇게 통계 정보를 테이블로 관리함으로써 MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.
### 히스토그램
* **히스토그램 정보 수집 및 삭제**
  * MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.
  * 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다.
  * MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.
    * Singeton(싱글톤 히스토그램): 컬럼값 개별로 레코드 건수를 관리하는 히스토그램
    * Equi-Height(높이 균형 히스토그램): 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램
* **히스토그램의 용도**
  * MySQL 서버의 `기존 통계 정보를 데이터가 항상 균등한 분포도를 가지지 않는 점`을 고려하지 못했다.
  * 이러한 단점을 보완하기 위해 히스토그램이 도입됐다. 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
  * 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
* **히스토그램과 인덱스**
  * ✏️`인덱스 다이브`: 옵티마이저가 쿼리 실행 계획을 생성할 때 인덱스의 통계 데이터를 세부적으로 조사하는 과정이다. 이를 통해 옵티마이저는 쿼리 성능을 최적화하기 위해 특정 인덱스를 사용할지 여부를 결정한다.
### 코스트 모델(Cost Model)
* `전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용`을 코스트 모델(Cost Model)이라 한다.
* MySQL 5.7 이전 버전까지는 이런 작업들의 비용을 MySQL 서버 소스 코드에 **상수화**해서 사용했다. 이 작업들의 비용은 MySQL 서버가 사용하는 하드웨어에 따라 달라질 수 있기 때문에 예전 버전처럼 고정된 비용을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어 방해 요소였다.
* 이런 단점을 보완하기 위해 MySQL 5.7 버전부터 MySQL 서버의 소스 코드에 상수화되어 있던 각 단위 작업의 비용을 **DBMS 관리자가 조정할 수 있게 개선**됐다. 하지만 MySQL 5.7 버전에서는 인덱스되지 않은 컬럼의 데이터 분포(히스토그램)나 메모리에 상주 중인 페이지의 비율 등 **비용 계산과 연관된 부분의 정보가 부족한 상태**였다.
* MySQL 8.0 버전으로 업그레이드되면서 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다.
* MySQL 8.0 서버의 코스트 모델
  * `server_cost` 테이블: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  * `engine_cost` 테이블: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
  * `server_cost`, `engine_cost` 테이블이 공통으로 갖고 있는 컬럼
    * cost_name
    * default_value
    * cost_value
    * last_updated
    * comment
    * engine_name, device_type: engine_cost 테이블만 갖고 있는 컬럼
## 🦅 10.2 실행 계획 확인
### 실행 계획 출력 포맷
* MySQL 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.
* `EXPLAIN FORMAT=TREE`
### 쿼리의 실행 시간 확인
* MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.
* `EXPLAIN ANALYZE` 명령은 항상 결과를 TREE 포맷으로 보여주기 때문에 EXPLAIN 명령에 FORMAT 옵션을 사용할 수 없다.
* `EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여준다. 따라서 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 EXPLAIN ANALYZE 명령을 사용하면 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있다.

## 🦅 10.3 실행 계획 분석 
**실행 계획의 출력 포맷보다는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 더 중요하다**   
### id 칼럼
* 각 쿼리에서 실행되는 단위별로 쿼리의 단계(순서)를 나타내는 요소
* 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다.(= 쿼리 블록을 구분하는 역할을 한다.)
### select_type 칼럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼(단일쿼리인지, 서브쿼리인지, UNION인지...)   
* **SIMPLE**
  * UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
* **PRIMARY**
  * UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
* **UNION**
  * UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리
  * UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION이 되는 쿼리 결과들을 모아서 저장하는 임시테이블(DERIVED)가 select_type으로 표시된다.
* **DEPENDENT UNION**
  * UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다. **DEPENDENT**는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
* **UNION RESULT**
  * UNION 결과를 담아두는 테이블을 의미한다.
  * MySQL 8.0 이전 버전에서는 UNION ALL이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시테이블로 생성했었는데, **MySQL 8.0 버전부터는 `UNION ALL`의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.**
  * **하지만, `UNION`은 MySQL 8.0 버전에서도 여전히 임시 테이블에 결과를 버퍼링한다.**
  * UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.
* **SUBQUERY**
  * FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.
* **DEPENDENT SUBQUERY**
  * 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
  * 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.
* **DERIVED**
  * DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
  * ✏️ **쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 컬럼의 값이 DERIVED인 것이 있는지 확인해야 한다.** 서브쿼리를 조인으로 해결할 수 있는 경우하면 서브쿼리보다는 조인을 사용할 것을 강력히 권장한다.
* **DEPENDENT DERIVED**
  * 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.
* **UNCHACHEABLE SUBQUERY**
  * 캐싱되지 않는 서브쿼리를 의미한다.(= 서브쿼리가 매번 실행될 때마다 새롭게 평가되어야 한다.)
  * 쿼리 캐시나 파생 테이블(DERIVED)과는 전혀 무관한 기능이다.
* **UNCACHEABLE UNION**
  * UNION과 UNCACHEABLE 두 개의 키워드 속성이 혼합된 select_type을 의미한다.
* **MATERIALIZED**
  * DERIVED와 비슷하게 쿼리의 내용을 임시 테이블로 생성한다.
### table 칼럼
### partitions 칼럼
### type 칼럼
쿼리 실행 계획에서 type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.   
* **system**
  * 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
  * InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.
* **const**
  * 테이블의 레코드 건수와 관계없이 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
* **eq_ref**
  * 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
  * 조인에서 처음 읽은 테이블의 컬럼값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.
* **ref**
* **fulltext**
* **ref_or_null**
* **unique_subquery**
* **index_subquery**
* **range**
* **index_merge**
* **index**
* **ALL**
