## 🦅 10.1 통계 정보
MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.   
하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.   
그래서 MySQL 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.   
히스토그램이 도입됐다고 해서 기존의 테이블이나 인덱스의 통계 정보가 필요치 않은 것은 아니다.
### 테이블 및 인덱스 통계 정보
* **MySQL 서버의 통계 정보**
  * MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되고, SHOW INDEX 명령으로만 테이블의 인덱스 칼럼의 분포도를 볼 수 있었다.
  * 이처럼 통계 정보가 메모리에 관리될 경우 MySQL 서버가 재시작되면 지금까지 수집된 통계 정보가 모두 사라진다.
  * MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 개선됐다. 이렇게 통계 정보를 테이블로 관리함으로써 MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.
### 히스토그램
* **히스토그램 정보 수집 및 삭제**
  * MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.
  * 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다.
  * MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.
    * Singeton(싱글톤 히스토그램): 컬럼값 개별로 레코드 건수를 관리하는 히스토그램
    * Equi-Height(높이 균형 히스토그램): 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램
* **히스토그램의 용도**
  * MySQL 서버의 `기존 통계 정보를 데이터가 항상 균등한 분포도를 가지지 않는 점`을 고려하지 못했다.
  * 이러한 단점을 보완하기 위해 히스토그램이 도입됐다. 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
  * 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
* **히스토그램과 인덱스**
  * ✏️`인덱스 다이브`: 옵티마이저가 쿼리 실행 계획을 생성할 때 인덱스의 통계 데이터를 세부적으로 조사하는 과정이다. 이를 통해 옵티마이저는 쿼리 성능을 최적화하기 위해 특정 인덱스를 사용할지 여부를 결정한다.
### 코스트 모델(Cost Model)
* `전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용`을 코스트 모델(Cost Model)이라 한다.
* MySQL 5.7 이전 버전까지는 이런 작업들의 비용을 MySQL 서버 소스 코드에 **상수화**해서 사용했다. 이 작업들의 비용은 MySQL 서버가 사용하는 하드웨어에 따라 달라질 수 있기 때문에 예전 버전처럼 고정된 비용을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 있어 방해 요소였다.
* 이런 단점을 보완하기 위해 MySQL 5.7 버전부터 MySQL 서버의 소스 코드에 상수화되어 있던 각 단위 작업의 비용을 **DBMS 관리자가 조정할 수 있게 개선**됐다. 하지만 MySQL 5.7 버전에서는 인덱스되지 않은 컬럼의 데이터 분포(히스토그램)나 메모리에 상주 중인 페이지의 비율 등 **비용 계산과 연관된 부분의 정보가 부족한 상태**였다.
* MySQL 8.0 버전으로 업그레이드되면서 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다.
* MySQL 8.0 서버의 코스트 모델
  * `server_cost` 테이블: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
  * `engine_cost` 테이블: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
  * `server_cost`, `engine_cost` 테이블이 공통으로 갖고 있는 컬럼
    * cost_name
    * default_value
    * cost_value
    * last_updated
    * comment
    * engine_name, device_type: engine_cost 테이블만 갖고 있는 컬럼
## 🦅 10.2 실행 계획 확인
### 실행 계획 출력 포맷
* MySQL 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.
* `EXPLAIN FORMAT=TREE`
### 쿼리의 실행 시간 확인
* MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.
* `EXPLAIN ANALYZE` 명령은 항상 결과를 TREE 포맷으로 보여주기 때문에 EXPLAIN 명령에 FORMAT 옵션을 사용할 수 없다.
* `EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여준다. 따라서 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 EXPLAIN ANALYZE 명령을 사용하면 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있다.

## 🦅 10.3 실행 계획 분석 
**실행 계획의 출력 포맷보다는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 더 중요하다**   
### id 칼럼
* 각 쿼리에서 실행되는 단위별로 쿼리의 단계(순서)를 나타내는 요소
* 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다.(= 쿼리 블록을 구분하는 역할을 한다.)
### select_type 칼럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼(단일쿼리인지, 서브쿼리인지, UNION인지...)   
* **SIMPLE**
  * UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
* **PRIMARY**
  * UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
* **UNION**
  * UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리
  * UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION이 되는 쿼리 결과들을 모아서 저장하는 임시테이블(DERIVED)가 select_type으로 표시된다.
* **DEPENDENT UNION**
  * UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다. **DEPENDENT**는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
* **UNION RESULT**
  * UNION 결과를 담아두는 테이블을 의미한다.
  * MySQL 8.0 이전 버전에서는 UNION ALL이나 UNION(또는 UNION DISTINCT) 쿼리는 모두 UNION의 결과를 임시테이블로 생성했었는데, **MySQL 8.0 버전부터는 `UNION ALL`의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.**
  * **하지만, `UNION`은 MySQL 8.0 버전에서도 여전히 임시 테이블에 결과를 버퍼링한다.**
  * UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.
* **SUBQUERY**
  * FROM 절 이외에서 사용되는 서브쿼리만을 의미한다.
* **DEPENDENT SUBQUERY**
  * 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
  * 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.
* **DERIVED**
  * DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
  * ✏️ **쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 컬럼의 값이 DERIVED인 것이 있는지 확인해야 한다.** 서브쿼리를 조인으로 해결할 수 있는 경우하면 서브쿼리보다는 조인을 사용할 것을 강력히 권장한다.
* **DEPENDENT DERIVED**
  * 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.
* **UNCHACHEABLE SUBQUERY**
  * 캐싱되지 않는 서브쿼리를 의미한다.(= 서브쿼리가 매번 실행될 때마다 새롭게 평가되어야 한다.)
  * 쿼리 캐시나 파생 테이블(DERIVED)과는 전혀 무관한 기능이다.
* **UNCACHEABLE UNION**
  * UNION과 UNCACHEABLE 두 개의 키워드 속성이 혼합된 select_type을 의미한다.
* **MATERIALIZED**
  * DERIVED와 비슷하게 쿼리의 내용을 임시 테이블로 생성한다.
### table 칼럼
### partitions 칼럼
### type 칼럼
쿼리 실행 계획에서 type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.   
* **system**
  * 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
  * InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.
* **const**
  * 테이블의 레코드 건수와 관계없이 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
  * 다른 DBMS에서는 이를 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고도 표현한다.
* **eq_ref**
  * 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
  * 조인에서 처음 읽은 테이블의 컬럼값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.
* **ref**
  * ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다.
  * 인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다.
  * ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다.
* **fulltext**
  * MySQL 서버의 **전문 검색(Full-text Search) 인덱스**를 사용해 레코드를 읽는 접근 방법을 의미한다.
  * 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.
  * MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다. 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const나 eq_ref, ref가 아니면 일반적으로 MySQL은 전문 인덱스를 사용하는 조건을 선택해서 처리한다.
  * 전문 검색은 `MATCH (...) AGAINST (...)` 구문을 사용해서 실행하는데, 이 때 반드시 해 당 테이블에 전문 검색용 인덱스가 준비돼 있어야만 한다.
  * 보통 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는 경우가 더 많았다. 따라서 전문 검색 쿼리를 사용할 때는 **조건별로 성능을 확인해 보는 편이 좋다.**
* **ref_or_null**
  * ref 방식 또는 NULL 비교(IS NULL) 접근 방법을 의미한다.
  * 실제 업무에서 많이 활용되지는 않지만, 만약 사용된다면 나쁘지 않은 접근 방법이다.
* **unique_subquery**
  * 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.
  * WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다. 
* **index_subquery**
  * 서브쿼리 결과의 중복 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.
* **range**
  * 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.
  * 주로 "<, >, IS NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
* **index_merge**
  * 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후, 그 결과를 병합해서 처리하는 방식이다.
  * index_merge 방법의 특징
    * 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
    * 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
    * index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.
* **ALL**
  * 풀 테이블 스캔을 의미하는 접근 방법이다. 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거(체크 조건이 존재할 때)하고 반환한다.
  * 풀 테이블 스캔은 가장 마지막에 선택하는 가장 비효율적인 방법이다.
  * 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니라는 점을 기억하자.
### possible_keys 칼럼
possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이다. 즉, 말 그대로 "사용될 법했던 인덱스의 목록"이다. 
### key 칼럼
possible_keys 칼럼의 인덱스가 사용 후보였던 반면, key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
### key_len 칼럼
key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다. 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.
### ref 칼럼
접근 방법이 ref면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 칼럼의 값은 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.
### rows 칼럼
rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.
### filtered 칼럼
filtered 칼럼은 특정 쿼리에서 필터링된 데이터의 비율을 퍼센트로 표시하여 보여준다. 값이 높을수록 쿼리가 많은 행을 필터링하지 않고 선택했다는 의미이고, 낮을수록 더 많은 데이터가 필터링되었다는 의미이다.
### Extra 칼럼
* const row not found
* Deleting all rows
* Distinct
* FirstMatch
* Full scan on NULL key
* Impossible HAVING
* LooseScan
* No matching min/max row
* no matching row in const table
* No matching rows after partition pruning
* No tables used
* Not exists
* Plan isn't ready yet
* Range checked for each record(index map:N)
* Recursive
* Rematerialize
* Select tables optimized away
* Start temporary, End temporary
* unique row not found
* Using filesort
* Using index(커버링 인덱스)
* Using index condition
* Using index for group-by
  * 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리
  * 루스 인덱스 스캔을 통한 GROUP BY 처리
* Using index for skip scan
* Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)
* Using MRR
* Using sort_union(...), Using union(...), Using intersect(...)
* Using temporary
* Using where
