## 🦅 8.1 디스크 읽기 방식
* **하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)**
  * SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다. 그래서 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.
  * 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 `순차 I/O`에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이지만, SSD는 기존 하드 디스크 드라이브보다 `랜덤 I/O`가 훨씬 빠르다.
* **랜덤 I/O와 순차 I/O**
  * `랜덤 I/O`는 **HDD의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것**을 의미하는데, 사실 `순차 I/O` 또한 이 작업 과정은 같다.
    * 두 I/O의 차이점은 디스크의 기록해야 할 위치를 찾기 위해 디스크 헤드를 몇 번 움직였냐는 것이다.
  * **디스크의 성능은 디스크의 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐**에 의해 결정된다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 `랜덤 I/O` 작업이 작업 부하가 훨씬 더 크다.
  * 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.

## 🦅 8.2 인덱스란?
* `SortedList`는 DBMS의 인덱스와 같은 자료구조로, 저장되는 값을 항상 정렬된 상태로 유지한다.
  * 장점: 이미 정렬되어 있기 때문에 아주 빨리 원하는 값을 찾아올 수 있다.
  * 단점: 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다.  
* `ArrayList`는 데이터 파일과 같은 자료구조로, 저장되는 순서 그대로 값을 유지한다.
* 결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
* **인덱스를 역할별로 구분할 경우**
  * `프라이머리 키`: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  * `세컨더리 인덱스`: 프라이머리 키를 제외한 나머지 모든 인덱스
* **인덱스를 데이터 저장 방식(알고리즘)별로 구분할 경우**
  * `B-Tree 인덱스`: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  * `Hash 인덱스`: 칼럼의 값으로 해시 값을 계산해 인덱싱하는 알고리즘, 매우 빠른 검색을 지원. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

## 🦅 8.3 B-Tree 인덱스
* **구조 및 특성**
  ![image](https://github.com/user-attachments/assets/785a8691-1ea7-4743-b5d7-21af79b21759)
  * `루트 노드`: 최상위 노드
  * `리프 노드`: 가장 하위에 있는 노드
  * `브랜치 노드`: 트리구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드
  * MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
  * 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다. 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, **프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.**
* **B-Tree 인덱스 키 추가 및 삭제**   
  인덱스키 추가나 삭제가 어떻게 처리되는지 알아두면 쿼리의 성능을 쉽게 예측할 수 있을 것이다.   
  * 인덱스 키 추가
    * B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
    * 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하기 때문에 상위 브랜치 노드까지 처리의 범위가 넓어진다. **이러한 작업 때문에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.**
    * MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
    * InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.
  * 인덱스 키 삭제
    * 해당 키 값이 저장된 B-Tree의 리프노드를 찾아서 삭제 마크만 하면 작업이 완료된다.
    * 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
  * 인덱스 키 변경
    * B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
    * InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.
  * 인덱스 키 검색
    * `트리 탐색`: 인덱스 검색 작업 시 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 수행하는 비교 작업
    * 인덱스 트리 탐색은 SELECT, UPDATE, DELETE를 처리하기 위해 사용된다.
    * B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.(부등호 비교 조건에도 활용가능하지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.)
* **B-Tree 인덱스 사용에 영향을 미치는 요소**
  * 인덱스 키 값의 크기
    * 인덱스는 페이지 단위로 관리되며 루트, 브랜치, 리프 노드를 구분한 기준도 페이지 단위이다.
    * 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree의 자식노드의 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
    * 인덱스를 구성하는 키 값의 키가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다 것을 의미한다.
  * B-Tree 깊이
    * B-Tree의 깊이는 **MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지**와 직결되는 문제다.
    * 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.
  * 선택도(기수성)
    * `선택도(기수성)`: 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
    * 인덱스는 선택도가 높을수록(=유니크한 값의 수가 많을수록) 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
  * 읽어야 하는 레코드의 건수
    * 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 `4~5배`정도 비용이 더 많이 드는 작업인 것으로 예측한다.
    * 즉, 인덱스를 통해 읽어야 할 레코드의 건수(=옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.
* **B-Tree 인덱스를 통한 데이터 읽기**
  * **인덱스 레인지 스캔**
    * `인덱스 레인지 스캔`은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
    * 실제 인덱스만을 읽는 경우와 B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야하는 경우가 있다.
    * 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다(인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.)
    * 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
    * 인덱스 레인지 스캔은 인덱스 탐색, 인덱스 스캔, 최종 레코드를 읽어오는 3가지 과정으로 이루어진다(커버링 인덱스의 경우 최종 레코드를 읽어오는 과정은 필요하지 않을 수 있다.)
  * **인덱스 풀 스캔**
    * `인덱스 풀 스캔`은 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식이다.
    * 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다. 인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.
    * 이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
  * **루스 인덱스 스캔**
    *`루스 인덱스 스캔`은 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리하는 방식이다.
    * 일반적으로 GROUP BY 또는 집합 함수 가운에 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.
  * **인덱스 스킵 스캔**
    * `인덱스 스킵 스캔`은 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스하는 스캔 방식이다.
    * 인덱스 스킵 스캔의 단점
      * WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 한다.(쿼리의 처리 성능이 오히려 더 느려질 수 있기 때문에)
      * 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 한다(커버링 인덱스)
* **다중 칼럼(Multi-column) 인덱스**
  * `다중 컬럼 인덱스`: 두 개 이상의 컬럼으로 구성된 인덱스
  * 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼 있다(만약 컬럼이 4개인 인덱스를 생성한다면 세번 째 컬럼은 두 번째 컬럼에 의존해서 정렬된다.)
* **B-Tree 인덱스의 정렬 및 스캔 방향**
  * 인덱스의 정렬   
    MySQL 5.7 버전까지는 컬럼 단위로 정렬 순서를 혼합(ASC와 DESC)해서 인덱스를 생성할 수 없었다. 하지만 MySQL 8.0 버전부터는 혼합 인덱스를 생성할 수 있게 됐다.
    * 인덱스 스캔 방향
      * ```
        mysql> SELECT *
               FROM employees
               ORDER BY first_name DESC
               LIMIT 1;
        ```
        **이 쿼리를 실행하기 위해서는 인덱스를 처음부터 오름차순으로 끝까지 읽어 first_name이 가장 큰(오름차순으로 읽었을 때 가장 마지막 레코드) 값 하나를 가져오는 것일까?** ➡️ 아니다. 옵티마이저는 인덱스를 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있음을 알기 때문이다.
    * 내림차순 인덱스
      * ✏️`오름차순 인덱스`: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
      * ✏️`내림차순 인덱스`: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
      * ✏️`인덱스 정순 스캔`: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
      * ✏️`인덱스 역순 스캔`: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
      * 내림차순과 오름차순의 내부적인 차이로 인한 성능: MySQL InnoDB 스토리지 엔진에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다(이유: 페이지 잠금이 인덱스 정순 스캔에 적합한 구조, 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조)
* **B-Tree 인덱스의 가용성과 효율성**   
  쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다. 그래야만 쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있기 때문이다.
  * 비교 조건의 종류와 효율성
    * 다중 컬럼 인덱스에서 각 컬럼의 순서와 크 컬럼에 사용된 조건이 동등 비교("=")인지 아니면 크다(">") 또는 작다("<") 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.
  * 인덱스의 가용성
  * 가용성과 효율성 판단
    * **B-Tree 인덱스 특성상 `작업 범위 결정 조건`으로 사용할 수 없는 조건**
      1. NOT-EQUAL로 비교된 경우
      2. LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
      3. 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변향된 후 비교된 경우
      4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
      5. 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
      6. 문자열 데이터 타입의 콜레이션이 다른 경우
    * **다중 컬럼으로 만들어진 인덱스 중 사용가능/불가능 경우**   
      `INDEX ix_test (column_1, column_2, column_3, .., column_n)`
      * 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
        1. column_1 컬럼에 대한 조건이 없는 경우
        2. column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
      * 작업 범위 결정 조건으로 인덱스를 사용하는 경우
        1. column_1 ~ column_(i-1) 컬럼까지 동등 비교 형태("=" 또는 "IN")로 비교
        2. column_i 컬럼에 대해 다음 연산자 중 하나로 비교
           * 동등 비교("=" 또는 "IN")
           * 크다 작다 형태(">" 또는 "<")
           * LIKE로 좌측 일치 패턴(LIKE '승환%')

## 🦅 8.4 R-Tree 인덱스
✏️`공간 인덱스`: R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스   
* MySQL 공간 확장의 기능
  * 공간 데이터를 저장할 수 있는 데이터 타입
  * 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
  * 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)
* **구조 및 특성**   
  ![image](https://github.com/user-attachments/assets/f071c650-6858-46b0-9c6c-a806d79e4bb0)
  * ✏️`MBR(Minimum Bounding Rectangle, 최소 경계 상자)`: 도형을 감싸는 최소 크기의 사각형. 위 이미지의 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree인덱스이다.
* **R-Tree 인덱스의 용도**
  * 일반적으로 **위도, 경도 좌표** 저장에 사용된다..
  * '현재 사용자의 위치로부터 반경 5km 이내의 음식점 검색' 등과 같은 검색에 사용할 수 있다.
  * 공간 인덱스를 사용할 수 있는 `ST_Contains()`나 `ST_Within()`을 이용해 거리 기반 검색을 해야한다.

## 🦅 8.5 전문 검색(Full Text search) 인덱스
* **인덱스 알고리즘**
  * 어근 분석 알고리즘
    * MySQL 서버의 전문 검색 인덱스는 `불용어(Stop Word) 처리`, `어근 분석(Stemming)` 과정을 거쳐 색인 작업이 수행된다.
    * ✏️`불용어 처리`: 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
    * ✏️`어근 분석`: 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
  * n-gram 알고리즘
    * `n-gram`이란 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.
    * 형태소 분석보다는 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없는 반면, 만들어진 인덱스의 크기는 상당히 큰 편이다.
    * n은 인덱싱할 최소 글자 수를 의미한다.
  * 불용어 변경 및 삭제
    * 전문 검색 인덱스의 불용어 처리 무시
      * **첫 번째**는 스토리지 엔진에 관계없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거하는 것이다.(`ft_stopword_file`시스템 변수에 빈 문자열 설정)
      * **두 번째**는 InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리를 무시할 수도 있다.(`innodb_ft_enable_stopword` 시스템 변수 OFF)
    * 사용자 정의 불용어 사용
      * **첫 번째 방법**은 불용어 목록을 파일로 저장하고, MySQL 서버 설정 파일에서 파일의 경로를 등록하는 것이다.(`ft_stop_file='/data/my_custom_stopword.txt'`)
      * **두 번째 방법**은 InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 엔진에서만 사용할 수 있으며, 불용어의 목록을 테이블로 저장하는 방식이다.
* **전문 검색 인덱스의 가용성**   
  전문 검색 인덱스를 사용하려면 반드시 두 가지 조건을 갖춰야 한다.   
  * 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...)을 사용
  * 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

## 🦅 8.6 함수 기반 인덱스   
MySQL 서버의 함수 기반 인덱스를 **인덱싱할 값을 계산하는 과정의 차이만 있을 뿐**, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree의 인덱스와 동일하다.
* **가상 칼럼을 이용한 인덱스**
  * 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.
* **함수를 이용한 인덱스**
  * 함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다.
  * **함수 기반 인덱스를 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.** 함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식이 다르다면 MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못한다.

## 🦅 8.7 멀티 밸류(Multi-Value) 인덱스
멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.   
멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안되고, `MEMBER OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()` 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.   

## 🦅 8.8 클러스터링 인덱스   
MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 `비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안`한 것이다.
* **클러스터링 인덱스**
  * 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용으로 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장한다.
  * 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로, 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다.
  * 🤔 그럼 프라이머리 키가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 수정될까? -> 우선순위가 존재한다.
    1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
    2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번쨰 인덱스를 클러스터링 키로 선택
    3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택
* **세컨더리 인덱스에 미치는 영향**
  * 🤔 InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 어떻게 될까? 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다.
  * **이런 오버헤드를 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.**
* **클러스터링 인덱스의 장점과 단점**
  * 장점
    * 프라이머리 키로 검색할 때 처리 성능이 매우 빠르다.
    * 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.
  * 단점
    * 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 처진다.
    * 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느리다.
* **클러스터링 테이블 사용 시 주의사항**
  * 클러스처링 인덱스 키의 크기
  * 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)
  * 프라이머리 키는 반드시 명시할 것
  * AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

## 🦅 8.9 유니크 인덱스
* **유니크 인덱스와 일반 세컨더리 인덱스의 비교**
  * 인덱스 읽기
    * 유니크 인덱스가 빠르다고 생각할 수 있지만, 사실이 아니다.
    * 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼 값을 비교하는 작업이기 때문에 이는 성능상 영향이 거의 없다.
  * 인덱스 쓰기
    * 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하기 때문에 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
* **유니크 인덱스 사용 시 주의사항**
  * 성능이 더 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지는 않는 것이 좋다.
  * 똑같은 컬럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성한 경우는 불필요한 중복이므로 주의하자.
 
## 🦅 8.10 외래키   
InnoDB의 외래키 관리에는 중요한 두 가지 특징이 있다.
1. **테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.**
2. **외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.**
