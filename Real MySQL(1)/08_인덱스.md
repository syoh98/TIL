## 🦅 8.1 디스크 읽기 방식
* **하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)**
  * SSD는 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 그 대신 플래시 메모리를 장착하고 있다. 그래서 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.
  * 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 `순차 I/O`에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이지만, SSD는 기존 하드 디스크 드라이브보다 `랜덤 I/O`가 훨씬 빠르다.
* **랜덤 I/O와 순차 I/O**
  * `랜덤 I/O`는 **HDD의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것**을 의미하는데, 사실 `순차 I/O` 또한 이 작업 과정은 같다.
    * 두 I/O의 차이점은 디스크의 기록해야 할 위치를 찾기 위해 디스크 헤드를 몇 번 움직였냐는 것이다.
  * **디스크의 성능은 디스크의 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐**에 의해 결정된다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 `랜덤 I/O` 작업이 작업 부하가 훨씬 더 크다.
  * 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.
## 🦅 8.2 인덱스란?
* `SortedList`는 DBMS의 인덱스와 같은 자료구조로, 저장되는 값을 항상 정렬된 상태로 유지한다.
  * 장점: 이미 정렬되어 있기 때문에 아주 빨리 원하는 값을 찾아올 수 있다.
  * 단점: 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다.  
* `ArrayList`는 데이터 파일과 같은 자료구조로, 저장되는 순서 그대로 값을 유지한다.
* 결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
* **인덱스를 역할별로 구분할 경우**
  * `프라이머리 키`: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  * `세컨더리 인덱스`: 프라이머리 키를 제외한 나머지 모든 인덱스
* **인덱스를 데이터 저장 방식(알고리즘)별로 구분할 경우**
  * `B-Tree 인덱스`: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  * `Hash 인덱스`: 칼럼의 값으로 해시 값을 계산해 인덱싱하는 알고리즘, 매우 빠른 검색을 지원. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.
## 🦅 8.3 B-Tree 인덱스
* **구조 및 특성**
  ![image](https://github.com/user-attachments/assets/785a8691-1ea7-4743-b5d7-21af79b21759)
  * `루트 노드`: 최상위 노드
  * `리프 노드`: 가장 하위에 있는 노드
  * `브랜치 노드`: 트리구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드
  * MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
  * 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다. 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, **프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.**
* **B-Tree 인덱스 키 추가 및 삭제**   
  인덱스키 추가나 삭제가 어떻게 처리되는지 알아두면 쿼리의 성능을 쉽게 예측할 수 있을 것이다.   
  * 인덱스 키 추가
    * B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
    * 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하기 때문에 상위 브랜치 노드까지 처리의 범위가 넓어진다. **이러한 작업 때문에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.**
    * MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
    * InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.
  * 인덱스 키 삭제
    * 해당 키 값이 저장된 B-Tree의 리프노드를 찾아서 삭제 마크만 하면 작업이 완료된다.
    * 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.
  * 인덱스 키 변경
    * B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
    * InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 이 작업 모두 체인지 버퍼를 활용해 지연 처리될 수 있다.
  * 인덱스 키 검색
    * `트리 탐색`: 인덱스 검색 작업 시 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 수행하는 비교 작업
    * 인덱스 트리 탐색은 SELECT, UPDATE, DELETE를 처리하기 위해 사용된다.
    * B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.(부등호 비교 조건에도 활용가능하지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.)
* **B-Tree 인덱스 사용에 영향을 미치는 요소**
  * 인덱스 키 값의 크기
    * 인덱스는 페이지 단위로 관리되며 루트, 브랜치, 리프 노드를 구분한 기준도 페이지 단위이다.
    * 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree의 자식노드의 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
    * 인덱스를 구성하는 키 값의 키가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다 것을 의미한다.
  * B-Tree 깊이
    * B-Tree의 깊이는 **MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지**와 직결되는 문제다.
    * 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.
  * 선택도(기수성)
    * `선택도(기수성)`: 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
    * 인덱스는 선택도가 높을수록(=유니크한 값의 수가 많을수록) 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
  * 읽어야 하는 레코드의 건수
    * 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 `4~5배`정도 비용이 더 많이 드는 작업인 것으로 예측한다.
    * 즉, 인덱스를 통해 읽어야 할 레코드의 건수(=옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.
* **B-Tree 인덱스를 통한 데이터 읽기**
  * 인덱스 레인지 스캔
  * 인덱스 풀 스캔
  * 루스 인덱스 스캔
  * 인덱스 스킵 스캔
* **다중 칼럼(Multi-column) 인덱스**
* **B-Tree 인덱스의 정렬 및 스캔 방향**
  * 인덱스의 정렬
    * 인덱스 스캔 방향
    * 내림차순 인덱스
* **B-Tree 인덱스의 가용성과 효율성**
  * 비교 조건의 종류와 효율성
  * 인덱스의 가용성
  * 가용성과 효율성 판단
## 🦅 8.4 R-Tree 인덱스

## 🦅 8.5 전문 검색(Full Text search) 인덱스

## 🦅 8.6 함수 기반 인덱스

## 🦅 8.7 멀티 밸류(Multi-Value) 인덱스

## 🦅 8.8 클러스터링 인덱스

## 🦅 8.9 유니크 인덱스

## 🦅 8.10 외래키
