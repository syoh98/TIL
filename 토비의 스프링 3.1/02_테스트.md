## 🌱 2.1 UserDaoTest 다시 보기
* 앞서 UserDao의 클래스를 책임에 따라 이리저리 분리하고, 인터페이스를 도입하고, 오브젝트 팩토리를 통해 생성하도록 만들고, 또 스프링의 DI 방식을 XML 설정파일까지 써서 사용했을 때 그것이 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법에는 어떤 것이 있겠는가?   
* 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다.   
* **테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는 지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.**'
* **또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.**
### 💡 UserDaoTest의 특징
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step8/UserDaoTest.java
* 웹을 통한 DAO 테스트 방법의 문제점
  * 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 많이 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다.
  * DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다.
  * 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 **이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제**가 있다.
* 작은 단위의 테스트
  * 한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.
  * 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.
    * ✏️ **이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위테스트라고 한다.**
  * **단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.**
* 자동수행 테스트 코드
  * UserDaoTest의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다.
  * 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
  * 자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다.
### 💡 UserDaoTest의 문제점
* 수동 확인 작업의 번거로움
  * UserDaoTest는 테스트를 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다.
* 실행 작업의 번거로움
  * 아무리 간단한 실행 가능한 main() 메서드라고 하더라고 매번 그것을 실행하는 것은 번거롭다. 좀 더 체계적으로 테스트를 실행하고 결과를 확인하는 방법이 필요하다.
</br>

## 🌱 2.2 UserDaoTest 개선
UserDaoTest의 두 가지 문제점을 개선해보자.
### 💡 테스트 검증의 자동화
```java
if(!user.getName().equals(user2.getName())) {
    System.out.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
    System.out.println("테스트 실패 (password)");
} else {
    System.out.println("조회 테스트 성공");
}
```
* 이 테스트는 UserDao의 두 가지 기능이 정상적으로 동작하는지를 언제든지 손쉽게 확인할 수 있게 해준다. 따라서 이 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든 자시 실행해볼 수 있다.
* 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것이다.
### 💡 테스트의 효율적인 수행과 결과 관리
좀 더 편리하게 테스트를 수행하고 편히라게 결과를 확인하려면 단순한 `main()` 메서드로는 한계가 있다.   
➡️ `JUnit` 테스트 지원 도구를 사용해서 테스트해보자.
* 테스트 메서드 전환
  * 기존에 만들었던 `main()` 메서드 테스트는 제어권을 직접 갖기 때문에, 프레임워크에 적용하기엔 적합하지 않다.
  * 따라서 가장 먼저 할 일은 `main()` 메서드에 있던 테스트 코드를 일반 메서드로 옮기는 것이다.
  * 새로 만들 테스트 메서드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다.
    1. 메서드가 `public`으로 선언되어야 한다.
    2. 메서드에 `@Test` 어노테이션을 붙여주어야 한다.
* 검증 코드 전환
  * `if(!user.getName().equals(user2.getName())) {...}` ➡️ `assertThat(user2.getName(), is(user.getName()));`
  * `else if(!user.getPassword().equals(user2.getPassword())) {...}` ➡️ `assertThat(user2.getPassword(), is(user.getPassword()));`
</br>

## 🌱 2.3 개발자를 위한 테스팅 프레임워크 JUnit
### 💡 테스트 결과의 일관성
* 지금까지 테스트를 실행하면서 **가장 큰 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점이다.**(매번 UserDaoTEst테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 한다.)
* 반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. **코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.**
* UserDaoTest에서는 `deleteAll()` 메서드로 USER 테이블의 모든 레코드를 삭제하고, `getCount()`로 USER 테이블의 레코드 개수를 돌려주는 기능을 추가했다.
  * `deleteAll()`은 검증되지 않았다. 그래서 `getCount()`를 함께 적용하자.
  * 그런데 `getCount()`는 잘 동작하는지 어떻게 믿을 수 있을까? `getCount()` 메서드가 테이블의 레코드 숫자에 상관없이 항상 0을 돌려주는 코드가 짜여져 있다면, `deleteAll()`을 검증하는데 사용할 수 없다.
  * 그래서 `getCount()`에 대한 검증 작업을 하나 더 추가한다. `add()`메서드를 실행한 뒤에 `getCount()`의 결과를 한 번 더 확인해보자.
  * 위 결과로 짜여진 테스트 코드
    ```java
    @Test
    public void addAndGet() throws SQLException {
        //...
    
        dao.deleteAll();
        assertThat(dao.getCount(), is(0));
    
        User user = new User();
        user.setId("syoh98");
        user.setName("소제로");
        user.getPassword("1q2w3e4r");

        dao.add(user);
        assertThat(dao.getCount(), is(1));

        User user2 = new User();

        assertThat(user2.getName(), is(user.getName()));
        assertThat(user2.getPassword(), is(user.getPassword()));
    }
    ```
### 💡 동일한 결과를 보장하는 테스트
* 단위테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다.
* DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말하야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.
* 포괄적인 테스트
  * 개발자가 테스트를 직접 만들 때 자주하는 실수는 **성공하는 테스트만 골라서 만드는 것**이다.
  * 개발자는 머릿속으로 이 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적이다.
  * 그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다.
### 💡 테스트가 이끄는 개발
* **기능설계를 위한 테스트**
  * 우리가 한 작업을 돌이켜보면 **테스트할 코드도 없는데 어떻게 테스트를 만들 수 있었을까?**
  * 그것은 만들어진 코드를 보고 이것을 어떻게 테스트할까라고 생각하면서 `getUserFailure()`를 만든 것이 아니라, 추가하고 싶은 기능을 코드로 표현하려고 했기 때문에 가능했다.
  * 추가하고 싶은 기능을 일반 언어가 아니라 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어놓은 것이라고 생각해보자. 그런 다음 실제 기능을 가진 애플리케이션 코드를 만들고 나면, 바로 이 테스트를 실행해서 설계한 대로 코드가 동작하는지를 빠르게 검증할 수 있다.
  * 테스트가 성공한다면, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것이다.
* **테스트 주도 개발(TDD)**
  * **만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법**
  * "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙이다.
  * TDD는 아예 테스트를 먼저 만들고 그 테스트가 성송하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어 낼 수 있다.
  * TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다.   
**✏️ 픽스처**
 * 테스트를 수행하는 데 필요한 정보나 오브젝트
 * 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메서드를 이용해 생성해두면 편리하다.
</br>

## 🌱 2.4 스프링 테스트 적용

## 🌱 2.5 학습 테스트로 배우는 스프링
* 때로는 **자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성**해야하는데, 이런 테스트를 `학습 테스트`라 한다.
* 학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 따라서 테스트이지만 **프레임워크나 기능에 대한 검증이 목적이 아니다.**
### 💡 학습 테스트의 장점
* 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
* 학습 테스트 코드를 개발 중에 참고할 수 있다.
* 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
* 테스트 작성에 대한 좋은 훈련이 된다.
* 새로운 기술을 공부하는 과정이 즐거워진다.   
➡️ 스프링 학습 테스트를 만들 때 참고할 수 있는 가장 좋은 소스는 **바로 스프링 자신에 대한 테스트 코드**다.
### 💡 버그 테스트
* 버그 테스트란 **코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트**를 말한다.
* 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것이다.
* 그런 후 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다. 테스트가 성공하면 버그는 해결된 것이다.
* **[버그 테스트의 필요성과 장점]**
  * 테스트의 완성도를 높여준다.
  * 버그의 내용을 명확하게 분석하게 해준다.
  * 기술적인 문제를 해결하는 데 도움이 된다.
</br>

## 🌱 2.6 정리
* 테스트는 자동화 되어야 하고, 빠르게 실행할 수 있어야 한다.
* `main()` 메서드 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
* 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안된다.
* 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
* 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
* 테스트하기 쉬운 코드가 좋은 코드다.
* 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
* 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
* `@Before`, `@After`를 사용해서 테스트 메서드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
* 스프링 테스트 컨텍스트 프레임워크를 시용하면 테스트 성능을 향상시킬 수 있다.
* 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
* `@Autowired`를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
* 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
* 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
