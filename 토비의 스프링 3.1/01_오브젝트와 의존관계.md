## 🌱 1.1 초난감 DAO
* 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자
* 새로운 사용자를 생성하고(add), 아이디를 가지고 사용자 정보를 읽어오는(get) 메소드를 먼저 만들어보자   
  ➡️ main()을 이용한 DAO 테스트 코드
```java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");

      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      ps.executeUpdate();

      ps.close();
      c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");
      ....
  }
}
```
  * UserDao 클래스 코드의 문제점은 무엇일까?
    * 문제점이라고 하면 뭔가 기능이 정상적으로 동작하지 않아야 할 텐데, 위의 DAO는 우리가 기대했던 기능을 충실하게 동작한다.
    * 그렇다면, 왜 이 코드에 문제가 많다고 하는 것일까?
    * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
    * 그렇게 DAO 코드를 개선했을 때의 장점은 무엇일까? 그런 장점들이 당장에, 또는 미래에 주는 유익은 무엇인가? 또, 객체지향 설계의 원칙과는 무슨 상관이 있을까?
    * 이 DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
</br>

## 🌱 1.2 관심사의 분리
* **✏️ 관심사의 분리란?**
  * 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

### 💡 커넥션 만들기의 추출
* UserDao의 관심사항(`add()` 메서드 하나에서만 적어도 세 가지 관심사항을 발견할 수 있다.)
  * DB과 연결을 위한 커넥션을 어떻게 가져올까?
  * 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
  * 작업이 끝나면 사용한 리소스인 Statment와 Connection 오브젝트를 닫아줘서 공유 리소스를 시스템에 돌려주는 것
* **관심사를 분리해보자!**   
  ➡️ 문제점: add()와 get()에서 DB 커넥션을 가져오는 코드가 중복되어 있다, DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메서드에 담겨있다.   
  ➡️ 하나의 관심사가 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.   
  * 중복 코드의 메소드 추출
    * 커넥션을 가져오는 중복된 코드를 분리하자
      * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step2/UserDao.java
      * ➡️ DB 연결과 관련된 부분에 변경이 일어났을 경우, 예를 들어 DB 종류와 접속 방법이 바뀌어서 드라이버 클래스와 URL이 바뀌었다거나, 로그인 정보가 변경돼도 앞으로는 `getConnection()`이라는 한 메서드의 코드만 수정하면 된다.
    * 변경사항에 대한 검증: 리팩토링과 테스트
      * 중복된 코드를 분리하는 작업은 UserDao의 기능에는 아무런 변화를 주지 않았다.
      * 이 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 기능이 추가되거나 바뀐 것은 없지만 UserDao는 이전보다 훨씬 깔끔해졌고 변화에 쉽게 대응할 수 있는 코드가 됐다
      * ➡️ 이런 작업을 `리팩토링`이라 한다. 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 `메소드 추출`기법이라 한다.
    * **✏️ 리팩토링이란?**
      * 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
### 💡 DB 커넥션 만들기의 독립
각각 다른 업체가  UserDao를 사용하고 싶어한다.   
문제는 각기 다른 종류의 DB를 사용하고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶어한다.   
➡️ 이런 경우 UserDao 소스코드를 각 업체에 제공해주지 않고, 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?
* 상속을 통한 확장   
  코드를 한 단계 더 분리하자
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step3/UserDao.java
  * UserDao에서 메소드의 구현 코드를 제거하고 `getConnection()`을 추상메서드로 만들자
  * 각 업체는 UserDao 클래스를 상속해서 서브클래스를 만들어 원하는 방식대로 구현한다.
  * ➡️ 새로운 DB 연결 방법을 적용해야 할 때는 UserDao를 상속을 통해 확장해주기만 하면 된다.
    * ✏️ 상위클래스에 기본적인 로직의 흐름을 만들고 기 기능의 일부를 추상 메서드나 오버라이딩이 가능한 메서드로 만든 후 하위클래스에서 해당 메서드를 필요에 맞게 구현해서 사용하는 것을 `템플릿 메서드 패턴`이라 한다.
    * ✏️ `getConnection()` 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지 결정하는데, 이렇게 하위클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라 한다.
* **이 방법은 상속을 사용했다는 단점이 있다.**
  * 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
  * 상속관계는 완전한 관심사의 독립이 아니다. 하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.
  * DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다.
</br>

## 🌱 1.3 DAO의 확장
### 💡 클래스의 분리
* DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 독립적인 클래스로 분리하자.
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step4/SimpleConnectionMaker.java
  * 이 방법은 UserDao의 소스코드를 함께 제공하지 않고는 DB 연결 방법을 바꿀 수 없다는 처음 문제로 다시 되돌아와 버렸다.
  * ➡️ 두 가지 문제를 해결해야 한다.
    1. SimpleConnectionMaker의 메서드
    2. DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고있어야 한다는 점
### 💡 인터페이스의 도입
따라서, 인터페이스를 활용하자
* 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/ConnectionMaker.java
* **UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.**
* UserDao의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다.
### 💡 관계설정 책임의 분리
* UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심.
* ➡️ 이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/UserDaoTest.java
  * 이 관심을 분리해서 클라이언트에게 떠넘겨주자
  * UserDao에 있으면 안 되는 다른 관심사항, 책임을 클라이언트로 떠넘기는 작업이 끝났다.
### 💡 원칙과 패턴
* 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 높은 응집도와 낮은 결합도
  * 높은 응집도: 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
  * 낮은 결합도: 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태
    * 결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다.
* 전략 패턴
  * 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.

## 🌱 1.4 제어의 역전(IOC)

## 🌱 1.5 스프링의 IoC

## 🌱 1.6 싱글톤 레지스트리와 오브젝트 스코프

## 🌱 1.7 의존관계 주입(DI)

## 🌱 1.8 XML을 이용한 설정

## 🌱 1.9 정리
