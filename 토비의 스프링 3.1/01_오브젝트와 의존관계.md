## 🌱 1.1 초난감 DAO
* 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자
* 새로운 사용자를 생성하고(add), 아이디를 가지고 사용자 정보를 읽어오는(get) 메소드를 먼저 만들어보자   
  ➡️ main()을 이용한 DAO 테스트 코드
```java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");

      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      ps.executeUpdate();

      ps.close();
      c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");
      ....
  }
}
```
  * UserDao 클래스 코드의 문제점은 무엇일까?
    * 문제점이라고 하면 뭔가 기능이 정상적으로 동작하지 않아야 할 텐데, 위의 DAO는 우리가 기대했던 기능을 충실하게 동작한다.
    * 그렇다면, 왜 이 코드에 문제가 많다고 하는 것일까?
    * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
    * 그렇게 DAO 코드를 개선했을 때의 장점은 무엇일까? 그런 장점들이 당장에, 또는 미래에 주는 유익은 무엇인가? 또, 객체지향 설계의 원칙과는 무슨 상관이 있을까?
    * 이 DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
</br>

## 🌱 1.2 관심사의 분리
* **✏️ 관심사의 분리란?**
  * 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

### 💡 커넥션 만들기의 추출
* UserDao의 관심사항(`add()` 메서드 하나에서만 적어도 세 가지 관심사항을 발견할 수 있다.)
  * DB과 연결을 위한 커넥션을 어떻게 가져올까?
  * 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
  * 작업이 끝나면 사용한 리소스인 Statment와 Connection 오브젝트를 닫아줘서 공유 리소스를 시스템에 돌려주는 것
* **관심사를 분리해보자!**   
  ➡️ 문제점: add()와 get()에서 DB 커넥션을 가져오는 코드가 중복되어 있다, DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메서드에 담겨있다.   
  ➡️ 하나의 관심사가 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.   
  * 중복 코드의 메소드 추출
    * 커넥션을 가져오는 중복된 코드를 분리하자
      * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step2/UserDao.java
      * ➡️ DB 연결과 관련된 부분에 변경이 일어났을 경우, 예를 들어 DB 종류와 접속 방법이 바뀌어서 드라이버 클래스와 URL이 바뀌었다거나, 로그인 정보가 변경돼도 앞으로는 `getConnection()`이라는 한 메서드의 코드만 수정하면 된다.
    * 변경사항에 대한 검증: 리팩토링과 테스트
      * 중복된 코드를 분리하는 작업은 UserDao의 기능에는 아무런 변화를 주지 않았다.
      * 이 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 기능이 추가되거나 바뀐 것은 없지만 UserDao는 이전보다 훨씬 깔끔해졌고 변화에 쉽게 대응할 수 있는 코드가 됐다
      * ➡️ 이런 작업을 `리팩토링`이라 한다. 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 `메소드 추출`기법이라 한다.
    * **✏️ 리팩토링이란?**
      * 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
### 💡 DB 커넥션 만들기의 독립
각각 다른 업체가  UserDao를 사용하고 싶어한다.   
문제는 각기 다른 종류의 DB를 사용하고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶어한다.   
➡️ 이런 경우 UserDao 소스코드를 각 업체에 제공해주지 않고, 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?
* 상속을 통한 확장   
  코드를 한 단계 더 분리하자
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step3/UserDao.java
  * UserDao에서 메소드의 구현 코드를 제거하고 `getConnection()`을 추상메서드로 만들자
  * 각 업체는 UserDao 클래스를 상속해서 서브클래스를 만들어 원하는 방식대로 구현한다.
  * ➡️ 새로운 DB 연결 방법을 적용해야 할 때는 UserDao를 상속을 통해 확장해주기만 하면 된다.
    * ✏️ 상위클래스에 기본적인 로직의 흐름을 만들고 기 기능의 일부를 추상 메서드나 오버라이딩이 가능한 메서드로 만든 후 하위클래스에서 해당 메서드를 필요에 맞게 구현해서 사용하는 것을 `템플릿 메서드 패턴`이라 한다.
    * ✏️ `getConnection()` 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지 결정하는데, 이렇게 하위클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라 한다.
* **이 방법은 상속을 사용했다는 단점이 있다.**
  * 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
  * 상속관계는 완전한 관심사의 독립이 아니다. 하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.
  * DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다.
</br>

## 🌱 1.3 DAO의 확장
### 💡 클래스의 분리
* DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 독립적인 클래스로 분리하자.
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step4/SimpleConnectionMaker.java
  * 이 방법은 UserDao의 소스코드를 함께 제공하지 않고는 DB 연결 방법을 바꿀 수 없다는 처음 문제로 다시 되돌아와 버렸다.
  * ➡️ 두 가지 문제를 해결해야 한다.
    1. SimpleConnectionMaker의 메서드
    2. DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고있어야 한다는 점
### 💡 인터페이스의 도입
따라서, 인터페이스를 활용하자
* 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/ConnectionMaker.java
* **UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.**
* UserDao의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다.
### 💡 관계설정 책임의 분리
* UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심.
* ➡️ 이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/UserDaoTest.java
  * 이 관심을 분리해서 클라이언트에게 떠넘겨주자
  * UserDao에 있으면 안 되는 다른 관심사항, 책임을 클라이언트로 떠넘기는 작업이 끝났다.
### 💡 원칙과 패턴
* 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 높은 응집도와 낮은 결합도
  * 높은 응집도: 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
  * 낮은 결합도: 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태
    * 결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다.
* 전략 패턴
  * 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.
</br>

## 🌱 1.4 제어의 역전(IOC)
원래 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것인데, 또 다른 책임까지 떠맡고 있어 문제가 있다.   
성격이 다른 책임이나 관심사는 분리해버리자.   
### 💡 오브젝트팩토리
팩토리: 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용한다.(어떻게 만들지와 어떻게 사용할지는 다른 관심이다.)
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step6/UserDaoFactory.java
  * UserDaoTest는 이제 UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 그만이다.
  * ➡️ 각각이 자신의 책임에만 충실하도록 역할에 따라 분리되었다.
* 만약, 다른 Dao에서 ConnectionMaker를 사용하려고 하면 중복된다
  ```java
  public class DaoFactory {
      public UserDao userDao() {
          return new UserDao(new DConnectionMaker());    // ConncetionMaker 구현 클래스를 선정하고 생성하는 코드의 중복
      }
      public AccountDao accountDao() {
          return new AccountDao(new DConnectionMaker()); // ConncetionMaker 구현 클래스를 선정하고 생성하는 코드의 중복
      }
  }
  ```
  * 이런 경우 오브젝트를 만드는 코드를 별도의 메서드로 뽑아내자
* ✏️ **제어의 역전이란?**
  * 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
  * 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다.
  * 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.
  * 앞서 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 IoC를 적용하는 작업이었다고 볼 수 있다!
</br>

## 🌱 1.5 스프링의 IoC
### 💡 오브젝트 팩토리를 이용한 스프링 IoC
* 애플리케이션 컨텍스트와 설정정보
  * `1.4`에서 애플리케이션의 로직을 담고 있는 컴포넌트와 설계도 역할을 하는 팩토리를 구분했었다.
  * 이 설계도라는 게 애플리케이션 컨텍스트와 설정정보를 말한다고 보면 된다.
  * 그 자체로는 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당하는 것이다.
* DaoFactory를 사용하는 애플리케이션 컨텍스트
  * `@Configuration`: 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
  * `@Bean`: 오브젝트 생성을 담당하는 IoC용 메서드라는 표시
    * ➡️ 이 두개의 어노테이션은 자바코드의 탈을 쓰고 있지만, 사실은 XML과 같은 스프링 전용 설정정보라고 보는 것이 좋다.
### 💡 애플리케이션 컨텍스트의 동작방식
애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다
### 💡 스프링 IoC의 용어 정리
* 빈
  * 스프링이 IoC 방식으로 관리하는 오브젝트
  * 주의할 점: 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니다.
  * 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
* 빈 팩토리
  * 스프링의 IoC를 담당하는 핵심 컨테이너
  * 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외의 부가적인 빈을 관리하는 기능을 담당한다.
* 애플리케이션 컨텍스트
  * 빈 팩토리를 확장한 IoC 컨테이너
  * 빈을 등록하고 관리하는 기본적인 기능은 빈팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
  * 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이다.
  * ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가리키는 것이기도 하다.
  * ApplicationContext는 BeanFactory를 상속한다.
* 설정정보/설정 메타정보
  * 애플리케이션 컨텍스트 또는 빈팩토리가 IoC를 적용하기 위해 사용하는 메타정보
  * 영어로 `configuration`, 구성정보/형상정보의 의미
* 컨테이너 또는 IoC 컨테이너
  * IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
* 스프링 프레임워크
  * IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.
</br>

## 🌱 1.6 싱글톤 레지스트리와 오브젝트 스코프
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.   
단순하게 `getBean()`을 실행할 때마다 `userDao()`메서드를 호출하고, 매번 new에 의해 새로운 UserDao가 만들어지지 않는다. 왜그럴까?
애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 `싱글톤 레지스트리`이기도 하다.
## 💡싱글톤 레지스트리로서의 애플리케이션 컨텍스트
* 서버 애플리케이션과 싱글톤
  * 왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.
  * 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.
* 싱글톤 패턴의 한계
  * private 생성자를 갖고 있기 때문에 상속할 수 없다
  * 싱글톤은 테스트하기가 힘들다
  * 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  * 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
* 싱글톤 레지스트리
  * 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
    * ➡️이것이 `싱글톤 레지스트리`다.
  * 싱글톤 레지스트리의 장점은 스태틱 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 **평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점**이다.
  * 가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.
## 💡싱글톤과 오브젝트의 상태
* 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있기 때문에 상태 관리에 주의를 기울여야 한다.
* 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야할까?
  * 이 때는 파라미터와 로컬 변수, 리턴 값들을 이용하자.
## 💡스프링 빈의 스코프
* 스프링 빈의 기본 스코프는 싱글톤이다
* 싱글톤 스코프는 컨테이너 내의 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
</br>

## 🌱 1.7 의존관계 주입(DI)

## 🌱 1.8 XML을 이용한 설정

## 🌱 1.9 정리
