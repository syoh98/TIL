## 🌱 1.1 초난감 DAO
* 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자
* 새로운 사용자를 생성하고(add), 아이디를 가지고 사용자 정보를 읽어오는(get) 메소드를 먼저 만들어보자   
  ➡️ main()을 이용한 DAO 테스트 코드
```java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");

      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      ps.executeUpdate();

      ps.close();
      c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection c = DriverManager.getConnection("jdbc:mysql://localhost:13306/springbook?characterEncoding=UTF-8", "spring", "book");
      ....
  }
}
```
  * UserDao 클래스 코드의 문제점은 무엇일까?
    * 문제점이라고 하면 뭔가 기능이 정상적으로 동작하지 않아야 할 텐데, 위의 DAO는 우리가 기대했던 기능을 충실하게 동작한다.
    * 그렇다면, 왜 이 코드에 문제가 많다고 하는 것일까?
    * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
    * 그렇게 DAO 코드를 개선했을 때의 장점은 무엇일까? 그런 장점들이 당장에, 또는 미래에 주는 유익은 무엇인가? 또, 객체지향 설계의 원칙과는 무슨 상관이 있을까?
    * 이 DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
</br>

## 🌱 1.2 관심사의 분리
* **✏️ 관심사의 분리란?**
  * 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

### 💡 커넥션 만들기의 추출
* UserDao의 관심사항(`add()` 메서드 하나에서만 적어도 세 가지 관심사항을 발견할 수 있다.)
  * DB과 연결을 위한 커넥션을 어떻게 가져올까?
  * 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
  * 작업이 끝나면 사용한 리소스인 Statment와 Connection 오브젝트를 닫아줘서 공유 리소스를 시스템에 돌려주는 것
* **관심사를 분리해보자!**   
  ➡️ 문제점: add()와 get()에서 DB 커넥션을 가져오는 코드가 중복되어 있다, DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메서드에 담겨있다.   
  ➡️ 하나의 관심사가 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.   
  * 중복 코드의 메소드 추출
    * 커넥션을 가져오는 중복된 코드를 분리하자
      * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step2/UserDao.java
      * ➡️ DB 연결과 관련된 부분에 변경이 일어났을 경우, 예를 들어 DB 종류와 접속 방법이 바뀌어서 드라이버 클래스와 URL이 바뀌었다거나, 로그인 정보가 변경돼도 앞으로는 `getConnection()`이라는 한 메서드의 코드만 수정하면 된다.
    * 변경사항에 대한 검증: 리팩토링과 테스트
      * 중복된 코드를 분리하는 작업은 UserDao의 기능에는 아무런 변화를 주지 않았다.
      * 이 작업은 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 기능이 추가되거나 바뀐 것은 없지만 UserDao는 이전보다 훨씬 깔끔해졌고 변화에 쉽게 대응할 수 있는 코드가 됐다
      * ➡️ 이런 작업을 `리팩토링`이라 한다. 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 `메소드 추출`기법이라 한다.
    * **✏️ 리팩토링이란?**
      * 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
### 💡 DB 커넥션 만들기의 독립
각각 다른 업체가  UserDao를 사용하고 싶어한다.   
문제는 각기 다른 종류의 DB를 사용하고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶어한다.   
➡️ 이런 경우 UserDao 소스코드를 각 업체에 제공해주지 않고, 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?
* 상속을 통한 확장   
  코드를 한 단계 더 분리하자
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step3/UserDao.java
  * UserDao에서 메소드의 구현 코드를 제거하고 `getConnection()`을 추상메서드로 만들자
  * 각 업체는 UserDao 클래스를 상속해서 서브클래스를 만들어 원하는 방식대로 구현한다.
  * ➡️ 새로운 DB 연결 방법을 적용해야 할 때는 UserDao를 상속을 통해 확장해주기만 하면 된다.
    * ✏️ 상위클래스에 기본적인 로직의 흐름을 만들고 기 기능의 일부를 추상 메서드나 오버라이딩이 가능한 메서드로 만든 후 하위클래스에서 해당 메서드를 필요에 맞게 구현해서 사용하는 것을 `템플릿 메서드 패턴`이라 한다.
    * ✏️ `getConnection()` 메서드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지 결정하는데, 이렇게 하위클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메서드 패턴`이라 한다.
* **이 방법은 상속을 사용했다는 단점이 있다.**
  * 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
  * 상속관계는 완전한 관심사의 독립이 아니다. 하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.
  * DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다.
</br>

## 🌱 1.3 DAO의 확장
### 💡 클래스의 분리
* DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 독립적인 클래스로 분리하자.
  * https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step4/SimpleConnectionMaker.java
  * 이 방법은 UserDao의 소스코드를 함께 제공하지 않고는 DB 연결 방법을 바꿀 수 없다는 처음 문제로 다시 되돌아와 버렸다.
  * ➡️ 두 가지 문제를 해결해야 한다.
    1. SimpleConnectionMaker의 메서드
    2. DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고있어야 한다는 점
### 💡 인터페이스의 도입
따라서, 인터페이스를 활용하자
* 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/ConnectionMaker.java
* **UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.**
* UserDao의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다.
### 💡 관계설정 책임의 분리
* UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심.
* ➡️ 이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step5/UserDaoTest.java
  * 이 관심을 분리해서 클라이언트에게 떠넘겨주자
  * UserDao에 있으면 안 되는 다른 관심사항, 책임을 클라이언트로 떠넘기는 작업이 끝났다.
### 💡 원칙과 패턴
* 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 높은 응집도와 낮은 결합도
  * 높은 응집도: 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
  * 낮은 결합도: 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태
    * 결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다.
* 전략 패턴
  * 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.
</br>

## 🌱 1.4 제어의 역전(IOC)
원래 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것인데, 또 다른 책임까지 떠맡고 있어 문제가 있다.   
성격이 다른 책임이나 관심사는 분리해버리자.   
### 💡 오브젝트팩토리
팩토리: 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용한다.(어떻게 만들지와 어떻게 사용할지는 다른 관심이다.)
* https://github.com/bingbingpa/dev-book/blob/main/toby-spring/src/main/java/me/bingbingpa/vol1/ch1/dao/step6/UserDaoFactory.java
  * UserDaoTest는 이제 UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 그만이다.
  * ➡️ 각각이 자신의 책임에만 충실하도록 역할에 따라 분리되었다.
* 만약, 다른 Dao에서 ConnectionMaker를 사용하려고 하면 중복된다
  ```java
  public class DaoFactory {
      public UserDao userDao() {
          return new UserDao(new DConnectionMaker());    // ConncetionMaker 구현 클래스를 선정하고 생성하는 코드의 중복
      }
      public AccountDao accountDao() {
          return new AccountDao(new DConnectionMaker()); // ConncetionMaker 구현 클래스를 선정하고 생성하는 코드의 중복
      }
  }
  ```
  * 이런 경우 오브젝트를 만드는 코드를 별도의 메서드로 뽑아내자
* ✏️ **제어의 역전이란?**
  * 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
  * 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다.
  * 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.
  * 앞서 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 IoC를 적용하는 작업이었다고 볼 수 있다!
</br>

## 🌱 1.5 스프링의 IoC
### 💡 오브젝트 팩토리를 이용한 스프링 IoC
* 애플리케이션 컨텍스트와 설정정보
  * `1.4`에서 애플리케이션의 로직을 담고 있는 컴포넌트와 설계도 역할을 하는 팩토리를 구분했었다.
  * 이 설계도라는 게 애플리케이션 컨텍스트와 설정정보를 말한다고 보면 된다.
  * 그 자체로는 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당하는 것이다.
* DaoFactory를 사용하는 애플리케이션 컨텍스트
  * `@Configuration`: 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
  * `@Bean`: 오브젝트 생성을 담당하는 IoC용 메서드라는 표시
    * ➡️ 이 두개의 어노테이션은 자바코드의 탈을 쓰고 있지만, 사실은 XML과 같은 스프링 전용 설정정보라고 보는 것이 좋다.
### 💡 애플리케이션 컨텍스트의 동작방식
애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다
### 💡 스프링 IoC의 용어 정리
* **빈**
  * 스프링이 IoC 방식으로 관리하는 오브젝트
  * 주의할 점: 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니다.
  * 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
* **빈 팩토리**
  * 스프링의 IoC를 담당하는 핵심 컨테이너
  * 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외의 부가적인 빈을 관리하는 기능을 담당한다.
* **애플리케이션 컨텍스트**
  * 빈 팩토리를 확장한 IoC 컨테이너
  * 빈을 등록하고 관리하는 기본적인 기능은 빈팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
  * 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이다.
  * ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가리키는 것이기도 하다.
  * ApplicationContext는 BeanFactory를 상속한다.
* **설정정보/설정 메타정보**
  * 애플리케이션 컨텍스트 또는 빈팩토리가 IoC를 적용하기 위해 사용하는 메타정보
  * 영어로 `configuration`, 구성정보/형상정보의 의미
* **컨테이너 또는 IoC 컨테이너**
  * IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
* **스프링 프레임워크**
  * IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.
</br>

## 🌱 1.6 싱글톤 레지스트리와 오브젝트 스코프
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.   
단순하게 `getBean()`을 실행할 때마다 `userDao()`메서드를 호출하고, 매번 new에 의해 새로운 UserDao가 만들어지지 않는다. 왜그럴까?
애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 `싱글톤 레지스트리`이기도 하다.
### 💡싱글톤 레지스트리로서의 애플리케이션 컨텍스트
* **서버 애플리케이션과 싱글톤**
  * 왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.
  * 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.
* **싱글톤 패턴의 한계**
  * private 생성자를 갖고 있기 때문에 상속할 수 없다
  * 싱글톤은 테스트하기가 힘들다
  * 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  * 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
* **싱글톤 레지스트리**
  * 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
    * ➡️이것이 `싱글톤 레지스트리`다.
  * 싱글톤 레지스트리의 장점은 스태틱 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 **평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점**이다.
  * 가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.
### 💡싱글톤과 오브젝트의 상태
* 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있기 때문에 상태 관리에 주의를 기울여야 한다.
* 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야할까?
  * 이 때는 파라미터와 로컬 변수, 리턴 값들을 이용하자.
### 💡스프링 빈의 스코프
* 스프링 빈의 기본 스코프는 싱글톤이다
* 싱글톤 스코프는 컨테이너 내의 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.
</br>

## 🌱 1.7 의존관계 주입(DI)
### 💡 제어의 역전(IoC)과 의존관계 주입
스프링이 서블릿 컨테이너처럼 서버에서 동작하는 서비스 컨테이너라는 뜻인지, 아니면 단순히 IoC 개념이 적용된 템플릿 메소드 패턴을 이용해 만들어진 프레임워크인지, 아니면 또 다른 IoC특징을 지닌 기술이라는 것인지 파악하기 힘들다.   
그래서 `의존관계 주입`이라는 의도가 명확히 드러나는 이름을 사용하기 시작했다.
### 💡 런타임 의존관계 설정
* 의존관계
  * <img src="https://github.com/syoh98/TIL/assets/76934280/49279a6e-654d-4ac3-b07d-ae95d442b8b2" width="400"/></br>
  * A가 B에 의존하고 있는 경우, B가 변하면 A에게 영향이 전달된다
  * 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 **방향성을 부여**해줘야한다.
* UserDao의 의존관계
  * <img src="https://github.com/syoh98/TIL/assets/76934280/7d29e40c-eef0-4587-b235-67b436d05146" width="400"/></br>
  * UserDao는 ConnectionMaker 인터페이스에만 의존하고 있다. 따라서 ConnectionMaker 인터페이스가 변한다면 그 영향을 UserDao가 직접적으로 받게 된다.
  * 하지만 ConnectionMaker 인터페이스를 구현한 클래스, 즉 DConnectionMaker 등이 다른 것으로 바뀌거나 그 내부에서 사용하는 메서드에 변화가 생겨도 UserDao에 영향을 주지 않는다.
  * 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워진다.
  * 의존관계 주입이란 세 가지 조건을 충족하는 작업을 말한다.
    1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
    2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
    3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
* UserDao의 의존관계 주입
  ```java
  public UserDao() {
      connectionMaker = new DConnectionMaker();
  }
  ```
  * **이 코드의 문제는 이미 런타임 시의 의존관계가 코드 속에 다 미리 결정되어 있다는 점이다**
  * ➡️ 그래서 IoC의 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정 권한을 위임한다. 그래서 최종적으로 만들어진 것이 DaoFactory이다.
### 💡 의존관계 검색과 주입
* 스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 코드에서는 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주빙과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색이라고 불리는 것도 있다.
* 의존관계 검색과 의존관계 주입 방법 중 어떤 것이 더 나을까?
  * 의존관계 주입의 방법이 훨씬 단순하고 깔끔하다.
  * 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다.
  * 반면 의존관계 주입에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다.
### 💡 의존관계 주입의 응용
* 기능 구현의 교환
* 부가기능 추가
### 💡 메서드를 이용한 의존관계 주입
생성자가 아닌 일반 메서드를 이용해 의존 오브젝트와의 관계를 주입해주는 두 가지 방법
* 수정자 메서드를 이용한 주입
  * 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용된다.
* 일반 메서드를 이용한 주입
  * 수정자 메서드처럼 set으로 시작해야하고 한 번 에 한 개의 파라미터만 가질 수 있다는 제약이 싫을 때 여러 개의 파라미터를 갖는 일반 메서드를 DI용으로 사용할 수 있다.
</br>

## 🌱 1.8 XML을 이용한 설정
* 스프링의 애플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다.
* XML 설정은 @Configuration과 @Bean이 붙은 자바 클래스로 만든 설정과 내용이 동일하다.
  * @Configuration을 <beans>, @Bean을 <bean>에 대응해서 생각하자
* 하나의 @Bean 메서드를 통해 얻을 수 있는 빈의 DI 정보는 세가지다.
  * 빈의 이름: @Bean 메서드 이름이 빈의 이름이다. 이 이름은 getBean()에서 사용된다.
  * 빈의 클래스: 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
  * 빈의 의존 오브젝트: 빈의 생성자나 수정자 메서드를 통해 의존 오브젝트를 넣어준다.
### 💡 connectionMaker() 전환
| |자바 코드 설정정보|XML 설정정보|
|---|---|---|
|빈 설정파일|@Configuration|< beans >|
|빈의 이름|@Bean methodName()|<bean id="methodName"|
|빈의 클래스|return new BeanClass();|class="a.b.c... BeanClass"|
</br>

## 🌱 1.9 정리
앞의 과정을 정리해보자
* 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다(관심사의 분리, 리팩토링)
* 그 중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도, 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다(전략패턴)
* 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고, 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만들었다(개방 폐쇄 원칙)
* 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고(낮은 결합도), 자신의 책임과 관심사에만 순수하게 집중하는(높은 응집도) 깔끔한 코드를 만들 수 있었다.
* 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘겼다. 또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어줬다(제어의 역전/IoC)
* 전통적인 싱글톤 패턴 구현 방식의 단점을 살펴보고, 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서도 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다(싱글톤 레지스트리)
* 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고, 런타임 시에 실제 사용할 구체적인 의존 오브젝트를 제 3자(DI 컨테이너)의 도움으로 주입받아서 다이내믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아봤다(의존관계 주입/DI)
* 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메서드를 이용하는 방법을 알아봤다(생성자 주입과 수정자 주입)
* 마지막으로, XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반 값을 외부에서 설정해서 런타임 시에 주입하는 방법을 알아봤다(XML 설정)
