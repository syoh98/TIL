## 🌱 6.1 트랜잭션 코드의 분리
트랜잭션 경계설정을 위한 코드를 넣음으로써 비즈니스 로직이 주인어야 할 메서드 안에 트랜잭션 코드가 차지하게 되었다.   
### 💡 메서드 분리
하지만, 논리적으로 트랜잭션의 경계는 분명히 **비즈니스 로직의 전후**에 설정되어야 한다.   
이러한 로직 안에서 깔끔한 코드를 만드는 방법은 `비즈니스 로직을 담당하는 코드를 메서드로 추출해서 독립`시키는 것이다~   
해당 방법이 가능한 이유는
* 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
   * 비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없다.
* 따라서 이 두 메서드는 성격이 다르기 때문에 메서드를 분리할 수 있는 것이다.
### 💡 DI를 이용한 클래스의 분리
비즈니스 로직을 담당하는 코드를 분리해서 깔끔한 코드를 만들어냈지만, 여전히 트랜잭션을 담당하는 코드가 UserService 안에 있다.   
따라서 트랜잭션 코드를 DI 적용을 통해 클래스 밖으로 뽑아내자.   
* 현재 UserService는 UserServiceTest가 클라이언트가 되어 `강한 결합`이 맺어져있다.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/f558a55f-275b-4e99-98d0-c6daa86737bc" width="400"/></br>
* `강한 결합`이 `약한 결합`을 가질 수 있도록 인터페이스를 이용하자.(직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능하다.)   
  <img src="https://github.com/syoh98/TIL/assets/76934280/d0f7dfe2-5a7e-4953-917d-a3c2c0dbe23b" width="400"/></br>
* 또한, 트랜잭션 경계설정을 위해 UserServiceTx를 도입하자.
  <img src="https://github.com/syoh98/TIL/assets/76934280/d823a767-0f11-4e08-b93d-dfa2fb4b86ba" width="480"/></br>
  ➡️ 위임을 통한 작업을 통해 클라이언트 입장에서 볼때는 결국 **트랜잭션이 적용된 비즈니스 로직의 구현**이라는 기대하는 동작이 일어날 것이다.
* 스프링 DI 설정에 의해 만들어진 빈 오브젝트와 의존관계는 이러하다!   
  <img src="https://github.com/syoh98/TIL/assets/76934280/0ba19488-d083-4c09-be7b-601cc42c5b72" width="480"/></br>
* 트랜잭션을 분리했으니 테스트 코드도 마찬가지로 수정해야 한다.   
* **🤔 트랜잭션 경계설정 코드의 분리와 DI를 통한 연결은 복잡하고 큰 개선 작업이다. 이런 과정으로 얻을 수 있는 장점은 무엇일까??**
  1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. (+트랜잭션 적용이 필요한지 신경 쓰지 않아도 된다.)
  2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.
</br>

## 🌱 6.2 고립된 단위 테스트
가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.   
**작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.**   
하지만 작은 단위로 테스트하고 싶어도 그럴 수 없는 경우가 많은데, 이 경우 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.
### 💡 복잡한 의존관계 속의 테스트
* **UserService를 분리하기 전의 테스트 대상의 의존구조**이다.
  ![image](https://github.com/syoh98/TIL/assets/76934280/717834af-ec39-450f-981a-ef6085046215)
  * UserServiceTest가 테스트하고자하는 대상인 UserService는 사용자 정보를 관리하는 비즈니스 로직의 구현코드로, UserService의 코드가 바르게 작성되어 있으면 성공하고, 아니라면 실패한다.
  * **따라서 테스트의 단위는 UserService 클래스여야 한다.**
  * UserService는 UserDao, TransactionManager, MailSender 세 가지 의존관계를 갖고 있다. 따라서 테스트가 진행되는 동안에 같이 실행되는데, 가장 큰 문제는 **세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라는 점**이다!
  * UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 객체와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.
### 💡 테스트 대상 오브젝트 고립시키기
결과적으로 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.   
* 테스트를 위해 UserServiceImpl를 고립시키자.
  ![image](https://github.com/syoh98/TIL/assets/76934280/93549c94-98c4-4d9c-a88d-12653e7bda91)
### 💡 단위 테스트와 통합 테스트
단위 테스트의 단위는 정하기 나름이다.   
해당 책에서는 **테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것**을 `단위 테스트`라 정의한다.
반면에 **두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트**는 `통합 테스트`라 정의한다.
### 💡 목 프레임워크
번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.   
그 중에서도 `Mockito 프레임워크`가 사용하기 편리하고, 코드도 직관적이라 인기가 많다.   
* Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 점이다. 간단한 메서드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
  * ex) `UserDao mockUserDao = mock(UserDao.class);`
</br>

## 🌱 6.3 다이내믹 프록시와 팩토리 빈
### 💡 프록시와 프록시 패턴, 데코레이터 패턴
* 데코레이터 패턴
* 프록시 패턴
