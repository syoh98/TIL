## 🌱 6.1 트랜잭션 코드의 분리
트랜잭션 경계설정을 위한 코드를 넣음으로써 비즈니스 로직이 주인어야 할 메서드 안에 트랜잭션 코드가 차지하게 되었다.   
### 💡 메서드 분리
하지만, 논리적으로 트랜잭션의 경계는 분명히 **비즈니스 로직의 전후**에 설정되어야 한다.   
이러한 로직 안에서 깔끔한 코드를 만드는 방법은 `비즈니스 로직을 담당하는 코드를 메서드로 추출해서 독립`시키는 것이다~   
해당 방법이 가능한 이유는
* 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
   * 비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없다.
* 따라서 이 두 메서드는 성격이 다르기 때문에 메서드를 분리할 수 있는 것이다.
### 💡 DI를 이용한 클래스의 분리
비즈니스 로직을 담당하는 코드를 분리해서 깔끔한 코드를 만들어냈지만, 여전히 트랜잭션을 담당하는 코드가 UserService 안에 있다.   
따라서 트랜잭션 코드를 DI 적용을 통해 클래스 밖으로 뽑아내자.   
* 현재 UserService는 UserServiceTest가 클라이언트가 되어 `강한 결합`이 맺어져있다.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/f558a55f-275b-4e99-98d0-c6daa86737bc" width="400"/></br>
* `강한 결합`이 `약한 결합`을 가질 수 있도록 인터페이스를 이용하자.(직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능하다.)   
  <img src="https://github.com/syoh98/TIL/assets/76934280/d0f7dfe2-5a7e-4953-917d-a3c2c0dbe23b" width="400"/></br>
* 또한, 트랜잭션 경계설정을 위해 UserServiceTx를 도입하자.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/d823a767-0f11-4e08-b93d-dfa2fb4b86ba" width="480"/></br>
  ➡️ 위임을 통한 작업을 통해 클라이언트 입장에서 볼때는 결국 **트랜잭션이 적용된 비즈니스 로직의 구현**이라는 기대하는 동작이 일어날 것이다.
* 스프링 DI 설정에 의해 만들어진 빈 오브젝트와 의존관계는 이러하다!   
  <img src="https://github.com/syoh98/TIL/assets/76934280/0ba19488-d083-4c09-be7b-601cc42c5b72" width="480"/></br>
* 트랜잭션을 분리했으니 테스트 코드도 마찬가지로 수정해야 한다.   
* **🤔 트랜잭션 경계설정 코드의 분리와 DI를 통한 연결은 복잡하고 큰 개선 작업이다. 이런 과정으로 얻을 수 있는 장점은 무엇일까??**
  1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. (+트랜잭션 적용이 필요한지 신경 쓰지 않아도 된다.)
  2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.
</br>

## 🌱 6.2 고립된 단위 테스트
가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.   
**작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.**   
하지만 작은 단위로 테스트하고 싶어도 그럴 수 없는 경우가 많은데, 이 경우 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.
### 💡 복잡한 의존관계 속의 테스트
* **UserService를 분리하기 전의 테스트 대상의 의존구조**이다.   
  ![image](https://github.com/syoh98/TIL/assets/76934280/717834af-ec39-450f-981a-ef6085046215)
  * UserServiceTest가 테스트하고자하는 대상인 UserService는 사용자 정보를 관리하는 비즈니스 로직의 구현코드로, UserService의 코드가 바르게 작성되어 있으면 성공하고, 아니라면 실패한다.
  * **따라서 테스트의 단위는 UserService 클래스여야 한다.**
  * UserService는 UserDao, TransactionManager, MailSender 세 가지 의존관계를 갖고 있다. 따라서 테스트가 진행되는 동안에 같이 실행되는데, 가장 큰 문제는 **세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라는 점**이다!
  * UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 객체와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.
### 💡 테스트 대상 오브젝트 고립시키기
결과적으로 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.   
* 테스트를 위해 UserServiceImpl를 고립시키자.
  ![image](https://github.com/syoh98/TIL/assets/76934280/93549c94-98c4-4d9c-a88d-12653e7bda91)
### 💡 단위 테스트와 통합 테스트
단위 테스트의 단위는 정하기 나름이다.   
해당 책에서는 **테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것**을 `단위 테스트`라 정의한다.
반면에 **두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트**는 `통합 테스트`라 정의한다.
### 💡 목 프레임워크
번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.   
그 중에서도 `Mockito 프레임워크`가 사용하기 편리하고, 코드도 직관적이라 인기가 많다.   
* Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 점이다. 간단한 메서드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
  * ex) `UserDao mockUserDao = mock(UserDao.class);`
</br>

## 🌱 6.3 다이내믹 프록시와 팩토리 빈
### 💡 프록시와 프록시 패턴, 데코레이터 패턴   
![image](https://github.com/syoh98/TIL/assets/76934280/cddcef36-958b-41e6-9699-d2b8bf0a535e)
* **🔶프록시**: 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인
* **🔶타깃**: 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
  * 프록시의 특징
    * 타깃과 같은 인터페이스를 구현했다는 것
    * 프록시가 타깃을 제어할 수 있는 위치에 있다는 것
  * 🤔프록시의 사용목적
    * 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
    * 타깃에 부가적인 기능을 부여해주기 위해서
    * ➡️ 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만, 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.
* **🔶데코레이터 패턴**: 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
  * ➡️ **다이내믹하게 기능을 부가한다는 의미: 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다**
  * 데코레이터 패턴은 프록시가 꼭 **한 개로 제한되지 않는다**, 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다. 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
  * **✏️ 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.**
  * 데코레이터 패턴의 예
    * 자바 IO 패키지의 InputStream과 OutputStream 구현클래스 (`InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));`)
* **🔶프록시 패턴**
  * 용어 정의
    * 일반적으로 사용하는 프록시: 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭
    * 디자인 패턴에서 말하는 프록시 패턴: 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
  * 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. **(=기능 자체에는 관여하지 않는다)**. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
  * 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
  * 프록시 패턴의 예
    * 특별한 상황에서 타깃에 대한 접근권한을 제어하는 경우(수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제)
### 💡 다이내믹 프록시
* **프록시의 문제점(프록시를 만들기 번거로운 이유)**
  * 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다는 점
    * 부가기능이 필요 없는 메서드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
  * 부가기능 코드가 중복될 가능성이 많다는 점   
➡️**이런 문제를 해결하기 위해 JDK의 다이내믹 프록시를 사용한다.**
* **리플렉션**
  * 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
  * 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
* **다이내믹 프록시 적용**
  * 다이내믹 프록시란? 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
  * 다이내믹 프록시의 동작방식   
    <img src="https://github.com/syoh98/TIL/assets/76934280/2b13e931-f1ee-461e-b41e-ef595c9d9510" width="800"/></br>
    * 다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다. 부가기능은 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 담는다.
    * `public Object invoke(Object proxy, Method method, Object[] args)`
### 💡 다이내믹 프록시를 이용한 트랜잭션 부가기능
### 💡 다이내믹 프록시를 위한 팩토리 빈
### 💡 프록시 팩토리 빈 방식의 장점과 한계
</br>

## 🌱 6.4 스프링의 프록시 팩토리 빈
### 💡 ProxyFactoryBean
### 💡 ProxyFactoryBean 적용
</br>

## 🌱 6.5 스프링 AOP
### 💡 자동 프록시 생성
### 💡 DefaultAdvisorAutoProxyCreator의 적용
### 💡 포인트컷 표현식을 이용한 포인트컷
### 💡 AOP란 무엇인가?
### 💡 AOP 적용기술
### 💡 AOP의 용어
### 💡 AOP 네임스페이스
</br>

## 🌱 6.6 트랜잭션 속성
## 🌱 6.7 애노테이션 트랜잭션 속성과 포인트컷
## 🌱 6.8 트랜잭션 지원 테스트
## 🌱 6.9 정리
