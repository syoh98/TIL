## 🌱 6.1 트랜잭션 코드의 분리
트랜잭션 경계설정을 위한 코드를 넣음으로써 비즈니스 로직이 주인어야 할 메서드 안에 트랜잭션 코드가 차지하게 되었다.   
### 💡 메서드 분리
하지만, 논리적으로 트랜잭션의 경계는 분명히 **비즈니스 로직의 전후**에 설정되어야 한다.   
이러한 로직 안에서 깔끔한 코드를 만드는 방법은 `비즈니스 로직을 담당하는 코드를 메서드로 추출해서 독립`시키는 것이다~   
해당 방법이 가능한 이유는
* 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
   * 비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없다.
* 따라서 이 두 메서드는 성격이 다르기 때문에 메서드를 분리할 수 있는 것이다.
### 💡 DI를 이용한 클래스의 분리
비즈니스 로직을 담당하는 코드를 분리해서 깔끔한 코드를 만들어냈지만, 여전히 트랜잭션을 담당하는 코드가 UserService 안에 있다.   
따라서 트랜잭션 코드를 DI 적용을 통해 클래스 밖으로 뽑아내자.   
* 현재 UserService는 UserServiceTest가 클라이언트가 되어 `강한 결합`이 맺어져있다.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/f558a55f-275b-4e99-98d0-c6daa86737bc" width="400"/></br>
* `강한 결합`이 `약한 결합`을 가질 수 있도록 인터페이스를 이용하자.(직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능하다.)   
  <img src="https://github.com/syoh98/TIL/assets/76934280/d0f7dfe2-5a7e-4953-917d-a3c2c0dbe23b" width="400"/></br>
* 또한, 트랜잭션 경계설정을 위해 UserServiceTx를 도입하자.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/d823a767-0f11-4e08-b93d-dfa2fb4b86ba" width="480"/></br>
  ➡️ 위임을 통한 작업을 통해 클라이언트 입장에서 볼때는 결국 **트랜잭션이 적용된 비즈니스 로직의 구현**이라는 기대하는 동작이 일어날 것이다.
* 스프링 DI 설정에 의해 만들어진 빈 오브젝트와 의존관계는 이러하다!   
  <img src="https://github.com/syoh98/TIL/assets/76934280/0ba19488-d083-4c09-be7b-601cc42c5b72" width="480"/></br>
* 트랜잭션을 분리했으니 테스트 코드도 마찬가지로 수정해야 한다.   
* **🤔 트랜잭션 경계설정 코드의 분리와 DI를 통한 연결은 복잡하고 큰 개선 작업이다. 이런 과정으로 얻을 수 있는 장점은 무엇일까??**
  1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. (+트랜잭션 적용이 필요한지 신경 쓰지 않아도 된다.)
  2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.
</br>

## 🌱 6.2 고립된 단위 테스트
가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.   
**작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.**   
하지만 작은 단위로 테스트하고 싶어도 그럴 수 없는 경우가 많은데, 이 경우 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.
### 💡 복잡한 의존관계 속의 테스트
* **UserService를 분리하기 전의 테스트 대상의 의존구조**이다.   
  ![image](https://github.com/syoh98/TIL/assets/76934280/717834af-ec39-450f-981a-ef6085046215)
  * UserServiceTest가 테스트하고자하는 대상인 UserService는 사용자 정보를 관리하는 비즈니스 로직의 구현코드로, UserService의 코드가 바르게 작성되어 있으면 성공하고, 아니라면 실패한다.
  * **따라서 테스트의 단위는 UserService 클래스여야 한다.**
  * UserService는 UserDao, TransactionManager, MailSender 세 가지 의존관계를 갖고 있다. 따라서 테스트가 진행되는 동안에 같이 실행되는데, 가장 큰 문제는 **세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라는 점**이다!
  * UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 객체와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.
### 💡 테스트 대상 오브젝트 고립시키기
결과적으로 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.   
* 테스트를 위해 UserServiceImpl를 고립시키자.
  ![image](https://github.com/syoh98/TIL/assets/76934280/93549c94-98c4-4d9c-a88d-12653e7bda91)
### 💡 단위 테스트와 통합 테스트
단위 테스트의 단위는 정하기 나름이다.   
해당 책에서는 **테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것**을 `단위 테스트`라 정의한다.
반면에 **두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트**는 `통합 테스트`라 정의한다.
### 💡 목 프레임워크
번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.   
그 중에서도 `Mockito 프레임워크`가 사용하기 편리하고, 코드도 직관적이라 인기가 많다.   
* Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 점이다. 간단한 메서드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.
  * ex) `UserDao mockUserDao = mock(UserDao.class);`
</br>

## 🌱 6.3 다이내믹 프록시와 팩토리 빈
### 💡 프록시와 프록시 패턴, 데코레이터 패턴   
![image](https://github.com/syoh98/TIL/assets/76934280/cddcef36-958b-41e6-9699-d2b8bf0a535e)
* **🔶프록시**: 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인
* **🔶타깃**: 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
  * 프록시의 특징
    * 타깃과 같은 인터페이스를 구현했다는 것
    * 프록시가 타깃을 제어할 수 있는 위치에 있다는 것
  * 🤔프록시의 사용목적
    * 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
    * 타깃에 부가적인 기능을 부여해주기 위해서
    * ➡️ 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만, 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.
* **🔶데코레이터 패턴**: 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
  * ➡️ **다이내믹하게 기능을 부가한다는 의미: 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다**
  * 데코레이터 패턴은 프록시가 꼭 **한 개로 제한되지 않는다**, 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다. 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
  * **✏️ 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.**
  * 데코레이터 패턴의 예
    * 자바 IO 패키지의 InputStream과 OutputStream 구현클래스 (`InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));`)
* **🔶프록시 패턴**
  * 용어 정의
    * 일반적으로 사용하는 프록시: 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭
    * 디자인 패턴에서 말하는 프록시 패턴: 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
  * 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. **(=기능 자체에는 관여하지 않는다)**. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
  * 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
  * 프록시 패턴의 예
    * 특별한 상황에서 타깃에 대한 접근권한을 제어하는 경우(수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제)
### 💡 다이내믹 프록시
* **프록시의 문제점(프록시를 만들기 번거로운 이유)**
  * 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다는 점
    * 부가기능이 필요 없는 메서드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
  * 부가기능 코드가 중복될 가능성이 많다는 점   
➡️**이런 문제를 해결하기 위해 JDK의 다이내믹 프록시를 사용한다.**
* **리플렉션**
  * 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
  * 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
* **다이내믹 프록시 적용**
  * 다이내믹 프록시란? 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
  * 다이내믹 프록시의 동작방식   
    <img src="https://github.com/syoh98/TIL/assets/76934280/2b13e931-f1ee-461e-b41e-ef595c9d9510" width="800"/></br>
    * 다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다. 부가기능은 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 담는다.
    * `public Object invoke(Object proxy, Method method, Object[] args)`
### 💡 다이내믹 프록시를 이용한 트랜잭션 부가기능
### 💡 다이내믹 프록시를 위한 팩토리 빈
DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없다는 점이 문제다!   
다이내믹 프록시는 Proxy 클래스의 `newProxyInstance()`라는 스태틱 팩토리 메서드를 통해서만 만들 수 있다.
* 팩토리 빈: 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.
  * 팩토리를 만드는 방법 중 가장 간단한 방법은 스프링의 FactoryBean 인터페이스를 구현하는 것   
    ![image](https://github.com/syoh98/TIL/assets/76934280/726c8931-2015-476a-a037-e3552f71089e)
    * `getObject()`: 빈 오브젝트를 생성해서 돌려준다.
    * `getObjectType()`: 생성되는 오브젝트의 타입을 알려준다.
    * `isSingleton()`: getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
  * 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 시용해 오브젝트를 만들어주지만, 위험하기 때문에 주의하자.
* 다이내믹 프록시를 만들어주는 팩토리 빈
  * Proxy의 `newProxyInstance()` 메서드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다.
    * 대신, **팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수가 있다.**
    * 팩토리 빈의 `getObject()` 메서드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때문이다.
### 💡 프록시 팩토리 빈 방식의 장점과 한계
* **프록시 팩토리 빈의 재사용**
  * TransactionHandler를 이용하는 다이내믹 프록시를 생성해주는 TxProxyFactoryBean은 코드의 수정 없이도 다양한 클래스에 적용할 수 있다. 타깃 오브젝트에 맞는 프로퍼티 정보를 설정해서 빈으로 등록해주기만 하면 된다.
  * 하나 이상의 TxProxtFactoryBean을 동시에 빈으로 등록해도 상관없다. 팩토리 빈이기 때문에 각 빈의 타입은 타깃 인터페이스와 일치한다.
  * 프록시 팩토리 빈을 이용하면 프록시 기법을 아주 빠르고 효과적으로 적용할 수 없다. 코드 한 줄 만들지 않고 기존 코드에 부가적인 기능을 추가해줄 수 있다는 것은 정말 매력적인 방법이다!
* **프록시 팩토리 빈 방식의 장점**
  * 앞서 데코레이터 패턴이 적용된 프록시를 사용하면 많은 장점이 있지만 적극적으로 활용되지 못하는 데는 두 가지의 문제가 있었다.
    1. 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 한다는 점.
    2. 부가적인 기능이 여러 메서드에 반복적으로 나타나게 돼서 코드 중복의 문제가 발생한다는 점.   
    ➡️ **프록시 팩토리 빈은 이 두가지 문제를 해결해준다**
* **프록시 팩토리 빈의 한계**
중복없는 최적화된 코드와 설정만을 이용해 이런 기능을 적용하려고 한다면 한계에 부딪힌다.
  1. 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 지금까지 본 방법으로는 불가능하다.
  2. 하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때 XML 설정이 늘어나게 되고 사람이 손으로 편집할 수 없는 한계를 벗어나게 된다.
  3. TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다.
</br>

## 🌱 6.4 스프링의 프록시 팩토리 빈
### 💡 ProxyFactoryBean
* 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.
* 스프링의 `FactoryBean`은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
* `FactoryBean`은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈의 둘 수 있다.
* `FactoryBean`이 생성하는 프록시에서 사용할 부가기능은 `MethodInterceptor` 인터페이스를 구현해서 만든다.
  * `MethodInterceptor`는 `InvocationHandler`와 비슷하지만 한 가지 다르다.
    * **`InvocatioinHandler`의 invoke() 메서드는 타깃 오브젝트에 대한 정보를 제공하지 않는다.** 따라서 타깃은 InvocationHandler를 구현한 클래스가 직접 알고 있어야 한다.
    * **`MethodInterceptor`의 invoke() 메서드는 ProxtFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다.** 따라서 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있고, 타깃이 다른 여러 프록시에서 함께 사용할 수 있으며 싱글톤 빈으로 등록 가능하다.
* 🔶 **어드바이스: 타깃이 필요 없는 순수한 부가기능**
  * 다이내믹 프록시를 사용했을 때와 반대로 ProxyFactoryBean에는 타깃 오브젝트가 등장하지 않는다. MethodInterceptor로는 메서드 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다.
  * **MethodInvocation은 일종의 콜백 오브젝트로, `proceed()` 메서드를 실행하면 타깃 오브젝트의 메서드를 내부적으로 실행해주는 기능이 있다.**
  * ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수 있다.   
    **➡️ 이는 프록시 팩토리 빈의 단점 중 하나였던, 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈도 추가해줘야 한다는 문제를 해결할 수 있다.**
  * ProxyFactoryBean은 기본적으로 JDK가 제공하는 다이내믹 프록시를 만들어준다.
* 🔶 **포인트컷: 부가기능 적용 대상 메서드 선정 방법**   
  <img src="https://github.com/syoh98/TIL/assets/76934280/2156d1d2-4537-427f-8957-19801662bc5b" width="700"/></br>
  * 어드바이스: 부가기능을 제공하는 오브젝트
  * 포인트컷: 메서드 선정 알고리즘을 담은 오브젝트   
  어드바이스와 포인트컷 모두 프록시에 DI로 주입돼서 사용된다.
  포인트컷은 직접 만들수도 있지만, 스프링이 제공하는 다양한 Pointcut 구현 클래스가 있으므로 이를 사용하면 편리하다.   
  * **어드바이저 = 포인트컷(메서드 선정 알고리즘) + 어드바이스(부가기능)**
### 💡 ProxyFactoryBean 적용
* 어드바이스와 포인트컷의 재사용
  * ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다. 그 덕분에 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.
</br>

## 🌱 6.5 스프링 AOP
### 💡 자동 프록시 생성
* **중복 문제의 접근 방법**   
  지금까지 다뤄봤던 반복적이고 기계적인 코드에 대한 해결책을 생각해보자   
  1. JDBC API를 사용하는 DAO 코드가 있었고, 메서드마다 JDBC try/catch/finally 블록으로 구성된 비슷한 코드가 반복해서 나타났다.
  2. 코드에서 `바뀌는 부분`/`바뀌지 않는 부분`을 구분해서 분리하고, 템플릿과 콜백, 클라이언트로 나누는 방법을 통해 깔끔하게 해결했다. **(전략패턴과 DI를 적용한 덕분이다.)**
  3. 이와는 다른 방법으로 반복되는 코드의 문제를 해결했는데, 바로 반복적인 위임 코드가 필요한 `프록시 클래스 코드`다.
  4. 타깃 오브젝트로의 위임 코드와 부가기능 적용을 위한 코드가 프록시가 구현해야 하는 모든 인터페이스 메서드마다 반복적으로 필요했다.
  5. 이는 단순한 분리와 DI와는 다른 방법, JDK의 `다이내믹 프록시`라는 런타임 코드 자동생성 기법을 이용했다.
  6. JDK의 `다이내믹 프록시`는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 런타임 시 내부적으로 만들어준다. 그 덕분에 개발자가 일일이 인터페이스 메서드를 구현하는 프록시 클래스를 만들어서 **위임과 부가기능의 코드를 중복해서 넣어주지 않아도 되게 해줬다.**
  7. `변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단`이라는 부분은 **코드 생성 기법을 이용하는 다이내믹 프록시 기술**에 맡기고, `변하는 부가기능 코드`는 별도로 만들어서 **다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법**을 사용한 것이다.
* **빈 후처리기를 이용한 자동 프록시 생성기**
  * `DefaultAdvisorAutoProxyCreator`: 어드바이저를 이용한 자동 프록시 생성
  * 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.
  * **빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수 있고 별도의 초기화 작업을 수행할 수도 있다. 심지어 만들어진 빈오브젝트 자체를 바꿔치기할 수도 있다.**
* **확장된 포인트컷**   
  ![image](https://github.com/syoh98/TIL/assets/76934280/0b5e5296-31e0-4531-9665-db61f12b37eb)    
  포인트컷은 두 가지 기능을 갖고 있다.
  * `getClassFilter()`: 프록시를 적용할 클래스인지 확인해준다.
  * `getMethodMatcher()`: 어드바이스를 적용할 메서드인지 확인해준다.
### 💡 포인트컷 표현식을 이용한 포인트컷
* 스프링은 간단하고 효과적인 방법으로 포인트컷의 클래스와 메서드를 선정하는 알고리즘을 작성하는 방법을 제공하는데, 이것을 포인트컷 표현식이라한다.      
  <img src="https://github.com/syoh98/TIL/assets/76934280/7f387352-0079-4a70-b3b9-d162839d855f" width="700"/></br>
* **포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 `타입 패턴`임을 알아두자.**
### 💡 AOP란 무엇인가?
트랜잭션 서비스 추상화 -> 프록시와 데코레이터 패턴 -> 다이내믹 프록시와 프록시 팩토리 빈 -> 자동 프록시 생성 방법과 포인트컷 -> 부가기능의 모듈화
* AOP: 애스펙트 지향 프로그래밍
  * 애스팩트: 그 자체로 **애플리케이션의 핵심기능을 담고 있지는 않지만**, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈이다.
  * AOP: 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍 또는 약자로 AOP라고 부른다.
  * **AOP는 OOP를 돕는 보조적인 기술이지 OOP를 완전히 대체하는 새로운 개념은 아니다.**
  * AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이라고 보면 된다.  
### 💡 AOP 적용기술
* **프록시를 이용한 AOP**
  * 스프링은 IoC/DO 컨테이너, 다이내믹 프록시, 데코레이터 패턴, 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술을 조합해 AOP를 지원하고 있는데, 핵심은 **프록시**를 이용했다는 것이다.
  * 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다.
* **바이트코드 생성과 조작을 통한 AOP**
  * 프록시 방식이 아닌 AOP도 존재한다. -> `AspectJ`
  * **`AspectJ`는 프록시 같은 방법이 있음에도 왜 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용할까?**
    1. 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문에
    2. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문에
       * 프록시를 AOP의 핵심 메커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메서드로 제한된다.
       * 하지만 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 추기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.
### 💡 AOP의 용어
* **타깃**
  * 부가기능을 부여할 대상
* **어드바이스**
  * 타깃에게 제공할 부가기능을 담은 모듈
  * 여러 종류가 있다(메서드 호출 과정에 전반적으로 참여, 예외가 발생했을 때만 동작하는 어드바이스처럼 메서드 호출 과정의 일부에서만 동작) 
* **조인 포인트**
  * 어드바이스가 적용될 수 있는 위치
* **포인트컷**
  * 어드바이스를 적용할 조인포인트를 선별하는 작업 또는 그 기능을 정의한 모듈 
* **프록시**
  * 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트
  * DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메서드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여한다.
* **어드바이저**
  * 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트
* **애스펙트**
  * AOP의 기본 모듈
### 💡 AOP 네임스페이스
자동 프록시 생성기, 어드바이스, 포인트컷, 어드바이저 -> 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
</br>

## 🌱 6.6 트랜잭션 속성
### 💡 트랜잭션 정의
TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.   
* **🔶 트랜잭션 전파**: 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식
  * `PROPAGATION_REQUIRED`: 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다.
  * `PROPAGATION_REQUIRES_NEW`: 항상 새로운 트랜잭션을 시작한다.
  * `PEOPAGATION_NOT_SUPPORTED`: 진행 중인 트랜잭션이 있어도 무시한다.
* **🔶 격리수준**
  * DefaultTransactionDefinition에 설정된 격리수준은 ISOLATION_DEFAULT다.
* **🔶 제한시간**
  * DefaultTransactionDefinition의 기본 설정을 제한시간이 없는 것이다.
* **🔶 읽기전용**
  * 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아 줄 수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.
### 💡 트랜잭션 인터셉터와 트랜잭션 속성
스프링이 제공하는 TransactionInterceptor는 기본적으로 두 가지 종류의 예외처리 방식이 있다.
* 런타임 예외가 발생하면 트랜잭션은 롤백된다.
* 반면에 타깃 메서드가 런타임 예외가 아닌 체크 예외를 던지는 경우에는 이것을 예외상황으로 해석하지 않고 일종의 비즈니스 로직에 따른, 의미가 있는 리턴 방식의 한 가지로 인식해서 트랜잭션을 커밋해버린다.   
➡️ 그런데 이러한 예외처리 기본 원칙을 따르지 않는 경우가 있을 수 있다. 그래서 transactionAttribute는 `rollbackOn()`이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해준다.
✏️ Properties 타입의 **transactionAttributes 프로퍼티**는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.
### 💡 포인트컷과 트랜잭션 속성의 적용 전략
1. 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
2. 공통된 메서드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
3. 프록시 방식은 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다.
</br>
   
## 🌱 6.7 애노테이션 트랜잭션 속성과 포인트컷
## 🌱 6.8 트랜잭션 지원 테스트
## 🌱 6.9 정리
