## 🌱7.1 SQL과 DAO의 분리
SQL을 DAO에서 분리해보자.
### 💡 XML 설정을 이용한 분리
* **개별 SQL 프로퍼티 방식**
  * 설정파일에 넣은 SQL 문장
  ```
  <bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
    <property name="dataSource" ref="dataSource"/>
    <property name="sqlAdd" value="insert into users(id, name, password, email, level, login, recommend) values(?, ?, ?, ?, ?, ?, ?)"/>
    ...
  ```
  * 메서드에서 SQL 문장을 제거하고 외부로부터 DI 받은 sqlAdd를 사용하게 만든다.
  * 이런방식으로 변경하면 코드 수정없이 XML 설정을 바꾸는 것만으로도 자유롭게 수정이 가능하다
  * 하지만, 이 방법은 조금 불편하다. 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메서드를 만들어줘야 하기 때문이다.
* **SQL 맵 프로퍼티 방식**
  * SQL을 하나의 컬렉션으로 담아두는 방법을 시도하자. 맵을 이용하면 프로퍼티는 하나만 만들어도 되기 때문에 DAO의 코드는 더 간결해진다.
  * 설정파일에 넣은 SQL 문장
    ```
    <bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
      <property name="dataSource" ref="dataSource"/>
      <property name="sqlMap">
        <map>
          <entry key="add" value="insert into users(id, name, password, email, level, login, recommend) values(?, ?, ?, ?, ?, ?, ?)" />
          <entry key="get" value="select * from users where id = ?" />
          ...
        </map>
       </property>
    </bean>
    ```
### 💡 SQL 제공 서비스
위 코드에서는 몇 가지 문제점이 존재한다.
1. SQL과 DI 설정정보가 섞여 있으면 보기에도 지저분하고 관리하기에도 좋지 않다.
2. SQL을 꼭 스프링의 빈 설정 방법을 사용해 XML에 담아둘 이유도 없다.
3. 스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어렵다.(운영 중인 애플리케이션에서 빈번하게 참조되는 맵 내용을 수정할 경우 동시성 문제를 일으킬 수도 있다.)
* **SQL 서비스 인터페이스**
  * DAO가 적절한 키를 제공해주고 그에 대한 SQL을 돌려받기만 하면 되도록 만들어주자.
  * sqlService를 사용하도록 수정한 메서드
    ```
    public void add(User user) {
      this.jdbcTemplate.update(this.sqlService.getSql("userAdd"),
           user.getId(), user.getName() ... );
    }
    // ...
    ```
* **스프링 설정을 사용하는 단순 SQL 서비스**
  * 맵을 이용한 SqlService의 구현
    ```
    public class SimpleService implments SqlService {
      private Map<String, String> sqlMap; // 설정파일에 <map>으로 정의된 SQL 정보를 가져오도록 프로퍼티로 등록해둔다.

      public void SqlMap(Map<String, String> sqlMap) {
        this.sqlMap = sqlMap;
      }
    }
    ```
  * 이제 UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경쓰지 않아도 된다.
  * 동시에 sqlService 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있다.
</br>

## 🌱7.2 인터페이스의 분리와 자기참조 빈
### 💡 XML 파일 매핑
* **JAXB(Java Architecture for XML Binding)**: XML에 담긴 정보를 파일에서 읽어오는 방법
  * DOM과 같은 전통적이 XML API와 비교했을 때 JAXB의 장점은 XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해준다는 것이다.
    * DOM은 XML 정보를 자바의 리플렉션 API를 사용해서 오브젝트를 조작하는 것처럼 간접적으로 접근해야 하는 불편이 있다.
    * 그에 비해 JAXB는 XML의 정보를 그대로 담고 있는 오브젝트 트리 구조로 만들어주기 때문에 XML 정보를 오브젝트처럼 다를 수 있어 편리하다.
* **언마샬링**
  * 언마샬링(unmarshalling): XML 문서를 읽어서 자바의 오브젝트로 변환하는 것
  * 마샬링(marshalling): 바인딩 오브젝트를 XML 문서로 변환하는 것
  * 자바오브젝트를 바이트 스트림으로 바꾸는 걸 직렬화라고 부르는 것과 비슷하다.
### 💡 XML 파일을 이용하는 SQL 서비스
* XML SQL 서비스
  * 언제 JAXB를 사용해 XML 문서를 가져올지 생각해봐야 한다. DAO가 SQL을 요청할 때마다 매번 XML 파일을 다시 읽어서 SQL을 찾는 건 너무 비효율적인 방법이다.
  * 특별한 이유가 없는 한 XML 파일은 한 번만 읽도록 해야 한다. XML 파일로부터 읽은 내용은 어딘가에 저장해두고 DAO에서 요청이 올 때 사용해야 한다.
  * 일단은 간단히 생성자에서 SQL을 읽어와 내부에 저장해두는 초기 작업을 해보자
    * 생성자 초기화 방법을 사용하는 XmlSqlService 클래스
    ```java
    public class XmlSqlService implments SqlService {
        private Map<String, String> sqlMap = new HashMap<String, String>(); // 읽어온 SQL을 저장해둘 맵

        // 스프링이 오브젝트를 만드는 시점에서 SQL을 읽어오도록 생성자를 이용한다.
        public XmlSqlService() { // JAXB API를 이용해 XML 문서를 오브젝트 트리로 읽어온다.
            String contextPath = Sqlmap.class.getPackage().getName();
            try {
                JAXBContext context = JAXBContext.newInstance(contextPath);
                Unmarshaller unmarshaller = context.createUnmarshaller();
                InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml"); // UserDao와 같은 클래스패스의 sqlmap.xml 파일을 변환한다.
                Sqlmap sqlmap = (Sqlmap)unmarshaller.unmarshal(is);

                // 읽어온 SQL을 맵으로 저장해둔다.
                for(SqlType sql:sqlmap.getSql()) {
                    sqlMap.put(sql.getKey(), sql.getValue());
                }
            } catch(JAXBException e) {
                throw new RuntimeException(e);
            }
        }
    }
    ```   
    **➡️ SQL 문장을 스프링의 빈 설정에서 완벽하게 분리했다. DAO 로직이나 파라미터가 바뀌지 않는 한 SQL 내용을 변경하더라도 애플리케이션의 코드나 DI 설정은 전혀 수정할 필요가 없어졌다.**
### 💡 빈의 초기화 작업
위 코드에서 몇 가지 개선했으면 하는 점이 보인다.
1. 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않다.
2. 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점
* **따라서 생성자 대신 초기화 메서드를 사용하자**
* ➡️ 그런데 이 초기화 메서드는 언제 실행돼야하고, 어떻게 실행시키지?
  * `@PostConstruct`: java.lang.annotation 패키지에 포함된 공통 어노테이션의 한 가지. 빈 오브젝트의 초기화 메서드를 지정하는 데 사용한다.**생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 매우 유용하다.**
### 💡 변화를 위한 준비: 인터페이스 분리
현재 `XmlSqlService`는 특정 포맷의 XML에서 SQL 데이터를 가져오고, 이를 HashMap 타입의 맵 오브젝트에 저장해둔다.   
**SQL을 가져오는 방법에 있어서는 특정 기술에 고정되어 있다.**
* XML 대신 다른 포맷의 파일에서 SQL을 읽어오게 한다면?
* 가져온 SQL 정보를 HashMap 타입 컬렉션이 아닌 다른 방식으로 저장해두고 검색해서 데이터를 가져오려면?
➡️ **코드를 고쳐야 한다. 서로 관심이 다른 코드들을 분리하고, 서로 코드에 영향을 주지 않으면서 유연하게 확장 가능하도록 DI를 적용해보자.**
* **책임에 따른 인터페이스 정의**   
  가장 먼저 할 일은 분리 가능한 관심사를 구분하는 것. 독입적으로 변경 가능한 두 가지 책임을 뽑아보자.
  1. SQL 정보를 외부의 리소스로부터 읽어오는 것
  2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것
  * SqlService 서비스 오브젝트의 구조를 변경하자.   
    <img src="https://github.com/syoh98/TIL/assets/76934280/a3beaf30-7e88-45ea-b4c7-784738b7920a" width="600"/></br>
  * 인터페이스 정의 전 생각해볼 사항은 SQLReader가 읽어오는 SQL 정보는 다시 SqlRegistry에 전달해서 등록되게 해야한다는 것이다.
  * SqlService가 일단 SqlReader에게서 정보를 전달받은 뒤, SqlRegistry에 다시 전달해줘야 할 필요는 없다.
  * SqlReader에게 SqlRegistry 전략을 제공해주면서 이를 이용해 SQL 정보를 SqlRegistry에 저장하라고 요청하는 편이 낫다.
    * ➡️ `sqlReader.readSql(sqlRegistry); // SQL을 저장할 대상인 sqlRegistry 오브젝트를 전달한다.`   
    <img src="https://github.com/syoh98/TIL/assets/76934280/22d5352e-9c98-425f-a209-55a1bcc50305" width="400"/></br>
</br>

## 🌱7.3 서비스 추상화 적용
JaxbXmlReader를 좀 더 개선하고 발전시켜보자
* 자바에는 JAXB 외에도 다양한 XML과 자바오브젝트를 매핑하는 기술이 있다. 필요에 따라 다른 기술로 손쉰게 바꿔서 사용할 수 있게 해야 한다.
* XML 파일을 좀 더 다양한 소스에서 가져올 수 있게 만든다. 현재는 UserDao 클래스와 같은 클래스 패스 안에서만 XML을 읽어올 수 있다. 이것을 `임의의 클래스패스`나 `파일 시스템 상의 절대위치` 또는 `HTTP 프로토콜`을 통해 원격에서 가져오도록 확장할 수는 없는가?
### 💡 OXM 서비스 추상화
* **OXM(Object-XML Mapping)**: XML과 자바오브젝트를 매핑해서 상호 변환해주는 기술
  * Caster XML
  * JiBX
  * XmlBeans
  * Xstream
  * ➡️ JAXB를 포함하여 5가지 기술 모두 사용목적이 동일하다. **즉 서비스를 추상화 할 수 있다.**
  * ➡️ 스프링은 OXM에 대해서도 서비스 추상화 기능을 제공한다. **스프링의 제공을 통해 변환을 처리하게 되면 코드 수정 없이 OXM 기술을 자유롭게 바꿔 적용할 수 있다!**
 * **OXM 서비스 인터페이스**   
   ![image](https://github.com/syoh98/TIL/assets/76934280/e6c6baaa-120a-465e-9364-b5f047b2d53c)
  * XML 파일에 대한 정보를 담은 Source 타입의 오브젝트를 주면, 설정에서 지정한 OXM 기술을 이용해 자바오브젝트 트리로 환하고, 루트 오브젝트를 돌려준다.
### 💡 OXM 서비스 추상화 적용
SQL을 읽는 방법을 OXM으로 제한해서 사용성을 극대화해보자.
* **멤버 클래스를 참조하는 통합 클래스**   
  <img src="https://github.com/syoh98/TIL/assets/76934280/603c244a-fdfc-4167-84ae-b1afa71b1f15" width="600"/></br>
  * OxmSqlReader는 private 멤버 클래스이므로 외부에서 접근하거나 사용할 수 없다. 또한 OxmSqlService는 이를 final로 선언하고 직접 오브젝트를 생성하기 때문에 OxmSqlReader를 DI 하거나 변경할 수 없다.
  * ➡️ 두 개의 클래스를 강하게 결합하고 더 이상의 확장이나 변경을 제한해두는 이유는 무엇일까?
  * ➡️ **OXM을 이용하는 서비스 구조로 최적화하기 위해서.** 하나의 클래스로 만들어두기 때문에 빈의 등록과 설정은 단순해지고 쉽게 사용할 수 있다.   
  <img src="https://github.com/syoh98/TIL/assets/76934280/7bda5915-a239-4d61-91d4-2c3135b431dd" width="700"/></br>
  * ➡️ 하나의 빈 설정으로 두 개의 오브젝트를 설정하는 구조
### 💡 리소스 추상화
지금까지 만든 OxmSqlReader나 XmlSqlReader에는 공통적인 문제점이 있다.   
SQL 매핑 정보가 담긴 XML 파일 이름을 프로퍼티로 외부에서 지정할 수는 있지만, UserDao 클래스와 같은 클래스패스에 존재하는 파일로 제한된다는 점이다.   
예를 들어
* 클래스패스 루트 등에 있는 XML 파일을 읽으려면 어떻게 해야할까?
* 상대적인 클래스패스가 아니라 서버나 개발 시스템의 특정 폴더에 있는 파일을 읽을 수는 없을까?
* 서블릿 컨텍스트의 상대적인 폴더나 http, ftp 프로토콜로 접근할 수 있는 웹상의 리소스 파일을 가져올 수는 없을까?
* ➡️ **안타깝게도 자바에는 이렇게 다양한 위치에 존재하는 리소스에 대해 단일화된 접근 인터페이스를 제공해주는 클래스가 없다.**
* **리소스**
  * 스프링은 자바에 존재하는 일관성 없는 리소스 접근 API를 추상화해서 `Resource`라는 추상화 인터페이스를 정의했다.
  * 애플리케이션 컨텍스트가 사용할 설정정보 파일을 지정하는 것부터 시작해서 스프링의 거의 모든 API는 외부의 리소스 정보가 필요할 때는 항상 이 `Resource` 추상화를 이용한다.
  * 🤔 그렇다면 어떻게 임의의 리소스를 Resource 인터페이스 타입의 오브젝트로 가져올 수 있을까? 리소스를 사용하려면 매번 빈으로 등록해야 할까?
  * ➡️ 물론 아니다. 다른 서비스의 추상화 오브젝트와는 달리, `Resource`**는 스프링에서 빈이 아니라 값으로 취급된다.**
  * 그래서 추상화를 적용하는 방법이 문제다.
* **리소스 로더**
  * 그래서 스프링에는 URL 클래스와 유사하게 접두어를 이용해 Resource 오브젝트를 선언하는 방법이 있다.
  * 문자열 안에 `리소스의 종류`와 `리소스의 위치`를 함께 표현하게 해주는 것이다.
  * 그리고 이렇게 문자열로 정의된 리소스를 실제 Resource 타입 오브젝트로 변환해주는 `ResourceLoader`를 제공한다.
  * **ResourceLoader의 대표적인 예는 스프링의 애플리케이션 컨텍스트다.**
  * Resource를 사용할 때는 Resource 오브젝트가 실제 리소스는 아니라는 점을 주의해야한다. Resource는 단지 리소스에 접근할 수 있는 추상화된 핸들러일 뿐이다. 따라서 Resource 타입의 오브젝트가 만들어졌다고 해도 실제로 리소스가 존재하지 않을 수 있다.
  * **이렇게 스프링의 리소스 추상화를 이용하면 리소스의 위치와 접근 방법에 독립적인 코드를 쉽게 만들 수 있다.**
  * 스프링 애플리케이션에서 파일을 읽거나 참조하는 기능을 만들 때는 Resource 타입의 추상화 기능을 사용하자.
</br>

## 🌱7.4 인터페이스 상속을 통한 안전한 기능확장
때로는 서버가 운영 중인 상태에서 서버를 재시작하지 않고 긴급하게 애플리케이션이 사용 중인 SQL을 변경해야 할 수도 있다.   
그럼 애플리케이션을 새로 시작하지 않고 특정 SQL의 내용만을 변경하고 싶다면 어떻게 해야할까?   
### 💡 DI와 기능의 확장
* **DI를 의식하는 설계**
  * DI는 런타임 시에 의존 오브젝트를 다이내믹하게 연결해줘서 유연한 확장을 꾀하는 게 목적이기 때문에 항상 확장을 염두에 두고 오브젝트 사이의 관계를 생각해야 한다.
  * 이렇게 DI를 잘 활용할 수 있는 방법을 생각하면서 오브젝트를 설계한다면 객체지향 기술이 약속하는 유연한 확장과 재사용이 가능한 설계를 만드는 데 많은 도움이 될 것이다.
* **DI와 인터페이스 프로그래밍**
  * DI를 적용할 때는 가능한 한 인터페이스를 사용하게 해야한다.
  * 인터페이스를 사용하는 이유는?
    1. `다형성`을 얻기 위함이다.
    2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 해줄 수 있기 때문이다.
    * 오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있고, 이를 객체지향 설계 원칙에서는 `인터페이스 분리 원칙`이라고 부른다.
### 💡 인터페이스 상속
* 인터페이스 분리 원칙이 주는 장점은 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지할 수 있다는 점이다. 그래서 기존 클라이언트에 영향을 주지 않은 채로 오브젝트의 기능을 확장하거나 수정할 수 있다.
* 인터페이스를 사용해 DI 관계를 만들었기 때문에 얻을 수 있는 또 다른 장점은 SqlRegistry의 구현 클래스인 MySqlRegistry의 오브젝트가 또 다른 제 3의 클라이언트를 위한 인터페이스를 가질 수 있다는 점이다.
* 인터페이스를 추가하거나 상속을 통해 확장하는 방식을 잘 활용하면 이미 기존의 인터페이스를 사용하는 클라이언트가 있는 경우에도 유연한 확장이 가능해진다.
* **잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려있다.**
* 인터페이스를 적절하게 분리하고 확장하는 방법을 통해 오브젝트 사이의 의존관계를 명확하게 해주고, 기존 의존관계에 영향을 주지 않으면서 유연한 확장성을 얻는 방법이 무엇인지 항상 고민해야한다!
</br>

## 🌱7.5 DI를 이용해 다양한 구현 방법 적용하기
운영 중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업을 만들 때 가장 먼저 고려해야 할 사항은 `동시성 문제`다.   
동시 접속자가 많은 대형 시스템의 DAO라면 수시로 접근하는 SQL 레지스트리 정보를 잘못 수정하다가 어느 순간 깨진 SQL이 나타날 수도 있다.   
자바에서 제공되는 주요 기술을 이용해 간단한 방식으로 어느 정도 안전한 업데이트가 가능한 SQL 레지스트리를 구현해보자.
### 💡 ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
멀티스레드 환경에서 안전하게 HashMap을 조작하려면 `Collections.synchronizedMap()` 등을 이용해 외부에서 동기화해줘야한다.     
하지만 이렇게 HashMap에 대한 전 작업을 동기화하면 SqlService처럼 DAO의 요청이 많은 고성능 서비스에서는 성능에 문제가 생긴다.   
그래서 동기화된 해시 데이터 조작에 최적화되도록 만들어진 `ConcurrentHashMap`을 사용하는 방법이 일반적으로 권장된다.   
`ConcurrentHashMap`은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다. 그래서 어느 정도 안전하면서성능이 보장되는 동기화된 HashMap으로 이용하기에 적당하다.
### 💡 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
ConcurrentHashMap이 멀티스레드 환경에서 최소한의 동시성을 보장해주고 성능도 그리 나쁜 편은 아니지만, **저장되는 데이터의 양이 많아지고 잦은 조회와 변경이 일어나는 환경이라면 한계가 있다.**   
이런 경우, DB의 장점과 특징은 그대로 갖고 있으면서도 애플리케이션 외부에 별도로 설치하고 셋업하는 번거로움은 없는 `내장형 DB`를 사용하는 것이 적당하다.   
`내장형 DB`는 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는 DB를 말한다. 데이터는 메모리에 저장되기 때문에 IO로 인해 발생하는 부하가 적어서 성능이 뛰어나다.   
데이터를 내장형 DB의 테이블에 분산해서 넣은 후 SQL 문을 이용해 검색하고 조작하는 편이 훨씬 코드도 깔끔하고 활용하기도 편리하다. 복잡한 데이터를 효과적으로 분석하고 조작하는 데는 관계형 DB와 SQL만 한 것이 없다.   
* **스프링의 내장형 DB 지원 기능**
  * 자바에서 많이 사용되는 내장형 데이터베이스는 `Derby`, `HSQL`, `H2`를 꼽을 수가 있다.
  * JDBC의 방식의 접근이라고 해서 기존의 DataSource와 DAO를 사용하는 모델을 그대로 사용하는 건 좋은 방법은 아니다.
  * 애플리케이션 내에서 DB를 기동시키고 초기화 SQL 스크립트 등을 실행시키는 등의 `초기화 작업`이 별도로 필요하기 때문이다.
  * 대신 스프링은 내장형 DB를 **초기화하는 작업을 지원**하는 편리한 `내장형 DB 빌더`를 제공한다.
  * 내장형 DB 인스턴스는 보통 고유한 JDBC 접속 URL을 통해 연결을 시도하면 JDBC 드라이버 내에서 이를 생성해준다.
* **내장형 DB 빌더 학습 테스트**
  * 내장형 DB는 애플리케이션을 통해 DB가 시작될 때마다 매번 테이블을 새롭게 생성한다. 따라서 지속적으로 사용 가능한 테이블 생성 SQL 스크립트를 준비해둬야 한다.
  * 내장형 DB 빌더는 DB 엔진을 생성하고 초기화 스크립트를 실행해서 테이블과 초기 데이터를 준비한 뒤에 DB에 접근할 수 있는 Connection을 생성해주는 `DataSource 오브젝트`를 돌려주게 된다. 정확히는 DB 셧다운 기능을 가진 `EmbeddedDatabase 타입 오브젝트`다.
  * ```
    new EmbeddedDatabaseBuilder()
        .setType(내장형 DB 종류)
        .addScript(초기화에 사용할 DB 스크립트의 리소스)
        ...
        .build(); // 주어진 조건에 맞는 내장형 DB를 준비하고 초기화 스크립트를 모두 실행한 뒤에 이에 접근할 수 있는 EmbeddedDatabse를 돌려준다.
    ```
  * **내장형 DB를 이용한 SqlRegistry 만들기**
    * `EmbeddedDatabaseBuilder`는 직접 빈으로 등록한다고 바로 사용할 수 있는 게 아니다.
    * 적절한 메서드를 호출해주는 **초기화 코드**가 필요하다. 초기화 코드가 필요하다면 팩토리 빈으로 만드는 것이 좋다.
    * 스프링에는 팩토리 빈을 만드는 번거로운 작업을 대신해주는 전용 태그가 있다. 내장형 DB와 관련된 빈을 설정하고 등록해주는 기능이 있는 태그들은 jdbc 스키마에 정의되어 있다.
</br>

## 🌱7.6 스프링 3.1의 DI
* 자바 언어의 변화와 스프링
  * 애노테이션의 메타정보 활용
    * 어노테이션은 옵션에 따라 컴파일된 클래스에 존재하거나 애플리케이션이 동작할 때 메모리에 로딩되기도 하지만 자바 코드가 실행되는 데 직접 참여하지 못한다. 그럼에도 어노테이션을 이용하는 표준 기술과 프레임워크는 빠르게 증가했다.
    * **🤔어노테이션의 활용이 늘어난 이유는 무엇일까?** 어노테이션은 애플리케이션의 핵심 로직을 담은 자바 코드와 이를 지원하는 IoC 방식의 프레임워크, 프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울리기 때문일 것이다.
    * 앞서 DaoFactory와 같은 자바코드를 XML을 적용했을 때, AOP를 위해 빈 생성과 관계 설정을 재구성하는 경우를 고려하면 자바 코드보다 유리했기 때문에 스프링 초창기부터 XML이 프레임워크가 사용하는 오브젝트 `관계 설정용 DI 메타정보`로 적극 활용돼왔다.
    * **그런데 어노테이션이 등장하면서 상황이 달라졌다.** 어노테이션은 XML이나 여타 외부 파일과 달리 자바 코드의 일부로 사용된다. 코드의 동작에 직접 영향을 주지는 못하지만 메타정보로서 활용되는 데는 XML에 비해 유리한 점이 많다.
    * **[XML vs annotation]**
      * **정보표현**: 어노테이션은 정의하기에 따라 타입, 필드, 메서드, 파라미터, 생성자, 로컬 변수의 한군데 이상 적용이 가능하며 어노테이션을 참고하는 코드에서 다양한 부가정보를 얻어낼 수 있다. 반면 동일한 정보를 XML로 표현하려면 모든 내용을 명시적으로 나타내야한다. 어노테이션 하나를 자바 코드에 넣는 것에 비해 작성할 정보의 양이 많고, 텍스트 정보이기 때문에 오타가 발생하기 쉽다.
      * **리팩토링**: 패키지 변경 또는 클래스 이름 변경 시 XML은 정보가 단순 텍스트로 작성되어 있어 리팩토링을 할 때 번거롭고 안전하지 못하다.
      * **하지만 어노테이션도 단점이 존재한다.** XML은 어느 환경에서나 손쉽게 편집이 가능하고, 내용을 변경하더라도 다시 빌드를 거칠 필요가 없다. 반면 어노테이션은 **자바 코드에 존재하므로** 변경할 때마다 매번 클래스를 새로 컴파일 해줘야 한다.
  * 정책과 관례를 이용한 프로그래밍
### 💡 자바 코드를 이용한 빈 설정
  * 테스트 컨텍스트의 변경
  * <context:annotation-config /> 제거
  * <bean>의 전환
  * 전용 태그 전환
</br>

## 🌱7.7 정리
