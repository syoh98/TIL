## 🌱 5.1 사용자 레벨 관리 기능 추가
* 인터넷 서비스 사용자 관리 기능을 구현해보자.
* 사용자 관리의 기본 로직은 정해진 조건에 따라 사용자의 레벨을 주기적으로 변경한다는 간단한 내용이다.
### 💡 필드 추가
* LEVEL enum
  * User 클래스에 사용자의 레벨을 저장할 필드를 추가하자.
  * ```java
    class User {
        private static final int BASIC = 1;
        private static final int SILVER = 2;
        private static final int GOLD = 3;
    
        int level;
    
        public void setLevel(int level) {
            this.level = level;
        }
    }
    ```
  * ➡️ 깔끔하게 코드를 작성할 수 있지만, `setLevel(1000)`처럼 범위를 벗어나는 값을 넣을 위험이 존재한다.
  * ➡️ 따라서 숫자 타입을 직접 사용하는 것보다는 자바 5 이상에서 제공하는 `enum`을 이용하는 게 안전하고 편리하다.
  * ```java
    class enum Level {
        BASIC(1), SILVER(2), GOLD(3); // 세 개의 enum 객체 정의
    
        private final int value;
    
        Level(int value) { // DB에 저장할 값을 넣어줄 생성자를 만들어둔다.
            this.value = value;
        }
    
        public int intValue() { // 값을 가져오는 메서드 
            return value;
        }
    }
    ```
* User 필드 추가
  * 위에서 만든 Level 타입의 변수를 User 클래스에 추가하자.
* UserDaoTest 테스트 수정
  * UserDaoJdbc와 테스트에도 필드를 추가해주자.
  * UserDaoTest에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교하는 checkSameUser() 메서드를 수정한다.
    ```java
    private void checkSameUser(User user1, User user2) {
        assertThat(user1.getId(), is(user2.getId()));
        assertThat(user1.getName(), is(user2.getName()));
        assertThat(user1.getPassword(), is(user2.getPassword()));
        assertThat(user1.getLevel(), user2.getLevel());
        assertThat(user1.getLogin(), user2.getLogin());
        assertThat(user1.getRecommed(), user2.getRecommed());
    }
    ```
    * ➡️ 앞으로 추가되거나 변경돼도 User 오브젝트를 비교하는 로직을 일정하게 유지할 수 있도록 checkSameUser()를 이용하자.
* UserDaoJdbc 수정
  * userMapper에 추가된 필드를 넣어주자.
### 💡 사용자 기능 추가
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다.   
기본키인 id를 제외한 나머지 필드는 수정될 가능성이 있다.
* 수정 기능 테스트 추가, 수정 테스트 보완
  ```java
  @Test
  private void update) {
      dao.deleteAll();
      dao.add(User1);

      // 픽스처에 들어 있는 정보를 변경해서 수정 메서드를 호출한다.
      user1.setName("오소영");
      user1.setPassword("springbom");
      // ....

      User user1update = dao.get(user1.getId());
     checkSameUser(user1, user1update);
  }
  ```
  * JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 **SQL 문장**이다.
  * 위와 같이 UPDATE 문장에서 WHERE절을 빼먹는 경우, 아무런 경고 없이 정상적으로 동작하는 것처럼 보이기 때문에 이 문제를 해결해야한다.
  * 해결방법
    1. JDBCTemplate의 `update()`가 돌려주는 리턴 값을 확인하는 것
    2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것
    * 2번의 방법으로 해결한 테스트 코드
        ```java
        @Test
        private void update) {
            dao.deleteAll();
        
            dao.add(User1); // 수정할 사용자
            dao.add(User2); // 수정하지 않을 사용자
      
            user1.setName("오소영");
            user1.setPassword("springbom");
            // ....

            dao.update(user1);
      
            User user1update = dao.get(user1.getId());
            checkSameUser(user1, user1update)

            User user2same = dao.get(user2.getId());
            checkSameUser(user2, user2same);
        }
        ```
### 💡 UserService.upgradeLevels()
![image](https://github.com/syoh98/TIL/assets/76934280/c4a703f0-b7a9-4db8-a690-de5eea11949b)
* 레벨 관리 기능을 구현하기 위한 사용자 관리 비즈니스 로직을 담을 클래스를 추가하자.
* UserService가 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 DI를 적용하자.
* 테스트 클래스도 추가하자.
### 💡 코드 개선
* 작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.
  * 코드에 중복된 부분은 없는가?
  * 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
  * 코드가 자신이 있어야 할 자리에 있는가?
  * 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
* upgradeLevels() 메서드 코드의 문제점
* upgradeLevels() 리팩토링
</br>

## 🌱 5.2 트랜잭션 서비스 추상화
### 💡 모 아니면 도
### 💡 트랜잭션 경계 설정
### 💡 트랜잭션 동기화
### 💡 트랜잭션 서비스 추상화
</br>

## 🌱 5.3 서비스 추상화와 단일 책임 원칙
* 수직, 수평 계층구조와 의존관계
* 단일 책임 원칙
* 단일 책임 원칙의 장점
</br>

## 🌱 5.4 메일 서비스 추상화
### 💡 JavaMail을 이용한 메일 발송 기능
### 💡 JavaMail이 포함된 코드의 테스트
### 💡 테스트를 위한 서비스 추상화
### 💡 테스트 대역
</br>

## 🌱 5.5 정리
