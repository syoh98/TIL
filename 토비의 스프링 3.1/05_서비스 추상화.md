## 🌱 5.1 사용자 레벨 관리 기능 추가
* 인터넷 서비스 사용자 관리 기능을 구현해보자.
* 사용자 관리의 기본 로직은 정해진 조건에 따라 사용자의 레벨을 주기적으로 변경한다는 간단한 내용이다.
### 💡 필드 추가
* LEVEL enum
  * User 클래스에 사용자의 레벨을 저장할 필드를 추가하자.
  * ```java
    class User {
        private static final int BASIC = 1;
        private static final int SILVER = 2;
        private static final int GOLD = 3;
    
        int level;
    
        public void setLevel(int level) {
            this.level = level;
        }
    }
    ```
  * ➡️ 깔끔하게 코드를 작성할 수 있지만, `setLevel(1000)`처럼 범위를 벗어나는 값을 넣을 위험이 존재한다.
  * ➡️ 따라서 숫자 타입을 직접 사용하는 것보다는 자바 5 이상에서 제공하는 `enum`을 이용하는 게 안전하고 편리하다.
  * ```java
    class enum Level {
        BASIC(1), SILVER(2), GOLD(3); // 세 개의 enum 객체 정의
    
        private final int value;
    
        Level(int value) { // DB에 저장할 값을 넣어줄 생성자를 만들어둔다.
            this.value = value;
        }
    
        public int intValue() { // 값을 가져오는 메서드 
            return value;
        }
    }
    ```
* User 필드 추가
  * 위에서 만든 Level 타입의 변수를 User 클래스에 추가하자.
* UserDaoTest 테스트 수정
  * UserDaoJdbc와 테스트에도 필드를 추가해주자.
  * UserDaoTest에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교하는 checkSameUser() 메서드를 수정한다.
    ```java
    private void checkSameUser(User user1, User user2) {
        assertThat(user1.getId(), is(user2.getId()));
        assertThat(user1.getName(), is(user2.getName()));
        assertThat(user1.getPassword(), is(user2.getPassword()));
        assertThat(user1.getLevel(), user2.getLevel());
        assertThat(user1.getLogin(), user2.getLogin());
        assertThat(user1.getRecommed(), user2.getRecommed());
    }
    ```
    * ➡️ 앞으로 추가되거나 변경돼도 User 오브젝트를 비교하는 로직을 일정하게 유지할 수 있도록 checkSameUser()를 이용하자.
* UserDaoJdbc 수정
  * userMapper에 추가된 필드를 넣어주자.
### 💡 사용자 기능 추가
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다.   
기본키인 id를 제외한 나머지 필드는 수정될 가능성이 있다.
* 수정 기능 테스트 추가, 수정 테스트 보완
  ```java
  @Test
  private void update) {
      dao.deleteAll();
      dao.add(User1);

      // 픽스처에 들어 있는 정보를 변경해서 수정 메서드를 호출한다.
      user1.setName("오소영");
      user1.setPassword("springbom");
      // ....

      User user1update = dao.get(user1.getId());
     checkSameUser(user1, user1update);
  }
  ```
  * JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 **SQL 문장**이다.
  * 위와 같이 UPDATE 문장에서 WHERE절을 빼먹는 경우, 아무런 경고 없이 정상적으로 동작하는 것처럼 보이기 때문에 이 문제를 해결해야한다.
  * 해결방법
    1. JDBCTemplate의 `update()`가 돌려주는 리턴 값을 확인하는 것
    2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것
    * 2번의 방법으로 해결한 테스트 코드
        ```java
        @Test
        private void update) {
            dao.deleteAll();
        
            dao.add(User1); // 수정할 사용자
            dao.add(User2); // 수정하지 않을 사용자
      
            user1.setName("오소영");
            user1.setPassword("springbom");
            // ....

            dao.update(user1);
      
            User user1update = dao.get(user1.getId());
            checkSameUser(user1, user1update)

            User user2same = dao.get(user2.getId());
            checkSameUser(user2, user2same);
        }
        ```
### 💡 UserService.upgradeLevels()
![image](https://github.com/syoh98/TIL/assets/76934280/c4a703f0-b7a9-4db8-a690-de5eea11949b)
* 레벨 관리 기능을 구현하기 위한 사용자 관리 비즈니스 로직을 담을 클래스를 추가하자.
* UserService가 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 DI를 적용하자.
* 테스트 클래스도 추가하자.
### 💡 코드 개선
* 작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.
  * 코드에 중복된 부분은 없는가?
  * 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
  * 코드가 자신이 있어야 할 자리에 있는가?
  * 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
* upgradeLevels() 메서드 코드의 문제점
  * 레벨의 변화 단계와 업그레이드 조건, 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있어서 로직을 이해하기 쉽지 않다.
  * 성격이 다른 두 가지 경우가 모두 한 곳에서 처리되는 것은 이상하다.
* upgradeLevels() 리팩토링
  * 레벨 업그레이드 작업 메서드
    ```java
    private void upgradeLevel(User user) {
        if(user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
        else if(user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
        userDao.update(user);
    }
    ```
    * ➡️ 다음 단계가 무엇인가 라는 로직과 그 때 사용자 오브젝트의 level 필드를 변경해준다는 로직이 함께 있다.
    * ➡️ 예외상황에 대한 처리가 없다.
    * 레벨이 늘어나면 if문이 점점 길어질 것이고, 레벨 변경 시 사용자 오브젝트에서 level 필드 외의 값도 같이 변경해야 한다면 if 조건 뒤에 붙는 내용도 점점 길어질 것이다.
    * 더 분리해보자.
  * 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자.
    ```java
    public enum Level {
        GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER); // enum 선언에 DB에 저장할 값과 함께 다음 단계의 레벨 정보도 추가한다.
        private final int value;
        private final Level next; // 다음 단계의 레벨 정보를 스스로 갖고 있도록 Level 타입의 next 변수를 추가한다.
        // ...
    }
    ```
  * 사용자 정보가 바뀌는 부분을 UserService 메서드에서 User로 옮기자.
    * UserService가 일일이 레벨 업그레이드 시에 User의 어떤 필드를 수정한다는 로직을 갖고 있기보다는, User에게 레벨업그레이드를 해야 하니 정보를 변경하라고 요청하는 편이 낫다.
</br>

## 🌱 5.2 트랜잭션 서비스 추상화
"정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그 때까지 변경된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기 상탤 되돌려 놓아야 할까요?"
### 💡 모 아니면 도
* 테스트용 USerService 대역
  * 테스트를 위해 코드를 함부로 건드리는 것은 좋은 생각이 아니기 때문에 테스트용으로 특별히 만든 UserService의 대역을 사용하는 방법이 좋다.
  * UserService 기능의 일부를 오버라이딩해서 테스트를 진행해보자.
    ```java
    static class TestUserService extends UserService {
        private String id;

        private TestUserService(String id) {
            this.id = id;
        }

        protected void upgradeLevel(User user) { // UserService의 메서드를 오버라이드한다.
            if(user.getId().equals(this.id)) throw new TestUserServiceException(); // 지정된 id의 User 오브젝트가 발견되면 예외를 던져서 작업을 강제로 중단시킨다.
            super.upgradeLevel(user);
        }
    }
    ```
* 강제 예외 발생을 통한 테스트
  * 테스트의 목적은 사용자 레벨 업그레이드를 시도하다가 중간에 예외가 발생했을 경우, 그 전에 업그레이드했던 사용자도 다시 원래 상태로 돌아갔는지를 확인하는 것이다.
* 테스트 실패의 원인
  * 테스트 실패의 원인은 **트랜잭션** 문제이다. 모든 사용자의 레벨을 업그레이드 하는 작업인 `upgradeLevels()` 메서드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.
  * 트랜잭션이란 더 이상 나눌 수 업는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 `원자성`을 의미한다.
### 💡 트랜잭션 경계 설정
DB는 그 자체로 완벽한 트랜잭션을 지원하나, 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우 DB가 트랜잭션을 보장해주지 못할 수 있다.   
`트랜잭션 롤백`: 두번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우 앞에서 처리한 SQL 작업도 취소되어야 한다.   
`트랜잭션 커밋`: 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행작업이 모두 성공적으로 마무리 됐다고 DB에 알려줘서 작업을 확정시키는 것.   
* JDBC 트랜잭션의 트랜잭션 경계설정
  * `트랜잭션 경계`: 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치
  * `트랜잭션 경계설정`: 트랜잭션의 시작을 선언하고 트랜잭션을 종료하는 작업
  * `로컬 트랜잭션`: 하나의 DB 커넥션 안에서 만들어지는 트랜잭션
* UserService와 UserDao의 트랜잭션 문제
  * UserService와 UserDao의 트랜잭션 처리 과정   
    <img src="https://github.com/syoh98/TIL/assets/76934280/a03f371e-8c0a-4182-b2c1-dfcccfad689d" width="600"/></br>
    * 데이터 액세스 코드를 DAO로 만들어서 분리해놓았을 경우에는 DAO 메서드를 호출할 때마다 하나의 새로운 트랙잭션이 만들어지는 구조가 될 수 밖에 없다.
    * ➡️ 그렇다면 `upgradeLevels()`와 같이 여러 번 DB에 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면 어떻게 해야 할까?
* 비즈니스 로직 내의 트랜잭션 경계설정
 * UserService에서 만든 Connection 오브젝트를 UserDao에서 사용하려면 DAO 메서드를 호출할 때마다 Connection 오브젝트를 파라미터로 전달해줘야한다.
* UserService 트랜잭션 경계설정의 문제점
  * 위의 방법으로 UserDAO와 UserService를 수정하면 트랜잭션 문제는 해결할 수 있지만, 다른 문제가 발생한다.
    1. DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다.
    2. DAO의 메서드 비즈니스 로직을 담고 있는 UserService의 메서드에 Connection 파라미터가 추가돼야 한다.
    3. Connection 파라미터가 UserDao 인터페이스 메서드에 추가되면 UserDao는 더 이상 데이터 액세스 기술에 독립적일 수 없다.
### 💡 트랜잭션 동기화
트랜잭션 경계를 설정해 관리하려면 지금까지 만들었던 깔끔하게 정리된 코드를 포기해야 할까? 트랜잭션 기능을 포기해야 할까?
아래의 방법으로 둘 다 해결하자.
* Connection 파라미터 제거
  * `트랜잭션 동기화`: UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메서드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다.
* 트랜잭션 동기화 적용
  * `TransactionSynchronizationManager`: 스프링이 제공하는 트랜잭션 관리 클래스
### 💡 트랜잭션 서비스 추상화
* 기술과 환경에 종속되는 트랙잭션 경계설정 코드
  * 여러 개의 DB에 데이터를 넣는 작업을 해야할 필요가 발생했을 때, 한 개 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는 건 JDBC의 Connection을 이용한 트랜잭션 방식인 `로컬 트랜잭션`으로는 불가능하다.
  * ➡️ **`로컬 트랜잭션`은 하나의 DB connection에 종속되기 때문**이다.
  * ➡️ 따라서 각 DB와 독립적으로 만들어지는 Connection을 통해서가 아니라, 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 `글로벌 트랜잭션` 방식을 사용해야한다.
  * `JTA(Java Transaction API)`를 이용해 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는 `분산 트랜잭션` 또는 `글로벌 트랜잭션`이 가능해진다.
</br>

## 🌱 5.3 서비스 추상화와 단일 책임 원칙
* 수직, 수평 계층구조와 의존관계
* 단일 책임 원칙
* 단일 책임 원칙의 장점
</br>

## 🌱 5.4 메일 서비스 추상화
### 💡 JavaMail을 이용한 메일 발송 기능
### 💡 JavaMail이 포함된 코드의 테스트
### 💡 테스트를 위한 서비스 추상화
### 💡 테스트 대역
</br>

## 🌱 5.5 정리
