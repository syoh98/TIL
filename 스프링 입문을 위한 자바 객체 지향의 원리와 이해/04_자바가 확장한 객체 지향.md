**✏️ abstract 키워드 - 추상 메서드와 추상 클래스**
  * 추상메서드: 선언부는 있는데 구현부가 없는 메서드를 말함. 추상메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스(Abstract Class)로 선언해야함
    * 추상 클래스는 인스턴스, 즉 객체를 만들 수 없음(= new를 사용할 수 없음)
    * 추상 메서드는 하위 클래스에게 메서드의 구현을 강제함. 오버라이딩 강제
    * 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야함

**✏️ 생성자(=객체 생성자 메서드)**
  * 생성자는 클래스의 인스턴스, 즉 객체를 만들 때마다 new 키워드를 사용
  * 컴파일 과정에서 자바 컴파일러가 알아서 기본 생성자를 만들어줌   
  ➡️ 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기존 생성자를 만들어줌
  ➡️ 인자가 있는 생성자를 하나라도 만든다면 자바는 기존 생성자를 만들어 주지 않음

**✏️ 클래스 생성 시의 실행 블록, statc 블록**
  * 클래스 생성자는 존재하지 않지만 클래스가 스태틱 영역에 배치될 때 실행되는 코드블록이 있음 **(= static 블록)**
  * static 블록에서 사용할 수 있는 속성과 메서드는 static 멤버 뿐이다(클래스의 static 블록이 실행되고 있을 때는 해당 클래스의 객체는 하나도 존재하지 않기 때문)
  * 정리해보면,,
    * 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T메모리의 스태틱 영역에 로딩되며, 이 때 단 한번 해당 클래스의 static블록이 실행됨
  * 클래스가 제일 처음 사용될 때
    * 클래스의 정적 속성을 사용할 때
    * 클래스의 정적 메서드를 사용할 때
    * 클래스의 인스턴스를 최초로 만들 때   
 🤔 왜 프로그램이 실행 될 때 바로 클래스들의 정보를 T메모리의 static 영역에 로딩하지 않고 해당 클래스가 처음 사용될 때 로딩할까??   
    **static영역도 메모리 이기 때문.**

**✏️ final 키워드**
  * final 키워드가 나타날 수 있는 곳: 클래스, 변수, 메서드
  * 클래스에 final이 붙으면 상속불가의 의미, 변수에 final이 붙으면 변경 불가능한 상수의 의미, 메서드에 final이 붙으면 재정의, 즉 오버라이딩 금지

**✏️ instanceof 연산자**
  * 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자. 연산의 결과로 true 또는 false를 반납
  * 사용법: ``` 객체_참조_변수 instanceof 클래스 ```
    
**✏️ instanceof 연산자**
  * 객체가 자기 자신을 지칭할 때 쓰는 키워드
  * 지역변수와 객체변수의 이름이 동일한 경우 this를 사용하여 객체변수를 쓰고 싶을 때 사용
  * 기억할 내용
    * 지역변수와 속성(객체변수, 정적변수)의 이름이 같은 경우는 지역변수가 우선
    * 객체변수와 이름이 같은 지역변수가 있는 경우 객체변수를 사용하려면 this를 접두사로 사용
    * 정적변수와 이름이 같은 지역변수가 있는 경우 정적변수를 사용하려면 클래스명을 접두사로 사용
   
**✏️ super 연산자**
  * 바로 위 상위클래스의 인스턴스를 지칭하는 키워드
  * super.super 형태로 상위의 상위클래스의 인스턴스에는 접근 불가
