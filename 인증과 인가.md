## 📝 인증(Authentication)
식별 가능한 정보로 사용자의 신원을 확인하는 과정
* 예시
  * 은행에 가서 계좌에서 돈을 인출하는 경우, 직원이 사용자가 누구인지 확인하기 위해 신분증을 요구
  * 어떤 사이트의 회원일 경우 로그인을 함으로써 회원이 맞음을 인증, 인증절차가 성공할 경우에만 서비스 이용 가능

## 📝 인가(Authorization) 또는 권한 부여
인증된 사용자를 바탕으로 사용자가 어떤 리소스를 요청(request)했을 때, 요청을 기반으로 사용자가 해당 리소스에 권한이 있는지 체크하는 과정
* 예시(쇼핑몰)
  * 회원을 구매자와 판매자로 구분하여 구매자는 구매만 할 수 있고, 판매자는 판매만 할 수 있도록 권한을 부여
  * 모든 회원은 구매를 할 수 있으나, 판매자는 신청을 통해 통과된 사용자만 판매자 권한을 부여받을 수 있도록 설정
 
* 💡 **인증 → 인가는 이어지지만, 인가 → 인증으로 이어지지 않는다.**
  * 인증은 권한 부여 결정의 요소로 사용될 수 있다.
  * 권한 부여는 인증을 하기에는 유용하지 않을 수 있다.
 
## 📌 로그인과 인증/인가
💡 웹사이트는 HTTP 통신 위에서 동작하기 때문에 웹 사이트 내의 모든 요청과 응답은 stateless한 특성을 가진다(= **서버에서 client의 이전 상태를 기억하고 있지 않는다**)
➡️ 이러한 상황에서 웹사이트를 이용하려면 인증/인가가 필요한 모든 상황에서 사용자는 반복적으로 ID/PW를 입력해야하는 불상사가 일어난다!
➡️ stateless한 HTTP 위에서 인증과 인가를 구현하는 방법으로는 대표적으로 Session방식과 Token 방식이 존재한다

## 📌 로그인의 세션방식과 토큰 방식
먼저! 기존 로그인 과정을 살펴봤을 때는
<img src="https://github.com/syoh98/TIL/assets/76934280/f7c5f19c-244c-434b-99f0-d3ab187e8f07" width="700"/> 

1. 사용자가 id와 password를 입력한다.
2. 클라이언트로부터 받은 URL을 (http://user:1q2w3e!@www.naver.com) 브라우저가 `Base64` 방식으로 인코딩한 문자열을 요청 헤더의 `Authorization`을 통해 넣어서 보내준다(HTTP 전송)
3. 서버가 DB check를 한다. DB에 실제 값이 있다면(검증) `OK sign`을 전송한다.
 
### 1️⃣ Session 방식
<img src="https://github.com/syoh98/TIL/assets/76934280/b74958e8-706b-44ce-b7d6-4e916d61ba5c" width="700"/> 

4. 응답을 보내기 전, 인증된 사용자의 식별자와 랜덤한 문자열로 서버로 부터 SESSIONID를 부여 받는다.(Session Storage)
5. SESSIONID를 응답 Header로 넘겨준다.
6. 클라이언트가 해당 정보를 저장한다. (클라이언트의 요청 시 쿠키에 저장된 SESSIONID를 같이 전달하여 요청한다.)
     
### 2️⃣ Token 방식 - JWT
<img src="https://github.com/syoh98/TIL/assets/76934280/1cd4598c-af32-4c0c-b101-5052604e957f" width="700"/> 

4. 응답을 보내기 전, Secret key를 이용해 서버로부터 `Token`(JWT)을 발급 받는다.
5. `Token`을 응답 Header로 넘겨준다.
6. 클라이언트가 해당 정보를 저장한다. (서버에 요청을 할 때마다 해당 `Token`을 HTTP Request Header에 포함하여 서버에 전달한다.)   

참고
* https://auth0.com/intro-to-iam/authentication-vs-authorization
* https://velog.io/@dev-joon/%EC%9D%B8%EC%A6%9DAuthentication%EA%B3%BC-%EC%9D%B8%EA%B0%80Authorization
* https://www.youtube.com/watch?v=y0xMXlOAfss
