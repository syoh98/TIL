## 📝 인증(Authentication)
식별 가능한 정보로 사용자의 신원을 확인하는 과정
* 예시
  * 은행에 가서 계좌에서 돈을 인출하는 경우, 직원이 사용자가 누구인지 확인하기 위해 신분증을 요구
  * 어떤 사이트의 회원일 경우 로그인을 함으로써 회원이 맞음을 인증, 인증절차가 성공할 경우에만 서비스 이용 가능

## 📝 인가(Authorization) 또는 권한 부여
인증된 사용자를 바탕으로 사용자가 어떤 리소스를 요청(request)했을 때, 요청을 기반으로 사용자가 해당 리소스에 권한이 있는지 체크하는 과정
* 예시(쇼핑몰)
  * 회원을 구매자와 판매자로 구분하여 구매자는 구매만 할 수 있고, 판매자는 판매만 할 수 있도록 권한을 부여
  * 모든 회원은 구매를 할 수 있으나, 판매자는 신청을 통해 통과된 사용자만 판매자 권한을 부여받을 수 있도록 설정
 
* 💡 **인증 → 인가는 이어지지만, 인가 → 인증으로 이어지지 않는다.**
  * 인증은 권한 부여 결정의 요소로 사용될 수 있다.
  * 권한 부여는 인증을 하기에는 유용하지 않을 수 있다.
 
## 📌 로그인과 인증/인가
💡 웹사이트는 HTTP 통신 위에서 동작하기 때문에 웹 사이트 내의 모든 요청과 응답은 stateless한 특성을 가진다   
(= **서버에서 client의 이전 상태를 기억하고 있지 않는다**)   
➡️ 이러한 상황에서 웹사이트를 이용하려면 인증/인가가 필요한 모든 상황에서 사용자는 반복적으로 ID/PW를 입력해야하는 불상사가 일어난다!   
➡️ stateless한 HTTP 위에서 인증과 인가를 구현하는 방법으로는 대표적으로 Session방식과 Token 방식이 존재한다

## 📌 로그인의 세션방식과 토큰 방식
먼저! 기존 로그인 과정을 살펴봤을 때는   
<img src="https://github.com/syoh98/TIL/assets/76934280/f7c5f19c-244c-434b-99f0-d3ab187e8f07" width="700"/> 

1. 사용자가 id와 password를 입력한다.
2. 클라이언트로부터 받은 URL을 (http://user:1q2w3e!@www.naver.com) 브라우저가 `Base64` 방식으로 인코딩한 문자열을 요청 헤더의 `Authorization`을 통해 넣어서 보내준다(HTTP 전송)
3. 서버가 DB check를 한다. DB에 실제 값이 있다면(검증) `OK sign`을 전송한다.
 
### 1️⃣ Session 방식
<img src="https://github.com/syoh98/TIL/assets/76934280/b74958e8-706b-44ce-b7d6-4e916d61ba5c" width="700"/> 

4. 응답을 보내기 전, 인증된 사용자의 식별자와 랜덤한 문자열로 서버로 부터 SESSIONID를 부여 받는다.(Session Storage)
5. SESSIONID를 응답 Header로 넘겨준다.
6. 클라이언트가 해당 정보를 저장한다. (클라이언트의 요청 시 쿠키에 저장된 SESSIONID를 같이 전달하여 요청한다.)
     
### 2️⃣ Token 방식 - JWT
<img src="https://github.com/syoh98/TIL/assets/76934280/1cd4598c-af32-4c0c-b101-5052604e957f" width="700"/> 

4. 응답을 보내기 전, Secret key를 이용해 서버로부터 `Token`(JWT)을 발급 받는다.
5. `Token`을 응답 Header로 넘겨준다.
6. 클라이언트가 해당 정보를 저장한다. (서버에 요청을 할 때마다 해당 `Token`을 HTTP Request Header에 포함하여 서버에 전달한다.)   

</br>

## 💡 ‘상태’는 어떤 의미일까?
* Stateful(상태유지)
  * 클라이언트의 요청이 서버와 독립적으로 처리되지 않는다.   
    (=이전 요청이 다음 요청에 영향을 끼친다.)
* Stateless(무상태)
  * 클라이언트의 요청이 서버에서 독립적으로 처리된다.   
    (=이전 요청이 다음 요청에 영향을 미치지 않는다.)   
* ➡️ 결과적으로 클라이언트의 정보가 서버에서 관리되는가 아닌가를 판단하여 `Stateful`과 `Stateless`를 나눈다.
</br>

## 💡 왜 세션은 Stateful이고 토큰은 Stateless일까?
* 세션 방식   
  클라이언트가 요청을 보내면, 해당 서버가 클라이언트에게 `SESSIONID`를 부여한다.   
  유저 정보 즉, `SESSIONID`는 서버에서 관리한다.   
* ➡️ 서버가 유저 정보를 관리하고 있다. `Stateful`하다.
* 토큰 방식을 구현한 JWT
  * JWT: 웹에서 사용하는 JSON 형식으로 정보를 담고 있는 토큰
  * JWT의 구성
    * Header
      * 토큰이 어떠한 알고리즘으로 암호화 되어 있는지에 대한 정보
    * Payload
      * 토큰이 담고자 하는 정보
    * Signature
      * 유효한 토큰인지 확인할 수 있는 인증 정보
      * Header와 Payload는 단순이 JSON 문자열을 base64로 인코딩한 것에 불과하기 때문에, 해커가 토큰을 탈취하여 수정 후 서버로 보내는 등의 경우를 방지하기 위해 존재   
* ➡️ 이렇듯 **토큰이 서버가 필요한 유저에 대한 정보를 담고 있기 때문에** 즉, **서버가 본인이 필요한 유저 정보를 관리하고 있지 않으므로** 토큰방식은 `Stateless`한 것이다.
</br>

## 💡 토큰이라고 모두 Stateless한 것은 아니다
* Token 방식의 문제(JWT)   
해커가 토큰을 탈취할 경우, JWT의 토큰 만료시간을 짧게 설정하여 남용을 방지하는 조치를 취할 수 있지만 이는 **본래의 사용자 또한 사용할 수 없게 되는 부작용을 초래**한다.   
➡️ 이를 방지하기 위해 `Refresh Token`이 만들어졌다.   
**💡 문제는, 이 `Refresh Token`을 DB에서 관리한다는 점이다!**   
➡️ 이는 결국 Stateless 하지 않다는 것이다.
* 또한 토큰을 발급한다고 하더라고, 서버에서 유저의 화이트리스트/블랙리스트를 관리한다면 유저의 상태를 관리하게 되는 것이다. 세션과 다를게 없어진다.
</br>

참고   
* https://auth0.com/intro-to-iam/authentication-vs-authorization
* https://velog.io/@dev-joon/%EC%9D%B8%EC%A6%9DAuthentication%EA%B3%BC-%EC%9D%B8%EA%B0%80Authorization
* https://www.youtube.com/watch?v=y0xMXlOAfss
* https://80000coding.oopy.io/9a56cae9-8626-4025-b3f9-c02251980d0f
