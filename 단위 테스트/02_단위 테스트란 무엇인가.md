## ✅ 2.1 '단위 테스트'의 정의
* **격리 문제에 대한 런던파의 접근**
  * 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다. 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 한다.
  * ✏️ 목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다.
    * 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.
    * 목은 그러한 의존성의 한 종류일 뿐이다.
* **격리 문제에 대한 고전파의 접근**
  * 고전적인 방법에서 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다. 대신 단위 테스트는 서로 격리해서 실행해야 한다. 이렇게 하면 테스트를 어떤 순서로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않는다.
  * 각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻이다.
    * ✏️ 공유 의존성(shared dependency): 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다. 데이터베이스도 공유 의존성의 전형적인 예가 될 수 있다.
    * ✏️ 프로세스 외부 의존성(out-of-process dependency): 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시(proxy)이다.
      
## ✅ 2.2 단위 테스트의 런던파와 고전파
런던파와 고전파로 나눠진 원인은 격리 특성에 있다. 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다.</br>
* **고전파와 런던파가 의존성을 다루는 방법**
 * | |격리 주체|단위의 크기|테스트 대역 사용 대상|
   |------|---|---|---|
   |런던파|단위|단일 클래스|불변 의존성 외 모든 의존성|
   |고전파|단위 테스트|단일 클래스 또는 클래스 세트|공유 의존성|

## ✅ 2.3 고전파와 런던파의 비교
고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.</br>
* 런던파의 접근 방식은 다음과 같은 이점을 제공한다.
  * 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
  * 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성 시 걱정할 필요가 없다.
  * 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다. 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다. 물론 테스트 대상 시스템이 값 객체를 사용하는 상황이 있을 수 있으며, 이 값 객체의 변경으로 인해 테스트가 실패하게 된다. 그러나 테스트 내 다른 의존성을 모두 제거했기 때문에 이러한 경우는 흔하지 않다.
* **한 번에 한 클래스만 테스트하기**
  * 테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다.
  * 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다. 이보다 적은 것을 목표로 삼는다면 사실 단위 테스트를 훼손하는 결과를 가져온다. 이 테스트가 무엇을 검증하는지 정확히 이해하기가 더 어려워지기 때문이다.
* **상호 연결된 클래스의 큰 그래프를 단위 테스트하기**
  * 실제 협력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.
  * 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다. 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.
  * 목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.
* **버그 위치 정확히 찾아내기**
  * 런던 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 SUT에 버그가 포함된 테스트만 실패한다.
  * 하지만 고전적인 방식이면, 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다.
* **고전파와 런던파 사이의 다른 차이점**
  * 고전파와 런던파 사이에 남아있는 두 가지 차이점은 다음과 같다.
    * 테스트 주도 개발(TDD, Test-Driven Development)을 통한 시스템 설계 방식
    * 과도한 명세(over-specification) 문제
  * 런던 스타일의 단위 테스트는 하향식 TDD로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다.
  * 고전파는 테스트에서 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 두지 않는다. 대신 일반적으로 상향식으로 한다. 고전적 스타일에서는 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.
  * 그러나 고전파와 런던파 간의 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT의 구현 세부 사항에 결합되는 것이다.
    
## ✅ 2.4 두 분파의 통합 테스트
* **통합 테스트의 일부인 엔드 투 엔드 테스트**
  * 엔드 투 엔드 테스트는 통합 테스트의 일부다. 엔드 투 엔드 테스트도 코드가 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증한다.
  * 엔드 투 엔드 테스트와 통합 테스트 간의 차이점은 엔드 투 엔드 테스트가 일반적으로 의존성을 더 많이 포함한다는 것이다.
  * 엔드 투 엔드라는 명칭은 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다.
  * 엔드 투 엔드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다. 또한 개인 개발자 머신이 아닌 빌드 서버에서만 실행할 수도 있다.
    
## ✅ 요약
* 단위 테스트의 정의
  * 단일 동작 단위를 검증하고
  * 빠르게 수행하고
  * 다른 테스트와 별도로 처리한다.
* 격리 문제를 주로 논의하고 있는데, 이 논쟁으로 고전파와 런던파라는 두 개의 단위 테스트 분파로 나뉘었다.
  * 런던파는 테스트 대상 단위를 서로 분리해야 한다고 한다.
  * 고전파는 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다. 또한 테스트 대상 단위는 코드 단위가 아니라 동작 단위다.
* 런던파는 더 나은 입자성의 이점, 상호 연결된 클래스의 큰 그래프에 대한 테스트 용이성 그리고 테스트 실패 후 버그가 있는 기능을 쉽게 찾을 수 있는 편의성 등을 제공한다.
* 런던파의 장점이 처음에는 매력적으로 보이지만 몇 가지 문제가 있다. 테스트 대상 클래스에 대한 초점이 잘못됐다.
* 런던파 테스트의 가장 큰 문제는 과잉 명세, 즉 SUT 세부 구현에 결합된 테스트 문제다.
* 통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트다. 엔드 투 엔드 테스트는 통합 테스트의 일부다.
