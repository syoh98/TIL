## ✅ 6.1 단위 테스트의 세 가지 스타일
* **출력 기반 테스트 정의**
  * 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식이다. 이러한 단위 테스트 스타일은 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.
  * 출력 기반 단위 테스트 스타일은 함수형(functional)이라고도 한다.
  * 이 이름은 사이드 이펙트 없는 코드 선호를 강조하는 프로그래밍 방식인 함수형 프로그래밍에 뿌리를 두고 있다. 
* **상태 기반 스타일 정의**
  * 상태 기반 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것이다.
  * 이 테스트 스타일에서 상태라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.
* **통신 기반 스타일 정의**
  * 이 스타일은 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.
  * 통신 기반 테스트는 SUT의 협력자를 목으로 대체하고 SUT가 협력자를 올바르게 호출하는지 검증한다.
* 단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 이와 반대로 선택한다. 두 분파는 출력 기반 테스트를 사용한다. 

## ✅ 6.2 단위 테스트 스타일 비교
* **회귀 방지와 피드백 속도 지표로 스타일 비교하기**
  * 회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다. 회귀 방지 지표는 다음 세 가지 특성으로 결정된다.
    * 테스트 중에 실행되는 코드의 양
    * 코드 복잡도
    * 도메인 유의성
  * 테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다.
  * 목은 런타임에 지연 시간이 생기는 편이므로 통신 기반 테스트가 약간 나쁠 수 있다. 그러나 이러한 테스트가 수만 개 수준이 아니라면 별로 차이는 없다.
* **리팩터링 내성 지표로 스타일 비교하기**
  * 리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성(허위 경보) 수에 대한 척도다. 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다.
  * 출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.
  * 상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 확률적으로 말하면, 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커진다.
  * 통신 기반 테스트가 허위 경보에 가장 취약하다. 그러나 피상적인 테스트가 통신 기반 테스트의 결정적인 특징이 아닌 것처럼, 불안정성도 통신 기반 테스트의 결정적인 특징이 아니다. 캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.
* **유지 보수성 지표로 스타일 비교하기**
  * 유지 보수성은 단위 테스트의 유지비를 측정하며, 다음 두 가지 특성으로 정의한다.
    * 테스트를 이해하기 얼마나 어려운가(테스트 크기에 대한 함수)?
    * 테스트를 실행하기 얼마나 어려운가(테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)?
  * **출력 기반 테스트의 유지보수성**
    * 출력 기반 테스트는 거의 항상 짧고 간결하므로 유지 보수가 쉽다. 이러한 이점은 메서드로 입력을 공급하는 것과 해당 출력을 검증하는 두 가지로 요약할 수 있다는 사실에서 비롯된다.
    * 출력 기반 테스트의 기반 코드는 전역 상태나 내부 상태를 변경할 리 없으므로, 프로세스 외부 의존성을 다루지 않는다. 따라서 두 가지 유지 보수성 모두의 측면에서 출력 기반 테스트가 가장 좋다.
  * **상태 기반 테스트의 유지보수성**
    * 상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다. 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지하기 때문이다.
  * **통신 기반 테스트의 유지보수성**
    * 통신 기반 테스트에는 테스트 대역과 상호 작용 검증을 설정해야 하며, 이는 공간을 많이 차지한다.
    * 목이 사슬 형태로 있을 때 테스트는 더 커지고 유지 보수하기가 어려워진다.
* **스타일 비교하기: 결론**
  * | |출력 기반|상태 기반|통신 기반|
    |------|---|---|---|
    |리팩터링 내성을 지키기 위해 필요한 노력|낮음|중간|중간|
    |유지비|낮음|중간|높음|

## ✅ 6.3 함수형 아키텍처 이해
* **함수형 프로그래밍이란?**
  * 함수형 프로그래밍은 수학적 함수(mathematical function)를 사용한 프로그래밍이다. 수학적 함수는 숨은 입출력이 없는 함수(또는 메서드)다.
  * 출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다. 이는 유지보수성이 뛰어나고 거짓 양성 빈도가 낮다.
  * 반면에 숨은 입출력은 코드를 테스트하기 힘들게 한다. 숨은 입출력의 유형은 다음과 같다.
    * 사이드 이펙트
    * 예외
    * 내외부 상태에 대한 참조
* **함수형 아키텍처란?**
  * 함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것이다.
  * 다음 두 가지 코드 유형을 구분해서 비즈니스 로직과 사이드 이펙트를 분리할 수 있다.
    * 결정을 내리는 코드
    * 해당 결정에 따라 작용하는 코드
* **함수형 아키텍처와 육각형 아키텍처 비교**
  * 함수형 아키텍처와 육각형 아키텍처는 둘 다 관심사 분리라는 아이디어를 기반으로 한다.
  * 또 다른 유사점은 의존성 간의 단방향 흐름이다.
  * 이 둘의 차이점은 사이드 이펙트에 대한 처리에 있다
    * 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다. 이 가장자리는 가변 셸이 처리한다.
    * 반면 육각형 아키텍처는 도메인 계층에 제한하는 한, 도메인 계층으로 인한 사이드 이펙트도 문제없다.

## ✅ 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환
* **감사 시스템 소개**
* **테스트를 파일 시스템에서 분리하기 위한 목 사용**
* **함수형 아키텍처로 리팩터링하기**
* **예상되는 추가 개발**

## ✅ 6.5 함수형 아키텍처의 단점 이해하기
* **함수형 아키텍처 적용 가능성**
  * 데이터베이스와 같이 해당 의존성으로 인해 숨은 입력이 생길 수도 있다. 이러한 클래스는 더 이상 순수 함수가 아니며, 전체 애플리케이션은 더 이상 함수형 아키텍처를 따르지 않는다. 따라서 출력 기반 테스트를 적용할 수 없다
* **성능 단점**
  * 이제 시스템은 프로세스 외부 의존성을 더 많이 호출하고, 그 결과로 성능이 떨어졌다.
  * 감사 시스템의 초기 버전과 목이 있는 버전 모두 작업 디렉터리에서 모든 파일을 읽지는 않았다. 그러나 최종 버전은 읽고-결정하고-실행하기(read-decide-act) 방식을 따르도록 작업 디렉터리의 모든 파일을 읽었다.
  * 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성(제품 코드와 테스트 코드 모두) 간의 절충이다.
* **코드베이스 크기 증가**
  * 함수형 아키텍터는 함수형 코어와 가변 셸 사이를 명확하게 분리해야 한다. 궁극적으로 코드 복잡도가 낮아지고 유지 보수성이 향상되지만, 초기에 코딩이 더 필요하다.
  * 그러나 모든 프로젝트에 초기 투자가 타당할 만큼 복잡도가 높은 것은 아니기 때문에 상황에 따라 함수형 아키텍처 도입을 고민해보자.
  * 함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지말라. 대부분의 프로젝트에서는 모든 도메인 모델을 불변으로 할 수 없기 때문에 출력 기반 테스트에만 의존할 수 없다.

## ✅ 요약
* 출력 기반 테스트는 SUT에 입력을 주고 출력을 확인하는 테스트 스타일이다. 이 테스트 스타일은 숨은 입출력이 없다고 가정하고, SUT 작업의 결과는 반환하는 값뿐이다.
* 상태 기반 테스트는 작업이 완료된 후의 시스템 상태를 확인한다.
* 통신 기반 테스트는 목을 사용해서 테스트 대상 시스템과 협력자 간의 통신을 검증한다.
* 함수형 프로그래밍은 수학적 함수로 된 프로그래밍이다.
* 수학적 함수는 숨은 입출력이 없는 함수다. 사이드 이펙트와 예외가 숨은 출력에 해당한다.
* 함수형 프로그래밍의 목표는 비즈니스 로직과 사이드 이펙트를 분리하는 것이다.
* 함수형 아키텍처는 사이드 이펙트를 비즈니스 연산의 가장자리로 밀어내 분리를 이루는 데 도움이 된다. 이 방법으로, 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수 방식으로 작성된 코드의 양을 최대화할 수 있다.
* 함수형 아키텍처는 모든 코드를 함수형 코어와 가변 셸이라는 두 가지 범주로 나눈다. 가변 셸은 입력 데이터를 함수형 코어에 공급하고, 코어가 내린 결정을 사이드 이펙트로 변환한다.
* 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 사이의 절충이며, 함수형 아키텍처는 유지 보수성 향상을 위해 성능을 희생한다.
* 모든 코드베이스를 함수형 아키텍처로 전환할 수는 없다. 함수형 아키텍처를 전략적으로 적용하라. 시스템의 복잡도와 중요성을 고려하라.
