## ✅ 5.1 목과 스텁 구분
* **테스트 대역 유형**</br>
  * 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
  * 테스트 대역의 주 용도는 테스트를 편리하게 하는 것이다.</br>
  <img src="https://github.com/user-attachments/assets/d418a31b-bd8b-4de5-9ffc-bde069a2a5cb" width="400"/></br>
  * 테스트 대역은 목과 스텁 두 가지 유형으로 나눌 수 있다.
    * 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
    * 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
* **도구로서의 목과 테스트 대역으로서의 목**
  * 목은 테스트 대역의 일부일 뿐이다. 그러나 목이라는 용어는 또 다른 의미가 있다. 목 라이브러리의 클래스도 목으로 참고할 수 있다.
  * 도구로서의 목을 사용해 목과 스텁, 이 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로서의 목을 혼동하지 않는 것이 중요하다.
* **스텁으로 상호 작용을 검증하지 말라**
  * ✏️ 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.
  * ✏️ 과잉 명세(overspecification): 최종 결과가 아닌 사항을 검증하는 관행
  * 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스트가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다.
  * 목은 더 복잡하다. 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만, 대다수가 그렇다.
* **목과 스텁 함께 쓰기**
* **목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?**
  * 목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Seperation) 원칙과 관련이 있다.
  * CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안된다.
    * 명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드(void)다.
    * 조회는 그 반대로, 사이드 이펙트가 없고 값을 반환한다.
* 명령을 대체하는 테스트 대역은 목이다. 마찬가지로 조회를 대체하는 테스트 대역은 스텁이다.

## ✅ 5.2 식별할 수 있는 동작과 구현 세부 사항
* **식별할 수 있는 동작은 공개 API와 다르다.**
  * 모든 제품 코드는 2차원으로 분류할 수 있다.
    * 공개 API 또는 비공개 API
    * 식별할 수 있는 동작 또는 구현 세부 사항
  * 식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야한다.
    * 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드다.
    * 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.
  * 구현 세부 사항은 이 두 가지 둥 아무것도 하지 않는다.
* **구현 세부 사항 유출: 연산의 예**
  * 클래스 API를 잘 설계하려면 해당 멤버가 식별할 수 있는 동작이 되게 해야 한다.
    * 클라이언트가 목표를 달성하는 데 도움이 되는 작업을 노출하라.
    * 클라이언트가 목표를 잘성하는 데 도움이 되는 상태를 노출하라.
* **잘 설계된 API와 캡슐화**
  * 잘 설계된 API를 유지 보수하는 것은 캡슐화 개념과 관련이 있다.
  * 구현 세부 사항을 노출하면 불변성 위반을 가져온다.
  * 장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다. 복잡도 때문이다. 코드 복잡도는 소프트웨어 개발에서 가장 큰 어려움 중 하나다. 코드베이스가 점점 복잡해질수록 작업하기가 더 어려워지고, 개발 속도가 느려지고, 버그 수가 증가하게 된다.
  * 계속해서 증가하는 코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고는 없다.
* **구현 세부 사항 유출: 상태의 예**

## ✅ 5.3 목과 테스트 취약성 간의 관계
* **육각형 아키텍처 정의**</br>
  <img src="https://github.com/user-attachments/assets/a06826bb-4453-4c8a-8758-7a8cf0ed0e9a" width="400"/></br>
  * 육각형 아키텍처는 상호 작용하는 애플리케이션(육각형)의 집합이다.
  * 육각형 아키텍처의 목적은 세 가지 중요한 지침을 강조하는 것이다.
    * 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
    * 애플리케이션 내부 통신
    * 애플리케이션 간의 통신
   * 잘 설계된 API의 원칙에는 프랙탈 특성이 있는데, 이는 전체 계층만큼 크게도, 단일 클래스만큼 작게도 똑같이 적용되는 것이다.
   * 각 계층의 API를 잘 설계하면(즉, 구현 세부 사항을 숨기면) 테스트도 프랙탈 구조를 갖기 시작한다. 즉, 달성하는 목표는 같지만 서로 다른 수준에서 동작을 검증한다.
* **시스템 내부 통신과 시스템 간 통신**
  * 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다. 시스템 간 통신은 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다.
  * 시스템 간 통신은 전체적으로 애플리케이션의 식별할 수 있는 동작을 나타낸다. 시스템 내부 통신은 구현 세부 사항이다.
* **시스템 내부 통신과 시스템 간 통신의 예**

## ✅ 5.4 단위 테스트의 고전파와 런던파 재고
* **모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다**
* **목을 사용한 동작 검증**

## ✅ 요약
* 테스트 대역은 테스트에서 비제품 가짜 의존성의 모든 유형을 설명하는 포괄적인 용어다. 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 등의 다섯가지 변형이 있는데, 이는 다시 목과 스텁이라는 두 가지 유형으로 분류할 수 있다. 이는 다시 목과 스텁이라는 두 가지 유형으로 분류할 수 있다. 스파이는 기능적으로 목과 같고, 더미와 페이크는 스텁과 같은 역할을 한다.
* 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다.
* Mock(도구)은 목(테스트 대역)이나 스텁을 만드는 데 사용할 수 있는 목 라이브러리의 클래스다.
* 스텁과의 상호 작용을 검증하면 취약한 테스트로 이어진다.
* 명령 조회 분리(CQS) 원칙에 따르면, 모든 메서드가 명령 또는 조회 중 하나여야 하지만 둘 다는 안 된다.
* 모든 제품 코드는 공개 API인지 비공개 API인지와 식별할 수 있는 동작인지 구현 세부 사항인지라는 두 가지 차원으로 분류할 수 있다.
* 잘 설계된 코드는 식별할 수 있는 동작이 공개 API와 일치하고 구현 세부 사항이 비공개 API 뒤에 숨겨져 있는 코드다.
* 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위다. 클라이언트는 구현 세부 사항을 이용해 코드의 불변성을 우회할 수 있기 때문에 구현 세부 사항을 노출하면 캡슐화가 위반되는 경우가 종종 있다.
* 육각형 아키텍처는 상호 작용하는 애플리케이션의 집합이고 각 애플리케이션은 육각형으로 표시한다.
* 육각형 아키텍처는 다음과 같은 세 가지 관점을 강조한다.
  * 도메인과 애플리케이션 서비스 계층 간의 영향 분리
  * 애플리케이션 서비스 계층에서 도메인 계층으로의 단방향 의존성 흐름
  * 외부 애플리케이션은 애플리케이션 서비스 계층이 유지하는 공통 인터페이스를 통해 연결된다.
* 육각형의 각 계층은 식별할 수 있는 동작을 나타내며 각각의 구현 세부 사항이 있다.
* 애플리케이션에는 시스템 내부 통신과 시스템 간 통신이라는 두 가지 통신 유형이 있다. 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다. 시스템 간 통신은 애플리케이션이 외부 애플리케이션과 통신할 때를 말한다.
* 시스템 내 통신은 구현 세부 사항이다.
* 시스템 내 통신을 검증하고자 목을 사용하면 취약한 테스트로 이어진다. 따라서 시스템 간 통신과 해당 통신의 사이드 이펙트가 외부 환경에서 보일 때만 목을 사용하는 것이 타당하다.
