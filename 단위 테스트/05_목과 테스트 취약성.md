## ✅ 5.1 목과 스텁 구분
* **테스트 대역 유형**</br>
  * 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
  * 테스트 대역의 주 용도는 테스트를 편리하게 하는 것이다.</br>
  <img src="https://github.com/user-attachments/assets/d418a31b-bd8b-4de5-9ffc-bde069a2a5cb" width="400"/></br>
  * 테스트 대역은 목과 스텁 두 가지 유형으로 나눌 수 있다.
    * 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
    * 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
* **도구로서의 목과 테스트 대역으로서의 목**
  * 목은 테스트 대역의 일부일 뿐이다. 그러나 목이라는 용어는 또 다른 의미가 있다. 목 라이브러리의 클래스도 목으로 참고할 수 있다.
  * 도구로서의 목을 사용해 목과 스텁, 이 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로서의 목을 혼동하지 않는 것이 중요하다.
* **스텁으로 상호 작용을 검증하지 말라**
  * ✏️ 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.
  * ✏️ 과잉 명세(overspecification): 최종 결과가 아닌 사항을 검증하는 관행
  * 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스트가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다.
  * 목은 더 복잡하다. 목을 쓰면 무조건 테스트 취약성을 초래하는 것은 아니지만, 대다수가 그렇다.
* **목과 스텁 함께 쓰기**
* **목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?**

## ✅ 5.2 식별할 수 있는 동작과 구현 세부 사항
* **식별할 수 있는 동작은 공개 API와 다르다.**
* **구현 세부 사항 유출: 연산의 예**
* **잘 설계된 API와 캡슐화**
* **구현 세부 사항 유출: 상태의 예**

## ✅ 5.3 목과 테스트 취약성 간의 관계
* **육각형 아키텍처 정의**
* **시스템 내부 통신과 시스템 간 통신**
* **시스템 내부 통신과 시스템 간 통신의 예**

## ✅ 5.4 단위 테스트의 고전파와 런던파 재고
* **모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다**
* **목을 사용한 동작 검증**

## ✅ 요약
