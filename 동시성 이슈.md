## ✏️ 동시성 이슈란?
하나의 자원에 대해서 여러 스레드가 동시에 접근하여 수정하는 경우 발생하는 문제   
➡️ 이는 곧, **스레드의 안정성이 깨졌다**고 말할 수 있다.

## ✏️ 동시성 이슈가 발생하는 예시
### 조회수 증가 프로그램
<img src="https://github.com/syoh98/TIL/assets/76934280/6bf852da-e3b0-403d-8f73-d068736bed1c" width="300"/></br>
<img src="https://github.com/syoh98/TIL/assets/76934280/cbf16073-e77d-4989-a81e-c65d266fd6ba" width="400"/></br>
<img src="https://github.com/syoh98/TIL/assets/76934280/3276b5c4-be8d-4bd4-876a-1cc43a44960e" width="300"/></br>
해당 코드를 실행시켰을 때, 100*100인 10000 조회수 값이 나오기를 기대하지만 기대와는 다른 결과 값이 나온다.
➡️ **동시성 이슈가 발생했기 때문이다.**

## 🤔 그럼 동시성 이슈는 왜 발생할까?
### Context Switching
위에서 테스트 해봤던 조회 수 증가 프로그램의 `increaseViews()` 메서드는 `views++` 동작을 진행하는데, 이 동작은 3가지의 과정을 거친다.
* 데이터를 조회하는 LOAD
* 데이터를 증가하는 INC
* 데이터를 저장하는 STORE   
<img src="https://github.com/syoh98/TIL/assets/76934280/6ff2938c-3989-4cd4-a754-d5843ba48883" width="600"/></br>
<img src="https://github.com/syoh98/TIL/assets/76934280/ba59e0bd-53ce-47a2-af8e-5e35baa75f32" width="600"/></br>
<img src="https://github.com/syoh98/TIL/assets/76934280/a14880db-fad8-4843-881e-c18b1ed6772e" width="260"/></br>
만약, 스레드 1에서 데이터를 저장하기 전 **Context Switching**이 일어나 스레드 2에서 LOAD, INC, STORE의 작업 마친 후 스레드 1에서 남은 작업인 STORE를 끝내는 경우, views 변수에 2가 저장될 것을 기대했지만 1이 저장되었다.   
이처럼 하나의 공유자원에 대해 다수의 스레드가 공유할 때 나타나는 동시성 문제를 **Race Condition** 이라고 한다.
* **💡Race Condition이란?**
  * 두 개 이상의 프로세스나 스레드가 공유 자원에 동시 접근해 값을 변경하는 경우, 접근 순서에 따라 실행 결과가 달라지는 현상
 
## 🤔 그럼 동시성 이슈를 해결하는 방법에는 무엇이 있을까?
Race Condition이 발생한 원인을 보면, 스레드가 `increaseViews()` 메서드를 수행하고 있는데 다른 스레드에게 제어권이 넘어갔기 때문이다.   
이러한 문제를 방지하기 위해 **하나의 스레드가 특정 작업을 끝내기 전까지 다른 스레드에 영향을 받지 않도록 도와주는 장치**가 있는데, 바로 `lock`이다.

## 1️⃣ 코드레벨 동시성(자바 어플리케이션 내부 메모리)
### Synchronized
자바는 `synchronized` 키워드를 사용하여 해당 메서드를 **임계영역**으로 설정할 수 있다.   
**임계영역이**란 공유 데이터를 사용하는 코드 영역을 의미하며, **lock을 획득한 단 하나의 스레드만 임계영역에 진입할 수 있다.**
```java
public class Stock {
    private int views; // 조회수
    
    public synchronized void increaseViews() {
        this.views++;
    }
    
    public int getViews() {
        return this.views;
    }
}
```

### Concurrent 패키지
synchronized의 임계영역은 프로그램의 성능을 좌우하기 때문에 최소화해야한다.   
따라서 Java5부터  synchronized를 사용하지 않고 동기화를 할 수 있는 `java.util.concurrent`패키지가 추가되었다.
* **Atomic 클래스**   
  ```java
  public class Stock {
    private AtomicInteger views; // 조회수
    
    public void increaseViews() {
        this.views.getAndAdd(+1);
    }
    
    public int getViews() {
        return this.views.get();
    }
  }
  ```
  views 변수를 `AtomicInteger`로 변환하여 적용했을 때, `increaseViews()` 메서드도 AtomicInteger 타입의 `getAndAdd()` 메서드를 적용해야 한다.
  🤔 그럼 동시성 이슈는 왜 발생할까?    
  ➡️ 위의 예시에서는 조회와 쓰기 작업 중 다른 스레드가 진입할 수 있었다. 하지만 `getAndAdd()` 메서드는 조회와 쓰기가 하나의 동작으로 이루어져 다른 스레드가 진입할 수 없다. **이는 곧 원자성을 보장한다고 할 수 있다.**
  Atomic변수는 CAS(Compare and swap) 알고리즘을 사용하여 멀티 스레드 환경에서 원자성을 보장한다.
  **CAS 알고리즘**은 값을 변경하는 시점에 스레드가 알고있는 `Stock.views` 값과 메모리 상의 `Stock.views` 값을 비교하여 일치하면 동작을 그대로 진행시키고, 다르다면 동작을 재수행하는 알고리즘이다.
* **ConcurrentHashMap**
  * ConcurrentHashMap의 `get()` 메서드   
    <img src="https://github.com/syoh98/TIL/assets/76934280/8e100f6d-3151-4d82-8ad4-085aaf6d93a5" width="600"/></br>
  * ConcurrentHashMap의 `put()` 메서드   
    <img src="https://github.com/syoh98/TIL/assets/76934280/c0310366-1754-4f66-9a70-deb20fb278a8" width="600"/></br>
  ➡️ `get()` 메서드는 synchronized가 존재하지 않는 반면, `put()` 메서드에서는 부분적으로 synchronized가 존재한다.   
  이처럼 ConcurrentHashMap은 모든 버킷에 락을 거는 것이 아닌, 접근하는 버킷에 대해서만 락을거는 **Lock Striping** 기법을 사용한다.

### 불변객체(Immutable Object)
불변객체는 `String`, `Integer`와 같이 객체 생성 후, **해당 객체의 내부상태가 변하지 않는 객체**를 의미한다.
불변객체의 기본 규칙은 `final`을 사용하고 `setter`를 사용하지 않는 것으로, lock을 걸 필요가 없다.   

➡️ **이러한 방법들은 단일 서버의 동시성 이슈만 해결할 수 있다. (=다중 서버에서는 해결할 수 없다.)**   
</br>

## 2️⃣ 다중 서버에서의 동시성 이슈 해결
## 분산락
**여러 서버에서 동일 자원에 접근하는 경우**, 동시에 한개의 프로세스(스레드)만 접근 가능하도록 사용하는 Lock이다.
## ✔️ 분산락 구현 방법(DBMS)
* **낙관적락(Optimistic Lock)**
  * 트랜잭션 대부분은 충돌하지 않을 것이라고 낙관적으로 가정하는 방법이다.
* **비관적락(Pessimistic Lock)**
  * 트랜잭션 충돌이 발생할 것이라고 비관적으로 가정하는 방법이다.
* **Named Lock(MySQL USER-LEVEL LOCK)**

## ✔️ 분산락 구현 방법(Redis)
* Redis
  * Lettuce
  * Redisson
</br>
참고
https://cookie-dev.tistory.com/29
