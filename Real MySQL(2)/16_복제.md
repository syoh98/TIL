## 🦅 16.1 개요
* 복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.
* 원본 데이터를 가진 서버를 소스 서버, 복제된 데이터를 가지는 서버를 레플리카(Replica) 서버라고 부른다.
* 복제를 통해 레플리카 서버를 구축하는 데는 여러 가지 목적이 있다.
  1. 스케일 아웃(Scale-out)
     * 스케일 업에는 한 대에서 트래픽을 처리할 수 있는 한계가 존재한다.
     * 따라서 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.
  2. 데이터 백업
     * 사용자의 실수로 DB서버에 있는 데이터가 삭제되면 서비스 운영에 치명적인 영향을 줄 수 있다.
     * 이러한 경우에 대비하기 위해서는 DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적인데, 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용한다.
     * 이 경우, 쿼리 처리 속도가 느려져 서비스에 문제가 발생할 수 있기 떄문에 복제를 통해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다.
  3. 데이터 분석
     * DB 서버에서는 차세대 비즈니스 모델을 발굴하기 위해서 또는 서비스를 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다.
     * 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많아 쿼리 자체가 복잡하고 무거운 경우가 대부분이라 쿼리를 실행할 때 서버의 리소스를 많이 사용하게 된다.
     * 이 경우, 서비스에 직접적으로 사용되는 다른 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축한다.
  4. 데이터의 지리적 분산
     * DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다.
     * 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못했다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 🦅 16.2 복제 아키텍처
* **복제 관련 용어**
  * ✏️ 바이너리 로그(Binary Log): MySQL 서버에서 발생하는 모든 변경 사항을 순서대로 기록해 놓은 로그 파일
  * ✏️ 이벤트(Event): 바이너리 로그에 기록된 각 변경 정보들
  * ✏️ 릴레이 로그(Relay Log): 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일
* **복제 시 작동하는 세 개의 스레드**
  * 바이너리 로그 덤프 스레드: 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
  * 레플리케이션 I/O 스레드: 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일로 저장하는 역할을 담당한다.
  * 레플리케이션 SQL 스레드: 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 * **복제가 시작될 때 레플리카 서버가 생성하는 복제 관련 데이터**
   * 릴레이 로그: 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트(트랜잭션) 정보가 저장된다.
   * 커넥션 메타데이터: 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨있다. `slave_master_info` 테이블에 저장되는 정보이다.
   * 어플라이어 메타데이터: 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 로그 파일명과 파일 내 위치 정보 등을 담고있다. `slave_relay_log_info` 테이블에 저장되는 정보이다.

## 🦅 16.3 복제 타입
* **바이너리 로그 파일 위치 기반 복제**
  * 바이너리 로그 파일 위치 기반 복제는 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  * 바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시하게 된다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않기 때문이다.
  * **바이너리 로그 파일 위치 기반의 복제 구축**
    1. 설정 준비
    2. 복제 계정 준비
    3. 데이터 복사
    4. 복제 시작
  * **바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기**
    * 복제로 구성돼 있는 MySQL 서버들을 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생하기도 한다.
    * 경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때가 있다. 이 경우 바이너리 로그 위치 기반 복제에서는 `sql_slave_skip_counter` 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.
* **글로벌 트랜잭션 아이디(GTID) 기반 복제**</br>
  바이너리 로그 파일 위치 기반 복제 방식은 각각의 이벤트들이 바이너리 로그 파일명과 파일 내 위치 값의 조합으로 식별되는데, 문제는 이 같은 식별이 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효하다. 동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다. 한마디로 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 되는 것이다.
  * GTID의 필요성
  * 글로벌 트랜잭션 아이디
    * GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다.
    * MySQL의 GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다.
    * `GTID = [source_id]:[transaction_id]`
  * 글로벌 트랜잭션 아이디 기반의 복제 구축
    * MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반의 복제를 사용하는 것은 별개이며, GTID 활성화는 GTID 복제를 위한 하나의 조건이다.
    * 즉, MySQL 서버의 GTID는 활성화돼 있다 하더라도 복제는 바이너리 로그 파일 위치 기반의 복제를 사용할 수도 있다.
    * **GTID를 사용하고 있는 소스 서버에 레플리카 서버를 GTID 기반 복제로 연결하는 과정**
      1. 설정 준비
      2. 복제 계정 준비
      3. 데이터 복사
      4. 복제 시작
  * 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기
    * 만약 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션을 무시하고 싶다면 레플리카 서버에서 수동으로 빈 트랜잭션을 생성해 GTID 값을 만들어야 한다.
  * Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경
    * MySQL 8.0에서는 서비스가 현재 동작하고 있는 상태에서 MySQL 서버가 GTID를 사용하도록 혹은 사용하지 않도록 GTID 모드를 온라인으로 전환할 수 있는 기능을 제공한다.
    * 이 기능을 통해 기존에 바이너리 로그 위치 기반의 복제를 GTID 기반의 복제로 변경할 수 있으며, 그 반대의 경우도 가능하다.
    * GTID를 사용하는 복제 환경에서는 다음과 같은 패턴의 쿼리들은 안전하지 않다.
      * 트랜잭션을 지원하는 테이블과 지원하지 않는 테이블을 함께 변경하는 쿼리 혹은 트랜잭션
      * CRAETE TABLE ... SELECT ... 구문
      * 트랜잭션 내에서 CREATE TEMPORARY TABLE. DROP TEMPORARY TABLE 구문 사용
      *  ➡️ 특징: 소스 서버에서 레플리카 서버로 복제되어 적용될 때 단일 트랜잭션으로 처리되지 않을 수도 있다. GTID가 트랜잭션 단위로 올바르게 할당돼야 복제가 정상적으로 동작한다.
      *  `enforce_gtid_consistency`: 쿼리들의 실행 가능 여부 제어
      *  `gtid_mode`: 바이너리 로그에 트랜잭션들이 GTID 기반으로 로깅될 수 있는지 여부, 트랜잭션 유형별로 MySQL 서버에서의 처리 가능 여부 제어
  * GTID 기반 복제 제약 사항
    * GTID가 활성화된 MySQL 서버에서는 `enforce_gtid_consistency=ON` 옵션으로 인해 GTID 일관성을 해칠 수 있는 일부 유형의 쿼리들은 실행할 수 없다.
    * GTID 기반 복제가 설정된 레플리카 서버에서는 sql_slave_skip_counter 시스템 변수를 사용해 복제된 트랜잭션을 건너뛸 수 없다.
    * GTID 기반 복제에서 CHANGE REPLICATION SOURCE TO(또는 CHANGE MASTER TO) 구문의 IGNORE_SERVER_IDS 옵션은 더 이상 사용되지 않는다.

## 🦅 16.4 복제 데이터 포맷
* **Statement 기반 바이너리 로그 포맷**
  * 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식이다.
  * 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데, 이 경우 Statement 포맷에서는 바이너리 로그에 SQL문 하나만 기록된다.
  * 장점
    * 바이너리 로그 파일의 용량이 작아지므로 사용자 입장에서는 저장 공간에 대한 부담을 덜 수 있으며, 원격으로 바이너리 로그를 백업하거나 혹은 원격에 위치한 레플리카 서버와 복제할 때도 좀 더 빠르게 처리될 수 있다.
  * 단점
    * 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.
    * Statement 포맷 기반 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 비확정적 쿼리 유형
      * DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
      * SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
      * LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
      * 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리
    * Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다.
    * Statement 기반 바이너리 로그 포맷은 트랜잭션 격리 수준이 반드시 "REPEATABLE-READ" 이상이어야 한다.
* **Row 기반 바이너리 로그 포맷**
  * MySQL 서버에서 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식이다.
  * Row 포맷에서는 소스 서버에서 실행된 쿼리가 UUID(), USER() 등과 같은 비확정적 함수를 사용했다 하더라도 레플리카 서버에서 똑같이 이 함수가 다시 실행되는 것이 아니라 함수의 결괏값을 전달받아 처리되므로 이 같은 경우에 있어서도 안전하게 복제가 가능하다.
  * 다음과 같은 쿼리들이 실행되는 경우 Statement 포맷보다 락이 최소화되어 처리된다.
    * INSERT ... SELECT
    * INSERT with AUTO_INCREMENT
    * 적절한 인덱스가 없어 풀스캔으로 처리되는 UPDATE/DELETE
  * 변경된 데이터가 그대로 바이너리 로그에 기록되기 때문에 만약 MySQL 서버에서 실행된 쿼리가 굉장히 많은 데이터를 변경한 경우에는 변경된 데이터가 전부 기록되므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있다.
* **Mixed 포맷**
  * 사용자는 MySQL 서버가 두 가지 바이너리 로그 포맷을 혼합해서 사용하도록 설정할 수 있다.
  * MIXED 방식을 사용하면 Statement 포맷과 Row 포맷의 장점만 취해서 사용하는 것으로 생각할 수 있지만 MySQL 서버가 내부적으로 설정된 기준과 기술적인 측면을 고려새 자동으로 두 포맷을 번갈아 사용하는 것이므로 예상했던 것과 다르게 처리될 수도 있다.
  * 따라서 MIXED 포맷만이 제일 좋은 방법이라고 할 수는 없으며, 사용자는 자신이 사용하는 쿼리 형태에 제일 적합한 방식이 어떤 방식인지를 고려해서 설정하는 것이 좋다.
* **Row 포맷의 용향 최적화**</br>
  사용자들이 Row 기반의 바이너리 포맷을 사용할지 망설이는 대표적인 이유는 바이너리 로그 파일의 용량이 Statement 포맷을 사용할 때보다 많이 커질 수 있다는 점이다.
  * 바이너리 로그 Row 이미지
    * MySQL에서는 Row 포맷의 바이너리 로그 파일 용량을 최소화하기 위해 저장되는 변경 데이터의 칼럼 구성을 제어하는 `binlog_row_image`라는 시스템 변수를 제공한다.
    * Row 포맷을 사용할 경우 바이너리 로그에는 각 변경 데이터마다 변경 전 레코드(Before-Image)와 변경 후 레코드(After-Image)가 함께 저장되는데, `binlog_row_image` 시스템 변수는 각 변경 전후 레코드들에 대해 테이블의 어떤 칼럼들을 기록할 것인지를 결정한다.
    * 옵션: full, minimal, noblob
  * 바이너리 로그 트랜잭션 압축

## 🦅 16.5 복제 동기화 방식**
* **비동기 복제(Asynchronous replication)**
* **반동기 복제(Semi-synchronous replication)**
  * 반동기 복제 설정 방법
