## 🦅 16.1 개요
* 복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.
* 원본 데이터를 가진 서버를 소스 서버, 복제된 데이터를 가지는 서버를 레플리카(Replica) 서버라고 부른다.
* 복제를 통해 레플리카 서버를 구축하는 데는 여러 가지 목적이 있다.
  1. 스케일 아웃(Scale-out)
     * 스케일 업에는 한 대에서 트래픽을 처리할 수 있는 한계가 존재한다.
     * 따라서 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.
  2. 데이터 백업
     * 사용자의 실수로 DB서버에 있는 데이터가 삭제되면 서비스 운영에 치명적인 영향을 줄 수 있다.
     * 이러한 경우에 대비하기 위해서는 DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적인데, 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용한다.
     * 이 경우, 쿼리 처리 속도가 느려져 서비스에 문제가 발생할 수 있기 떄문에 복제를 통해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다.
  3. 데이터 분석
     * DB 서버에서는 차세대 비즈니스 모델을 발굴하기 위해서 또는 서비스를 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다.
     * 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많아 쿼리 자체가 복잡하고 무거운 경우가 대부분이라 쿼리를 실행할 때 서버의 리소스를 많이 사용하게 된다.
     * 이 경우, 서비스에 직접적으로 사용되는 다른 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축한다.
  4. 데이터의 지리적 분산
     * DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다.
     * 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못했다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 🦅 16.2 복제 아키텍처
* **복제 관련 용어**
  * ✏️ 바이너리 로그(Binary Log): MySQL 서버에서 발생하는 모든 변경 사항을 순서대로 기록해 놓은 로그 파일
  * ✏️ 이벤트(Event): 바이너리 로그에 기록된 각 변경 정보들
  * ✏️ 릴레이 로그(Relay Log): 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일
* **복제 시 작동하는 세 개의 스레드**
  * 바이너리 로그 덤프 스레드: 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
  * 레플리케이션 I/O 스레드: 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일로 저장하는 역할을 담당한다.
  * 레플리케이션 SQL 스레드: 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 * **복제가 시작될 때 레플리카 서버가 생성하는 복제 관련 데이터**
   * 릴레이 로그: 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트(트랜잭션) 정보가 저장된다.
   * 커넥션 메타데이터: 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨있다. `slave_master_info` 테이블에 저장되는 정보이다.
   * 어플라이어 메타데이터: 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 로그 파일명과 파일 내 위치 정보 등을 담고있다. `slave_relay_log_info` 테이블에 저장되는 정보이다.

## 🦅 16.3 복제 타입
* **바이너리 로그 파일 위치 기반 복제**
  * 바이너리 로그 파일 위치 기반 복제는 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  * 바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시하게 된다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않기 때문이다.
  * **바이너리 로그 파일 위치 기반의 복제 구축**
    1. 설정 준비
    2. 복제 계정 준비
    3. 데이터 복사
    4. 복제 시작
  * **바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기**
    * 복제로 구성돼 있는 MySQL 서버들을 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생하기도 한다.
    * 경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때가 있다. 이 경우 바이너리 로그 위치 기반 복제에서는 `sql_slave_skip_counter` 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.
* **글로벌 트랜잭션 아이디(GTID) 기반 복제**
  * GTID의 필요성
  * 글로벌 트랜잭션 아이디
  * 글로벌 트랜잭션 아이디 기반의 복제 구축
  * 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기
  * Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경
  * GTID 기반 복제 제약 사항

## 🦅 16.4 복제 데이터 포맷
* **Statement 기반 바이너리 로그 포맷**
* **Row 기반 바이너리 로그 포맷**
* **Mixed 포맷**
* **Row 포맷의 용향 최적화**
  * 바이너리 로그 Row 이미지
  * 바이너리 로그 트랜잭션 압축

## 🦅 16.5 복제 동기화 방식**
* **비동기 복제(Asynchronous replication)**
* **반동기 복제(Semi-synchronous replication)**
  * 반동기 복제 설정 방법
