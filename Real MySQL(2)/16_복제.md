## 🦅 16.1 개요
* 복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.
* 원본 데이터를 가진 서버를 소스 서버, 복제된 데이터를 가지는 서버를 레플리카(Replica) 서버라고 부른다.
* 복제를 통해 레플리카 서버를 구축하는 데는 여러 가지 목적이 있다.
  1. 스케일 아웃(Scale-out)
     * 스케일 업에는 한 대에서 트래픽을 처리할 수 있는 한계가 존재한다.
     * 따라서 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.
  2. 데이터 백업
     * 사용자의 실수로 DB서버에 있는 데이터가 삭제되면 서비스 운영에 치명적인 영향을 줄 수 있다.
     * 이러한 경우에 대비하기 위해서는 DB 서버에 저장된 데이터들을 주기적으로 백업하는 것이 필수적인데, 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용한다.
     * 이 경우, 쿼리 처리 속도가 느려져 서비스에 문제가 발생할 수 있기 떄문에 복제를 통해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다.
  3. 데이터 분석
     * DB 서버에서는 차세대 비즈니스 모델을 발굴하기 위해서 또는 서비스를 발전시킬 수 있는 인사이트를 얻기 위해 분석용 쿼리들을 실행하기도 한다.
     * 분석용 쿼리는 대량의 데이터를 조회하는 경우가 많아 쿼리 자체가 복잡하고 무거운 경우가 대부분이라 쿼리를 실행할 때 서버의 리소스를 많이 사용하게 된다.
     * 이 경우, 서비스에 직접적으로 사용되는 다른 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축한다.
  4. 데이터의 지리적 분산
     * DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어난다.
     * 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못했다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 🦅 16.2 복제 아키텍처
* **복제 관련 용어**
  * ✏️ 바이너리 로그(Binary Log): MySQL 서버에서 발생하는 모든 변경 사항을 순서대로 기록해 놓은 로그 파일
  * ✏️ 이벤트(Event): 바이너리 로그에 기록된 각 변경 정보들
  * ✏️ 릴레이 로그(Relay Log): 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일
* **복제 시 작동하는 세 개의 스레드**
  * 바이너리 로그 덤프 스레드: 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
  * 레플리케이션 I/O 스레드: 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일로 저장하는 역할을 담당한다.
  * 레플리케이션 SQL 스레드: 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 * **복제가 시작될 때 레플리카 서버가 생성하는 복제 관련 데이터**
   * 릴레이 로그: 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트(트랜잭션) 정보가 저장된다.
   * 커넥션 메타데이터: 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과 파일 내 위치 값 등이 담겨있다. `slave_master_info` 테이블에 저장되는 정보이다.
   * 어플라이어 메타데이터: 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 로그 파일명과 파일 내 위치 정보 등을 담고있다. `slave_relay_log_info` 테이블에 저장되는 정보이다.

## 🦅 16.3 복제 타입
* **바이너리 로그 파일 위치 기반 복제**
  * 바이너리 로그 파일 위치 기반 복제는 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  * 바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시하게 된다. 자신의 서버에서 발생한 이벤트로 간주해서 적용하지 않기 때문이다.
  * **바이너리 로그 파일 위치 기반의 복제 구축**
    1. 설정 준비
    2. 복제 계정 준비
    3. 데이터 복사
    4. 복제 시작
  * **바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기**
    * 복제로 구성돼 있는 MySQL 서버들을 운영하다 보면 종종 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생해 복제가 멈추는 현상이 발생하기도 한다.
    * 경우에 따라 레플리카 서버에서 문제되는 소스 서버의 트랜잭션을 무시하고 넘어가도록 처리해도 괜찮을 때가 있다. 이 경우 바이너리 로그 위치 기반 복제에서는 `sql_slave_skip_counter` 시스템 변수를 이용해 문제되는 트랜잭션을 건너뛸 수 있다.
* **글로벌 트랜잭션 아이디(GTID) 기반 복제**</br>
  바이너리 로그 파일 위치 기반 복제 방식은 각각의 이벤트들이 바이너리 로그 파일명과 파일 내 위치 값의 조합으로 식별되는데, 문제는 이 같은 식별이 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효하다. 동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다. 한마디로 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 되는 것이다.
  * GTID의 필요성
  * 글로벌 트랜잭션 아이디
    * GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다.
    * MySQL의 GTID는 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다.
    * `GTID = [source_id]:[transaction_id]`
  * 글로벌 트랜잭션 아이디 기반의 복제 구축
    * MySQL 서버에서 GTID를 활성화하는 것과 GTID 기반의 복제를 사용하는 것은 별개이며, GTID 활성화는 GTID 복제를 위한 하나의 조건이다.
    * 즉, MySQL 서버의 GTID는 활성화돼 있다 하더라도 복제는 바이너리 로그 파일 위치 기반의 복제를 사용할 수도 있다.
    * **GTID를 사용하고 있는 소스 서버에 레플리카 서버를 GTID 기반 복제로 연결하는 과정**
      1. 설정 준비
      2. 복제 계정 준비
      3. 데이터 복사
      4. 복제 시작
  * 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기
    * 만약 레플리카 서버에서 소스 서버로부터 넘어온 트랜잭션을 무시하고 싶다면 레플리카 서버에서 수동으로 빈 트랜잭션을 생성해 GTID 값을 만들어야 한다.
  * Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경
    * MySQL 8.0에서는 서비스가 현재 동작하고 있는 상태에서 MySQL 서버가 GTID를 사용하도록 혹은 사용하지 않도록 GTID 모드를 온라인으로 전환할 수 있는 기능을 제공한다.
    * 이 기능을 통해 기존에 바이너리 로그 위치 기반의 복제를 GTID 기반의 복제로 변경할 수 있으며, 그 반대의 경우도 가능하다.
    * GTID를 사용하는 복제 환경에서는 다음과 같은 패턴의 쿼리들은 안전하지 않다.
      * 트랜잭션을 지원하는 테이블과 지원하지 않는 테이블을 함께 변경하는 쿼리 혹은 트랜잭션
      * CRAETE TABLE ... SELECT ... 구문
      * 트랜잭션 내에서 CREATE TEMPORARY TABLE. DROP TEMPORARY TABLE 구문 사용
      *  ➡️ 특징: 소스 서버에서 레플리카 서버로 복제되어 적용될 때 단일 트랜잭션으로 처리되지 않을 수도 있다. GTID가 트랜잭션 단위로 올바르게 할당돼야 복제가 정상적으로 동작한다.
      *  `enforce_gtid_consistency`: 쿼리들의 실행 가능 여부 제어
      *  `gtid_mode`: 바이너리 로그에 트랜잭션들이 GTID 기반으로 로깅될 수 있는지 여부, 트랜잭션 유형별로 MySQL 서버에서의 처리 가능 여부 제어
  * GTID 기반 복제 제약 사항
    * GTID가 활성화된 MySQL 서버에서는 `enforce_gtid_consistency=ON` 옵션으로 인해 GTID 일관성을 해칠 수 있는 일부 유형의 쿼리들은 실행할 수 없다.
    * GTID 기반 복제가 설정된 레플리카 서버에서는 sql_slave_skip_counter 시스템 변수를 사용해 복제된 트랜잭션을 건너뛸 수 없다.
    * GTID 기반 복제에서 CHANGE REPLICATION SOURCE TO(또는 CHANGE MASTER TO) 구문의 IGNORE_SERVER_IDS 옵션은 더 이상 사용되지 않는다.

## 🦅 16.4 복제 데이터 포맷
* **Statement 기반 바이너리 로그 포맷**
  * 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식이다.
  * 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데, 이 경우 Statement 포맷에서는 바이너리 로그에 SQL문 하나만 기록된다.
  * 장점
    * 바이너리 로그 파일의 용량이 작아지므로 사용자 입장에서는 저장 공간에 대한 부담을 덜 수 있으며, 원격으로 바이너리 로그를 백업하거나 혹은 원격에 위치한 레플리카 서버와 복제할 때도 좀 더 빠르게 처리될 수 있다.
  * 단점
    * 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.
    * Statement 포맷 기반 복제에서 소스 서버와 레플리카 서버 간의 데이터 일관성을 해칠 수 있는 비확정적 쿼리 유형
      * DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
      * SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
      * LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
      * 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리
    * Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다.
    * Statement 기반 바이너리 로그 포맷은 트랜잭션 격리 수준이 반드시 "REPEATABLE-READ" 이상이어야 한다.
* **Row 기반 바이너리 로그 포맷**
  * MySQL 서버에서 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식이다.
  * Row 포맷에서는 소스 서버에서 실행된 쿼리가 UUID(), USER() 등과 같은 비확정적 함수를 사용했다 하더라도 레플리카 서버에서 똑같이 이 함수가 다시 실행되는 것이 아니라 함수의 결괏값을 전달받아 처리되므로 이 같은 경우에 있어서도 안전하게 복제가 가능하다.
  * 다음과 같은 쿼리들이 실행되는 경우 Statement 포맷보다 락이 최소화되어 처리된다.
    * INSERT ... SELECT
    * INSERT with AUTO_INCREMENT
    * 적절한 인덱스가 없어 풀스캔으로 처리되는 UPDATE/DELETE
  * 변경된 데이터가 그대로 바이너리 로그에 기록되기 때문에 만약 MySQL 서버에서 실행된 쿼리가 굉장히 많은 데이터를 변경한 경우에는 변경된 데이터가 전부 기록되므로 바이너리 로그 파일 크기가 단시간에 매우 커질 수 있다.
* **Mixed 포맷**
  * 사용자는 MySQL 서버가 두 가지 바이너리 로그 포맷을 혼합해서 사용하도록 설정할 수 있다.
  * MIXED 방식을 사용하면 Statement 포맷과 Row 포맷의 장점만 취해서 사용하는 것으로 생각할 수 있지만 MySQL 서버가 내부적으로 설정된 기준과 기술적인 측면을 고려새 자동으로 두 포맷을 번갈아 사용하는 것이므로 예상했던 것과 다르게 처리될 수도 있다.
  * 따라서 MIXED 포맷만이 제일 좋은 방법이라고 할 수는 없으며, 사용자는 자신이 사용하는 쿼리 형태에 제일 적합한 방식이 어떤 방식인지를 고려해서 설정하는 것이 좋다.
* **Row 포맷의 용향 최적화**</br>
  사용자들이 Row 기반의 바이너리 포맷을 사용할지 망설이는 대표적인 이유는 바이너리 로그 파일의 용량이 Statement 포맷을 사용할 때보다 많이 커질 수 있다는 점이다.
  * 바이너리 로그 Row 이미지
    * MySQL에서는 Row 포맷의 바이너리 로그 파일 용량을 최소화하기 위해 저장되는 변경 데이터의 칼럼 구성을 제어하는 `binlog_row_image`라는 시스템 변수를 제공한다.
    * Row 포맷을 사용할 경우 바이너리 로그에는 각 변경 데이터마다 변경 전 레코드(Before-Image)와 변경 후 레코드(After-Image)가 함께 저장되는데, `binlog_row_image` 시스템 변수는 각 변경 전후 레코드들에 대해 테이블의 어떤 칼럼들을 기록할 것인지를 결정한다.
    * 옵션: full, minimal, noblob
  * 바이너리 로그 트랜잭션 압축

## 🦅 16.5 복제 동기화 방식
* **비동기 복제(Asynchronous replication)**
  * MySQL의 복제는 기본적으로 비동기 방식으로 동작한다. 비동기 방식이란 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식이다.
  * 비동기 복제 방식에서 소스 서버는 레플리카 서버로 변경 이벤트가 잘 전달됐는지, 실제로 적용됐는지 할지 못하며 이에 대한 어떠한 보장도 하지 않는다.
  * 비동기 복제는 소스 서버가 각 트랜잭션에 대해 레플리카 서버로 전송되는 부분을 고려하지 않기 때문에 트랜잭션 처리에 있어서도 좀 더 빠른 성능을 보이고, 아울러 레플리카 서버에 문제가 생기더라도 소스 서버는 아무런 영향도 받지 않는다는 장점이 있다.
  * 비동기 복제 방식은 소스 서버에 레플리카 서버를 여러 대 연결한다 해도 소스 서버에서 큰 성능 저하가 없으므로 레플리카 서버를 확장해서 읽기 트래픽을 분산하는 용도로 제격이라 할 수 있다.
* **반동기 복제(Semi-synchronous replication)**
  * 반동기 복제에서 소스 서버는 레플리카 서버가 소스 서버로 부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 그 때 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환한다.
  * 따라서 반동기 복제에서는 소스 서버에서 커밋되어 정상적으로 결과가 반환된 모든 트랜잭션들에 대해 적어도 하나의 레플리카 서버에서는 해당 트랜잭션들이 전송됐음을 보장한다.
  * 중요한 부분은 레플리카 서버에 "전송"됐음을 보장한다는 것이지, 실제로 복제된 트랜잭션이 레플리카 서버에 "적용"되는 것까지 보장한다는 것은 아니다. 그래서 이 동기화 방식의 이름이 반동기인 것이다.
  * 반동기 복제에서는 소스 서버가 트랜잭션 처리 중 어느 지점에서 레플리카 서버의 응답(ACK)을 기다리느냐에 따라 소스 서버에서 장애가 발생했을 때 사용자가 겪을 수 있는 문제 상황이 조금 다를 수 있다.
    * rpl_semi_sync_master_point 시스템 변수가 `AFTER_COMMIT`
    * rpl_semi_sync_master_point 시스템 변수가 `AFTER_SYNC`
      * 소스 서버에 장애가 발생했을 때 팬텀 리드(Phantom Read)가 발생하지 않음
      * 장애가 발생한 소스 서버에 대해 좀 더 수월하게 복구 처리가 가능
        
## 🦅 16.6 복제 토폴로지
* **싱글 레플리카 복제 구성**
  * 싱글 레플리카 복제는 하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태를 말한다.
  * 이렇게 소스 서버와 레플리카 서버가 일대일로 구성된 형태에서는 레플리카 서버를 정말 예비용 서버로서만 사용하는 게 제일 적합하다고 할 수 있다.
* **멀티 레플리카 복제 구성**
  * 멀티 레플리카 복제는 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태를 말한다.
  * 서비스 트래픽이 크게 증가하면 소스 서버 한 대에서만 쿼리 요청을 처리하기에는 벅찰 수 있는데, 이렇게 증가된 쿼리 요청은 대부분의 경우 쓰기보다는 읽기 요청이 더 많으므로 사용자는 멀티 레플리카 형태로 복제 구성을 전환해 읽기 요청 처리를 분산시킬 수 있다.
* **체인 복제 구성**
  * 멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능에 악영향이 예상된다면 1:M:M 구조의 체인 복제 구성을 고려해 볼 수 있다.
  * 만약 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있다.
  * 이 복제 형태는 MySQL 서버를 업그레이드하거나 장비를 일괄 교체할 때도 많이 사용된다.
  * 체인 복제 구성을 사용할 때는 중간 계층의 서버에서 장애가 발생하는 경우 하위 계층의 레플리카 서버들도 복제가 중단된다. 따라서 장애를 처리할 때 복잡도가 좀 더 높을 수 있다는 점에 유의해야 한다.
* **듀얼 소스 복제 구성**
  * 듀얼 소스 복제 구성은 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태를 말한다.
  * 듀얼 소스 구성은 두 MySQL 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징이며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기가 발생하지만 두 서버는 서로 동일한 데이터를 갖게 된다.
  * 듀얼 소스 복제 구성을 사용할 때는 다음과 같은 부분에서 문제가 발생할 수 있다.
    * 동일한 데이터를 각 서버에서 변경
    * 테이블에서 Auto-Increment 키 사용
* **멀티 소스 복제 구성**
  * 멀티 소스 복제 구성은 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태를 말한다.
  * 멀티 소스 복제 구성은 주로 다음과 같은 목적으로 사용된다.
    * 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
    * 여러 MySQL 서버에 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
    * 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행
    * ➡️ 분석에 필요한 데이터들이 여러 곳에 나눠져 있어 이를 한곳으로 모아 좀 더 빠르고 편리하게 분석을 수행하고자 할 때 멀티 소스 복제 형태를 사용하면 매우 효율적이다.
    * ➡️ 또한 늘어날 서비스 트래픽에 대비해 사전에 MySQL 서버들을 동일한 테이블 스키마 구조를 가지는 샤드 형태(분산해서 사용하는 형태)로 구성해뒀으나 예상했던 것만큼 트래픽이 유입되지 않은 경우 멀티 소스 복제를 구성해서 샤딩된 테이블들의 데이터를 통합해 MySQL 서버 수를 줄일 수도 있다.
  * **멀티 소스 복제 동작**
    * MySQL의 멀티 소스 복제에서 레플리카 서버는 자신과 연결된 소스 서버들의 변경 이벤트들을 동시점에, 병렬로 동기화한다.
    * 이는 각 소스 서버들에 대한 복제가 독립적으로 처리되는 것을 의미하며, 각각의 독립된 복제 처리를 채널(Channel)이라고 한다.
    * 각 복제 채널은 개별적인 레플리케이션 I/O 스레드, 릴레이 로그, 레플리케이션 SQL 스레드를 가지며, 채널의 이름은 어느 소스 서버와의 복제 연결인지를 구별할 수 있는 식별자 역할을 한다.
  * **멀티 소스 복제 구축**
    * 멀티 소스 복제로 연결할 소스 서버들 중에서 두 개 이상의 소스 서버에서 데이터를 가져와야 한다면 mysql 데이터베이스와 같이 공통으로 가지고 있는 데이터베이스와 InnoDB의 시스템 테이블 스페이스의 충돌과 병합을 고려해야 한다.
      * mysqldump와 같은 논리 수준의 백업 도구 이용
      * XtraBackup과 같은 물리 수준의 백업 도구 이용
      * ➡️ 서버가 갖고 있는 데이터가 크다면 XtraBackup을, 갖고 있는 데이터가 크지 않다면 mysqldump를 사용한다.

## 🦅 16.7 복제 고급 설정
* **지연된 복제(Delayed Replication)**
  * 소스 서버에서 실수로 중요한 테이블이나 데이터를 삭제했을 경우같은 문제 상황에 조금 더 유연하게 대처할 수 있도록 MySQL에서는 지연된 복제 기능을 제공한다.
  * 사용자는 지연된 복제본을 통해 바로 데이터 복구가 가능하다.
  * 또한 지연된 복제 기능은 데이터 반영에 지연이 있을 때 어떻게 서비스가 동작하는지 테스트할 때도 매우 유용하다.
  * 레플리카 서버를 소스 서버로부터 얼마나 지연시킬 것인지 지정할 수 있다.
* **멀티 스레드 복제(Multi-threaded Replication)**
  * MySQL 복제에서는 레플리카 서버에서 소스 서버로부터 복제된 트랜잭션들을 하나의 스레드가 아닌 여러 스레드로 처리할 수 있게 하는 멀티 스레드 복제 기능을 제공한다.
  * 소스 서버에서는 여러 세션에서 실행된 DML 쿼리들이 동시에 처리되는데, 만약 소스 서버에서 짧은 시간 동안 다향의 DML 쿼리가 실행되는 경우 레플리카 서버에서는 하나의 스레드가 모든 트랜잭션을 처리하므로 복제 동기화에 지연이 발생한다.
  * 코디네이터 스레드, 워커 스레드
  * **데이터베이스 기반 멀티 스레드 복제**
    * 데이터베이스 기반 멀티 스레드 복제는 MySQL 내의 데이터베이스 단위로 병렬 처리를 수행하는 형태를 말한다.
    * 따라서 만약 MySQL 서버에 데이터베이스가 하나밖에 존재하지 않는다면 이 멀티 스레드 방식은 아무런 장점을 가지지 못한다.
  * **LOGICAL CLOCK 기반 멀티 스레드 복제**
    * 데이터베이스 기반 멀티 스레드 복제에서는 MySQL 서버에 하나의 데이터베이스만 존재하는 경우 멀티 스레드로 처리될 수 없다는 큰 단점이 있었다.
    * 또한 여러 개의 데이터베이스가 있다 하더라도 데이터베이스별로 발생하는 DML 쿼리 양이 균등하지 않고 특정 데이터베이스로만 쿼리 요청이 집중되는 경우에는 여전히 레플리카 서버에서 쉽게 복제 지연이 발생할 수 있다는 것도 아쉬운 점 중 하나였다.
    * LOGICAL CLOCK 방식은 소스 서버에서 트랜잭션들이 바이너리 로그로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 정해진 기준에 따라 병렬로 실행할 수 있게 하는 방식이다.
    * **바이너리 로그 그룹 커밋**
      * 여러 트랜잭션에 대한 커밋을 동시에 진행할 수 있게 코드가 바뀌었고 바이너리 로그 단의 처리 또한 여러 트랜잭션을 함께 처리할 수 있도록 바이너리 로그 그룹 커밋 기능이 도입됐다.
      * (1) Flush 단계, (2) Sync 단계, (3) Commit 단계
    * **Commit-parent 기반 LOGICAL CLOCK 방식**
      * Commit-parent 기반 LOGICAL CLOCK 방식은 동일 시점에 커밋된 트랜잭션들을 레플리카 서버에서 병렬로 실행될 수 있게 한다.
      * 커밋 시점이 같은 트랜잭션들은 잠금 경합 등과 같이 서로 충돌하는 부분이 없는 트랜잭션들이므로 병렬로 실행될 수 있다.
      * 같은 시점에 커밋 처리가 시작된 트랜잭션들은 동일한 commit_seq_no 값을 갖게 되며, 레플리카 서버에서는 복제된 트랜잭션들의 commit_seq_no 값을 바탕으로 같은 값을 가진 트랜잭션들을 병렬로 처리하게 된다.
    * **잠금(Lock) 기반 LOGICAL CLOCK 방식**
      * 기존 Commit-parent 기반 방식에서는 단순하게 마지막으로 커밋된 선행 트랜잭션의 순번 값(commit_seq_no 값)이 동일한 트랜잭션들만 레플리카 서버에서 병렬로 처리할 수 있었다.
      * 그러나 잠금 기반 방식에서는 선행 트랜잭션의 순번 값이 동일하지 않더라도 커밋 처리 시점이 겹친다면 그 트랜잭션들은 레플리카 서버에서 병렬로 처리될 수 있다.
    * **WriteSet 기반 LOGICAL CLOCK 방식**
      * 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정한다.
      * WriteSet 기반 방식에서는 각 트랜잭션에서 변경한 데이터를 기준으로 병렬 처리를 위한 트랜잭션들의 종속 관계를 정의하므로 이를 위해 내부적으로 트랜잭션에 의해 변경된 데이터들의 목록을 관리한다.
  * **멀티 스레드 복제와 복제 포지션 정보**
* **크래시 세이프 복제(Crash-safe Replication)**
  * 서버 장애와 복제 실패
  * 복제 사용 형태별 크래시 세이프 복제 설정
    * 바이너리 로그 파일 위치 기반 복제 + 싱글 스레드 동기화
    * 바이너리 로그 파일 위치 기반 복제 + 멀티 스레드 동기화
    * GTID 기반 복제 + 싱글 스레드 동기화
    * GTID 기반 복제 + 멀티 스레드 동기화
* **필터링된 복제(Filtered Replication)**
