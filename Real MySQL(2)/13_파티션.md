## 🦅 13.1 개요
파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해준다.
* **파티션을 사용하는 이유**
  * 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리
    * 큰 테이블을 파티션하지 않고 하나의 큰 테이블로 사용하면 인덱스도 커지고 그만큼 물리적인 메모리 공간도 많이 필요해진다.
    * 결과적으로 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.
    * 💡 워킹 셋: 활발하게 사용되는 데이터(ex) 게시물 테이블. 100만 건이 저장된 테이블이라고 하더라도 그중에서 최신 20~30%의 게시물만 활발하게 조회된다.)
  * 데이터의 물리적인 저장소를 분리
    * 데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려워진다. 더욱이 테이블의 데이터나 인덱스를 파일 단위로 관리하는 MySQL에서 더 치명적인 문제가 될 수도 있다.
    * 이러한 문제는 파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분해서 지정해 해결하는 것도 가능하다. 하지만 MySQL에서는 테이블의 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 지원하지 않는다.
  * 이력 데이터의 효율적인 관리
    * 로그 테이블에서 불필요해진 데이터를 백업하거나 삭제하는 작업은 일반 테이블에서는 상당히 고부하의 작업에 속한다.
    * 로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결할 수 있다.
* **MySQL 파티션의 내부 처리**
  * 파티션 테이블의 레코드 INSERT
    * INSERT 쿼리가 실행되면 MySQL 서버는 INSERT되는 칼럼의 값 중에서 파티션 키인 칼럼의 값을 이용해 파티션 표현식을 평가 후 그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정한다. 
  * 파티션 테이블의 UPDATE
    * 파티션 키 이외의 칼럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경한다.
    * 파티션 키 칼럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다. 그리고 변경되는 파티션 키 칼럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.
  * 파티션 테이블의 검색
    * 파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건
      * WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
      * WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔)할 수 있는가?
    * 위 두 가지 주요 선택사항의 각 조합. 어떻게 실행되는지
      * 파티션 선택 가능 + 인덱스 효율적 사용 가능
        * 파티션의 개수와 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔
      * 파티션 선택 불가 + 인덱스 효율적 사용 가능
        * WHERE 조건에 일치하는 레코드가 저장된 파티션을 걸러낼 수 없기 때문에 우선 테이블의 모든 파티션을 대상으로 검색해야 한다.
        * 하지만 각 파티션에 대해서는 인덱스 레인지 스캔을 사용할 수 있기 때문에 최종적으로 테이블에 존재하는 모든 파티션의 개수만큼 인덱스 레인지 스캔을 수행해서 검색하게 된다.
      * 파티션 선택 가능 + 인덱스 효율적 사용 불가
        * 검색하려는 레코드가 저장된 파티션을 선별할 수 있기 때문에 파티션 개수와 관계없이 검색을 위해 필요한 파티션만 읽으면 된다.
        * 하지만 인덱스는 이용할 수 없기 때문에 대상 파티션에 대해 풀 테이블 스캔을 한다. 이는 각 파티션의 레코드 건수가 많으면 상당히 느리게 처리될 것이다.
      * 파티션 선택 불가 + 인덱스 효율적 사용 불가
        * WHERE 조건에 일치하는 파티션을 선택할 수가 없기 때문에 테이블의 모든 파티션을 검색해야 한다.
        * 하지만 각 파티션을 검색하는 작업 자체도 인덱스 레인지 스캔을 사용할 수 없기 때문에 풀 테이블 스캔을 수행해야 한다.
  * 파티션 테이블의 인덱스 스캔과 정렬
    * 실제 MySQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐(Priority Queue)에 임시로 저장한다. 그리고 우선순위 큐에서 다시 필요한 순서(인덱스의 정렬 순서)대로 데이터를 가져간다.
    * 결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 **MySQL 서버가 별도의 정렬 작업을 수행하지는 않는다.**
    * 하지만 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하는 것이 아니라 내부적으로 큐 처리가 한 번 필요한 것이다.
  * 파티션 프루닝
    * 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝(Partition pruning)이라고 한다.

## 🦅 13.2 주의사항
* **파티션의 제약 사항**
  * 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없다.
  * 파티션 표현식을 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 여기서 일부 함수들은 파티션 생성은 가능하지만 파티션 프루닝을 지원하지 않을 수도 있다.
  * 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 한다.
  * 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있다. 또한 파티션 개별로 인덱스를 변경하거나 추가할 수 있다.
  * 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있다.
  * 최대(서브 파티션까지 포함해서) 8192개의 파티션을 가질 수 있다.
  * 파티션 생성 이후 MySQL 서버의 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 수 있다.
  * 파티션 테이블에서는 외래키를 사용할 수 없다.
  * 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없다.
  * 공간 데이터를 저장하는 칼럼 타입(POINT, GEOMETRY, ...)은 파티션 테이블에서 사용할 수 없다.
  * 임시 테이블(Temporary table)은 파티션 기능을 사용할 수 없다.
* **파티션 사용 시 주의사항**
  * 파티션과 유니크 키(프라이머리 키 포함)
    * 종류와 관계없이 테이블에 유니크 인덱스(프라이머리 키 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.
  * 파티션과 open_files_limit 시스템 변수 설정
    * MySQL에서는 일반적으로 테이블을 파일 단위로 관리하기 때문에 MySQL 서버에서 동시에 오픈된 파일의 개수가 상당히 많아질 수 있다. 이를 제한하기 위해 open_files_limit 시스템 변수에 동시에 오픈할 수 있는 적절한 파일의 개수를 설정할 수 있다.

## 🦅 13.3 MySQL 파티션의 종류
* **레인지 파티션**</br>
  파티션 키의 연속된 범위로 파티션을 정의하는 방법으로, 가장 일반적으로 사용되는 파티션 방법 중 하나다.
  * 레인지 파티션의 용도
    * 다음과 같은 성격을 지닌 테이블에서는 레인지 파티션을 사용하는 것이 좋다.
      * 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
      * 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
      * 파티션 키 위주로 검색이 자주 실행될 때
    * 데이터베이스에서 파티션의 장점
      * 큰 테이블을 작은 크기의 파티션으로 분리
      * 필요한 파티션만 접근(쓰기와 읽기 모두)
  * 레인지 파티션 테이블 생성
    * `PARTITION BY RANGE()`
  * 레인지 파티션의 분리와 병합
    * 단순 파티션의 추가
      * 테이블에 이미 `LESS THAN MAXVALUE` 파티션을 가지고 있는 경우, 새로운 파티션을 추가하려고 하면 에러가 발생한다.
      * 이럴 경우, `ALTER TABLE ... REORGANIZE PARTITION` 명령을 사용해야 한다.
    * 파티션 삭제
      * `DROP PARTITION 삭제할 파티션 이름`
      * 레인지 파티션을 사용하는 테이블에서 파티션을 삭제하는 경우, **항상 가장 오래된 파티션 순서로만 삭제할 수 있다.** 레인지 파션이 4개가 있는데, 중간에 있는 파티션을 먼저 삭제할 수는 없다.
    * 기존 파티션의 분리
      * `REORGANIZE PARTITION`: 하나의 파티션을 두 개 이상의 파티션으로 분리하고자 할 때 사용
      * REORGANIZE PARTITION 명령은 기존 파티션의 레코드를 새로운 파티션으로 복사해야 하기 때문에 기존 파티션의 레코드 건수에 따라 시간이 오래 걸릴 수도 있다.
      * 파티션이 재구성되는 동안은 테이블의 쓰기가 불가능해지므로 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에 진행하는 것이 좋다. 
    * 기존 파티션의 병합
      * 파티션을 병합하는 경우에도 파티션 재구성(REORGANIZE PARTITION)이 필요하며, 이 작업을 테이블에 대해서 읽기 잠금을 필요로 한다.
* **리스트 파티션**</br>
  리스트 파티션은 레인지 파티션과 많은 부분에서 흡사하게 동작한다. **둘의 가장 큰 차이는 레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다는 점이다. 또한 리스트 파티션에서는 레인지 파티션과 같이 MAXVALUE 파티션을 정의할 수 없다.**
  * 리스트 파티션의 용도
    * 다음과 같은 특성을 지닐 때는 리스트 파티션을 사용하는 것이 좋다.
      * 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
      * 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
      * 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때
  * 리스트 파티션 테이블 생성
    * `PARTITION BY LIST`: 생성할 파티션이 리스트 파티션이라는 것을 명시
    * VALUES IN (...)을 사용해 파티션별로 저장할 파티션 키 값의 목록을 나열한다.
  * 리스트 파티션의 분리와 병합
    * 파티션을 정의하는 부분에서 VALUES LESS THAN이 아닌 VALUES IN을 사용한다는 것 외에는 레인지 파티션의 추가 및 삭제, 병합 작업이 모두 같다.
  * 리스트 파티션 주의사항
    * 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
    * 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.
* **해시 파티션**
  * 해시 파티션의 용도
    * 다음과 같은 특성을 지닐 때는 해시 파티션을 사용하는 것이 좋다.
      * 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
      * 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때
  * 해시 파티션 테이블 생성
    * `PARTITION BY HASH`: 파티션 종류를 해시 파티션으로 지정
    * 해시 파티션의 파티션 키 또는 파티션 표현식은 반드시 정수 타입의 값을 반환해야 한다.
  * 해시 파티션의 분리와 병합
    * 해시 파티션 추가
      * 해시 파티션은 특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정한다. 즉, 해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변하는 것이다.
      * 따라서 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다.
      * 해시 파티션에서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시키며, 다른 트랜잭션에서 동일 테이블에 데이터를 변경(`INSERT`, `UPDATE`, `DELETE`)하는 작업은 허용되지 않는다.
    * 해시 파티션 삭제
      * MySQL 서버가 지정한 파티션 키 값을 가공해서 데이터를 각 파티션으로 분산한 것이므로 각 파티션에 저장된 레코드가 어떤 부류의 데이터인지 사용자가 예측할 수가 없다.
      * 결국 해시 파티션이나 키 파티션을 사용한 테이블에서 파티션 단위로 데이터를 삭제하는 작업은 의미도 없으며 해서도 안 될 작업이다.
    * 해시 파티션 분할
      * 해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능하다.
    * 해시 파티션 병합
      * 해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능을 제공하지 않는다. 단지 파티션의 개수를 줄이는 것만 가능하다.
      * `COALESCE PARTITION 줄이고자 하는 파티션의 개수`: 파티션의 개수를 줄이는 명령어
    * 해시 파티션 주의사항
      * 특정 파티션만 삭제(DROP PARTITION)하는 것은 불가능하다.
      * 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존 모든 데이터의 재배치 작업이 필요하다.
      * 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요하다.
      * 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특정은 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많다. 해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요하다.
* **키 파티션**
  * 키 파티션의 생성
    * `PARTITION BY KEY`: 키 파티션을 정의한다.
    * `PARTITIONS`: 생성할 파티션 개수를 지정한다.
  * 키 파티션의 주의사항 및 특이사항
    * 키 파티션은 MySQL 서버가 내부적으로 MD5() 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 된다. 해시 파티션으로 파티션이 어렵다면 키 파티션 적용을 고려해보자.
    * 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있다.
    * 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 한다.
    * 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 떄문에 키 파티션이 더 효율적이다.
* **리니어 해시 파티션/리니어 키 파티션**
  * 리니어 해시 파티션/리니어 키 파티션의 추가 및 통합
    * 리니어 해시 파티션이나 리니어 키 파티션의 경우 단순히 나머지 연산으로 레코드가 저장될 파티션을 결정하는 것이 아니라 "Power-of-two" 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 된다.
    * 그래서 파티션을 추가하거나 통합하는 작업에서 나머지 파티션의 데이터는 재분배 대상이 되지 않는 것이다.
  * 리니어 해시 파티션/리니어 키 파티션의 추가
    * 새로운 파티션을 주가할 때 특정 파티션의 레코드만 재분배되면 된다.
    * 다른 파티션 데이터는 레코드 재분배 작업과 관련이 없기 때문에 일반 해시 파티션이나 키 파티션의 파티션 추가보다 매우 빠르게 처리할 수 있다.
  * 리니어 해시 파티션/리니어 키 파티션의 통합
    * 새로운 파티션을 추가할 때와 같이 일부 파티션에 대해서만 레코드 통합 작업이 필요하다.
    * 통합되는 파티션만 레코드 이동이 필요하며, 나머지 파티션의 레코드는 레코드 재분배 작업에서 제외된다.
  * 리니어 해시 파티션/리니어 키 파티션과 관련된 주의사항
    * 리니어 파티션은 "Power-of-two" 알고리즘을 사용하기 때문에 파티션을 추가하거나 통합할 때 작업의 범위를 최소화하는 대신 각 파티션이 가지는 레코드의 건수는 일반 해시 파티션이나 키 파티션보다는 덜 균등해질 수 있다.
    * 해시 파티션이나 키 파티션을 사용하는 테이블에 대해 새로운 파티션을 추가하거나 삭제해야 할 요건이 많다면 리니어 해시 파티션 또는 리니어 키 파티션을 적용하는 것이 좋다.
    * 파티션을 조정할 필요가 거의 없다면 일반 해시 파티션이나 키 파티션을 사용하는 것이 좋다.
* **파티션 테이블의 쿼리 성능**
  * **쿼리의 성능은 테이블에서 얼마나 많은 파티션을 프루닝할 수 있는지가 관건이다.**
